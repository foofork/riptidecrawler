// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
//
// SAFETY: This file contains multiple `mem::forget` calls throughout.
// These are REQUIRED for the WASM Component Model FFI boundary.
//
// All `mem::forget(vec)` calls follow this pattern:
// 1. A Rust Vec/String is converted to a boxed slice
// 2. The pointer and length are extracted
// 3. `mem::forget` prevents Rust from dropping the value
// 4. The WASM runtime takes ownership of the memory
//
// Without `mem::forget`, Rust would drop the memory, causing a double-free
// when the WASM runtime attempts to free the same memory later.
//
// This is the standard pattern for transferring heap-allocated data across
// the WASM FFI boundary as specified by the Component Model.

/// Content extraction modes with specific behaviors
#[derive(Clone)]
pub enum ExtractionMode {
    /// Extract article content using readability algorithms
    Article,
    /// Extract full page content including sidebars and navigation
    Full,
    /// Extract only metadata (title, description, structured data)
    Metadata,
    /// Custom extraction using provided CSS selectors
    Custom(_rt::Vec<_rt::String>),
}
impl ::core::fmt::Debug for ExtractionMode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            ExtractionMode::Article => f.debug_tuple("ExtractionMode::Article").finish(),
            ExtractionMode::Full => f.debug_tuple("ExtractionMode::Full").finish(),
            ExtractionMode::Metadata => {
                f.debug_tuple("ExtractionMode::Metadata").finish()
            }
            ExtractionMode::Custom(e) => {
                f.debug_tuple("ExtractionMode::Custom").field(e).finish()
            }
        }
    }
}
/// Comprehensive extraction result with rich metadata
#[derive(Clone)]
pub struct ExtractedContent {
    /// Source URL for context and link resolution
    pub url: _rt::String,
    /// Extracted page title
    pub title: Option<_rt::String>,
    /// Author/byline information
    pub byline: Option<_rt::String>,
    /// Publication date in ISO 8601 format
    pub published_iso: Option<_rt::String>,
    /// Content formatted as Markdown
    pub markdown: _rt::String,
    /// Plain text content with HTML tags removed
    pub text: _rt::String,
    /// List of extracted hyperlinks
    pub links: _rt::Vec<_rt::String>,
    /// List of media URLs (images, videos, audio)
    pub media: _rt::Vec<_rt::String>,
    /// Detected content language (ISO 639-1 code)
    pub language: Option<_rt::String>,
    /// Estimated reading time in minutes
    pub reading_time: Option<u32>,
    /// Content quality score (0-100, higher = better)
    pub quality_score: Option<u8>,
    /// Word count of extracted text
    pub word_count: Option<u32>,
    /// Content categories/tags if detected
    pub categories: _rt::Vec<_rt::String>,
    /// Site name/publisher if available
    pub site_name: Option<_rt::String>,
    /// Meta description from page
    pub description: Option<_rt::String>,
}
impl ::core::fmt::Debug for ExtractedContent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ExtractedContent")
            .field("url", &self.url)
            .field("title", &self.title)
            .field("byline", &self.byline)
            .field("published-iso", &self.published_iso)
            .field("markdown", &self.markdown)
            .field("text", &self.text)
            .field("links", &self.links)
            .field("media", &self.media)
            .field("language", &self.language)
            .field("reading-time", &self.reading_time)
            .field("quality-score", &self.quality_score)
            .field("word-count", &self.word_count)
            .field("categories", &self.categories)
            .field("site-name", &self.site_name)
            .field("description", &self.description)
            .finish()
    }
}
/// Structured error types for better error handling
#[derive(Clone)]
pub enum ExtractionError {
    /// Invalid or malformed HTML input
    InvalidHtml(_rt::String),
    /// Network-related errors during processing
    NetworkError(_rt::String),
    /// HTML parsing failures
    ParseError(_rt::String),
    /// Resource limits exceeded (memory, time, etc.)
    ResourceLimit(_rt::String),
    /// Trek-rs library errors
    ExtractorError(_rt::String),
    /// Component internal processing errors
    InternalError(_rt::String),
    /// Unsupported extraction mode
    UnsupportedMode(_rt::String),
}
impl ::core::fmt::Debug for ExtractionError {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            ExtractionError::InvalidHtml(e) => {
                f.debug_tuple("ExtractionError::InvalidHtml").field(e).finish()
            }
            ExtractionError::NetworkError(e) => {
                f.debug_tuple("ExtractionError::NetworkError").field(e).finish()
            }
            ExtractionError::ParseError(e) => {
                f.debug_tuple("ExtractionError::ParseError").field(e).finish()
            }
            ExtractionError::ResourceLimit(e) => {
                f.debug_tuple("ExtractionError::ResourceLimit").field(e).finish()
            }
            ExtractionError::ExtractorError(e) => {
                f.debug_tuple("ExtractionError::ExtractorError").field(e).finish()
            }
            ExtractionError::InternalError(e) => {
                f.debug_tuple("ExtractionError::InternalError").field(e).finish()
            }
            ExtractionError::UnsupportedMode(e) => {
                f.debug_tuple("ExtractionError::UnsupportedMode").field(e).finish()
            }
        }
    }
}
impl ::core::fmt::Display for ExtractionError {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "{:?}", self)
    }
}
impl std::error::Error for ExtractionError {}
/// Component health status
#[derive(Clone)]
pub struct HealthStatus {
    /// Overall component health
    pub status: _rt::String,
    /// Component version
    pub version: _rt::String,
    /// Trek-rs library version
    pub trek_version: _rt::String,
    /// Supported extraction modes
    pub capabilities: _rt::Vec<_rt::String>,
    /// Memory usage in bytes
    pub memory_usage: Option<u64>,
    /// Number of extractions performed
    pub extraction_count: Option<u64>,
}
impl ::core::fmt::Debug for HealthStatus {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("HealthStatus")
            .field("status", &self.status)
            .field("version", &self.version)
            .field("trek-version", &self.trek_version)
            .field("capabilities", &self.capabilities)
            .field("memory-usage", &self.memory_usage)
            .field("extraction-count", &self.extraction_count)
            .finish()
    }
}
/// Component information and metadata
#[derive(Clone)]
pub struct ComponentInfo {
    /// Component name
    pub name: _rt::String,
    /// Component version
    pub version: _rt::String,
    /// Component model interface version
    pub component_model_version: _rt::String,
    /// Enabled features
    pub features: _rt::Vec<_rt::String>,
    /// Supported extraction modes
    pub supported_modes: _rt::Vec<_rt::String>,
    /// Build timestamp
    pub build_timestamp: Option<_rt::String>,
    /// Git commit hash if available
    pub git_commit: Option<_rt::String>,
}
impl ::core::fmt::Debug for ComponentInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ComponentInfo")
            .field("name", &self.name)
            .field("version", &self.version)
            .field("component-model-version", &self.component_model_version)
            .field("features", &self.features)
            .field("supported-modes", &self.supported_modes)
            .field("build-timestamp", &self.build_timestamp)
            .field("git-commit", &self.git_commit)
            .finish()
    }
}
/// Statistics for extraction operation
#[repr(C)]
#[derive(Clone, Copy)]
pub struct ExtractionStats {
    /// Time taken for extraction in milliseconds
    pub processing_time_ms: u64,
    /// Memory used during extraction in bytes
    pub memory_used: u64,
    /// Number of DOM nodes processed
    pub nodes_processed: Option<u32>,
    /// Number of links found
    pub links_found: u32,
    /// Number of images found
    pub images_found: u32,
}
impl ::core::fmt::Debug for ExtractionStats {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ExtractionStats")
            .field("processing-time-ms", &self.processing_time_ms)
            .field("memory-used", &self.memory_used)
            .field("nodes-processed", &self.nodes_processed)
            .field("links-found", &self.links_found)
            .field("images-found", &self.images_found)
            .finish()
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_extract_cabi<T: Guest>(
    arg0: *mut u8,
    arg1: usize,
    arg2: *mut u8,
    arg3: usize,
    arg4: i32,
    arg5: *mut u8,
    arg6: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let len1 = arg3;
    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
    let v6 = match arg4 {
        0 => ExtractionMode::Article,
        1 => ExtractionMode::Full,
        2 => ExtractionMode::Metadata,
        n => {
            debug_assert_eq!(n, 3, "invalid enum discriminant");
            let e6 = {
                let base5 = arg5;
                let len5 = arg6;
                let mut result5 = _rt::Vec::with_capacity(len5);
                for i in 0..len5 {
                    let base = base5.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                    let e5 = {
                        let l2 = *base.add(0).cast::<*mut u8>();
                        let l3 = *base
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len4 = l3;
                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                        _rt::string_lift(bytes4)
                    };
                    result5.push(e5);
                }
                _rt::cabi_dealloc(
                    base5,
                    len5 * (2 * ::core::mem::size_of::<*const u8>()),
                    ::core::mem::size_of::<*const u8>(),
                );
                result5
            };
            ExtractionMode::Custom(e6)
        }
    };
    let result7 = T::extract(_rt::string_lift(bytes0), _rt::string_lift(bytes1), v6);
    let ptr8 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result7 {
        Ok(e) => {
            *ptr8.add(0).cast::<u8>() = (0i32) as u8;
            let ExtractedContent {
                url: url9,
                title: title9,
                byline: byline9,
                published_iso: published_iso9,
                markdown: markdown9,
                text: text9,
                links: links9,
                media: media9,
                language: language9,
                reading_time: reading_time9,
                quality_score: quality_score9,
                word_count: word_count9,
                categories: categories9,
                site_name: site_name9,
                description: description9,
            } = e;
            let vec10 = (url9.into_bytes()).into_boxed_slice();
            let ptr10 = vec10.as_ptr().cast::<u8>();
            let len10 = vec10.len();
            ::core::mem::forget(vec10);
            *ptr8.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
            *ptr8.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10
                .cast_mut();
            match title9 {
                Some(e) => {
                    *ptr8.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                        as u8;
                    let vec11 = (e.into_bytes()).into_boxed_slice();
                    let ptr11 = vec11.as_ptr().cast::<u8>();
                    let len11 = vec11.len();
                    ::core::mem::forget(vec11);
                    *ptr8.add(5 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                    *ptr8
                        .add(4 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr11.cast_mut();
                }
                None => {
                    *ptr8.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                        as u8;
                }
            };
            match byline9 {
                Some(e) => {
                    *ptr8.add(6 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                        as u8;
                    let vec12 = (e.into_bytes()).into_boxed_slice();
                    let ptr12 = vec12.as_ptr().cast::<u8>();
                    let len12 = vec12.len();
                    ::core::mem::forget(vec12);
                    *ptr8.add(8 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len12;
                    *ptr8
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr12.cast_mut();
                }
                None => {
                    *ptr8.add(6 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                        as u8;
                }
            };
            match published_iso9 {
                Some(e) => {
                    *ptr8.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                        as u8;
                    let vec13 = (e.into_bytes()).into_boxed_slice();
                    let ptr13 = vec13.as_ptr().cast::<u8>();
                    let len13 = vec13.len();
                    ::core::mem::forget(vec13);
                    *ptr8
                        .add(11 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len13;
                    *ptr8
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr13.cast_mut();
                }
                None => {
                    *ptr8.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                        as u8;
                }
            };
            let vec14 = (markdown9.into_bytes()).into_boxed_slice();
            let ptr14 = vec14.as_ptr().cast::<u8>();
            let len14 = vec14.len();
            ::core::mem::forget(vec14);
            *ptr8.add(13 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len14;
            *ptr8.add(12 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr14
                .cast_mut();
            let vec15 = (text9.into_bytes()).into_boxed_slice();
            let ptr15 = vec15.as_ptr().cast::<u8>();
            let len15 = vec15.len();
            ::core::mem::forget(vec15);
            *ptr8.add(15 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len15;
            *ptr8.add(14 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr15
                .cast_mut();
            let vec17 = links9;
            let len17 = vec17.len();
            let layout17 = _rt::alloc::Layout::from_size_align_unchecked(
                vec17.len() * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let result17 = if layout17.size() != 0 {
                let ptr = _rt::alloc::alloc(layout17).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout17);
                }
                ptr
            } else {
                ::core::ptr::null_mut()
            };
            for (i, e) in vec17.into_iter().enumerate() {
                let base = result17.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let vec16 = (e.into_bytes()).into_boxed_slice();
                    let ptr16 = vec16.as_ptr().cast::<u8>();
                    let len16 = vec16.len();
                    ::core::mem::forget(vec16);
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len16;
                    *base.add(0).cast::<*mut u8>() = ptr16.cast_mut();
                }
            }
            *ptr8.add(17 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len17;
            *ptr8.add(16 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result17;
            let vec19 = media9;
            let len19 = vec19.len();
            let layout19 = _rt::alloc::Layout::from_size_align_unchecked(
                vec19.len() * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let result19 = if layout19.size() != 0 {
                let ptr = _rt::alloc::alloc(layout19).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout19);
                }
                ptr
            } else {
                ::core::ptr::null_mut()
            };
            for (i, e) in vec19.into_iter().enumerate() {
                let base = result19.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let vec18 = (e.into_bytes()).into_boxed_slice();
                    let ptr18 = vec18.as_ptr().cast::<u8>();
                    let len18 = vec18.len();
                    ::core::mem::forget(vec18);
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len18;
                    *base.add(0).cast::<*mut u8>() = ptr18.cast_mut();
                }
            }
            *ptr8.add(19 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len19;
            *ptr8.add(18 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result19;
            match language9 {
                Some(e) => {
                    *ptr8.add(20 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                        as u8;
                    let vec20 = (e.into_bytes()).into_boxed_slice();
                    let ptr20 = vec20.as_ptr().cast::<u8>();
                    let len20 = vec20.len();
                    ::core::mem::forget(vec20);
                    *ptr8
                        .add(22 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len20;
                    *ptr8
                        .add(21 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr20.cast_mut();
                }
                None => {
                    *ptr8.add(20 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                        as u8;
                }
            };
            match reading_time9 {
                Some(e) => {
                    *ptr8.add(23 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                        as u8;
                    *ptr8
                        .add(4 + 23 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(e);
                }
                None => {
                    *ptr8.add(23 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                        as u8;
                }
            };
            match quality_score9 {
                Some(e) => {
                    *ptr8
                        .add(8 + 23 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    *ptr8
                        .add(9 + 23 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (_rt::as_i32(e)) as u8;
                }
                None => {
                    *ptr8
                        .add(8 + 23 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            match word_count9 {
                Some(e) => {
                    *ptr8
                        .add(12 + 23 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    *ptr8
                        .add(16 + 23 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(e);
                }
                None => {
                    *ptr8
                        .add(12 + 23 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            let vec22 = categories9;
            let len22 = vec22.len();
            let layout22 = _rt::alloc::Layout::from_size_align_unchecked(
                vec22.len() * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let result22 = if layout22.size() != 0 {
                let ptr = _rt::alloc::alloc(layout22).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout22);
                }
                ptr
            } else {
                ::core::ptr::null_mut()
            };
            for (i, e) in vec22.into_iter().enumerate() {
                let base = result22.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let vec21 = (e.into_bytes()).into_boxed_slice();
                    let ptr21 = vec21.as_ptr().cast::<u8>();
                    let len21 = vec21.len();
                    ::core::mem::forget(vec21);
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len21;
                    *base.add(0).cast::<*mut u8>() = ptr21.cast_mut();
                }
            }
            *ptr8.add(16 + 25 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len22;
            *ptr8.add(16 + 24 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result22;
            match site_name9 {
                Some(e) => {
                    *ptr8
                        .add(16 + 26 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    let vec23 = (e.into_bytes()).into_boxed_slice();
                    let ptr23 = vec23.as_ptr().cast::<u8>();
                    let len23 = vec23.len();
                    ::core::mem::forget(vec23);
                    *ptr8
                        .add(16 + 28 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len23;
                    *ptr8
                        .add(16 + 27 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr23.cast_mut();
                }
                None => {
                    *ptr8
                        .add(16 + 26 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            match description9 {
                Some(e) => {
                    *ptr8
                        .add(16 + 29 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    let vec24 = (e.into_bytes()).into_boxed_slice();
                    let ptr24 = vec24.as_ptr().cast::<u8>();
                    let len24 = vec24.len();
                    ::core::mem::forget(vec24);
                    *ptr8
                        .add(16 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len24;
                    *ptr8
                        .add(16 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr24.cast_mut();
                }
                None => {
                    *ptr8
                        .add(16 + 29 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
        }
        Err(e) => {
            *ptr8.add(0).cast::<u8>() = (1i32) as u8;
            match e {
                ExtractionError::InvalidHtml(e) => {
                    *ptr8.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                        as u8;
                    let vec25 = (e.into_bytes()).into_boxed_slice();
                    let ptr25 = vec25.as_ptr().cast::<u8>();
                    let len25 = vec25.len();
                    ::core::mem::forget(vec25);
                    *ptr8.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len25;
                    *ptr8
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr25.cast_mut();
                }
                ExtractionError::NetworkError(e) => {
                    *ptr8.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                        as u8;
                    let vec26 = (e.into_bytes()).into_boxed_slice();
                    let ptr26 = vec26.as_ptr().cast::<u8>();
                    let len26 = vec26.len();
                    ::core::mem::forget(vec26);
                    *ptr8.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len26;
                    *ptr8
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr26.cast_mut();
                }
                ExtractionError::ParseError(e) => {
                    *ptr8.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32)
                        as u8;
                    let vec27 = (e.into_bytes()).into_boxed_slice();
                    let ptr27 = vec27.as_ptr().cast::<u8>();
                    let len27 = vec27.len();
                    ::core::mem::forget(vec27);
                    *ptr8.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len27;
                    *ptr8
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr27.cast_mut();
                }
                ExtractionError::ResourceLimit(e) => {
                    *ptr8.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32)
                        as u8;
                    let vec28 = (e.into_bytes()).into_boxed_slice();
                    let ptr28 = vec28.as_ptr().cast::<u8>();
                    let len28 = vec28.len();
                    ::core::mem::forget(vec28);
                    *ptr8.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len28;
                    *ptr8
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr28.cast_mut();
                }
                ExtractionError::ExtractorError(e) => {
                    *ptr8.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32)
                        as u8;
                    let vec29 = (e.into_bytes()).into_boxed_slice();
                    let ptr29 = vec29.as_ptr().cast::<u8>();
                    let len29 = vec29.len();
                    ::core::mem::forget(vec29);
                    *ptr8.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len29;
                    *ptr8
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr29.cast_mut();
                }
                ExtractionError::InternalError(e) => {
                    *ptr8.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32)
                        as u8;
                    let vec30 = (e.into_bytes()).into_boxed_slice();
                    let ptr30 = vec30.as_ptr().cast::<u8>();
                    let len30 = vec30.len();
                    ::core::mem::forget(vec30);
                    *ptr8.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len30;
                    *ptr8
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr30.cast_mut();
                }
                ExtractionError::UnsupportedMode(e) => {
                    *ptr8.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (6i32)
                        as u8;
                    let vec31 = (e.into_bytes()).into_boxed_slice();
                    let ptr31 = vec31.as_ptr().cast::<u8>();
                    let len31 = vec31.len();
                    ::core::mem::forget(vec31);
                    *ptr8.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len31;
                    *ptr8
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr31.cast_mut();
                }
            }
        }
    };
    ptr8
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_extract<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
            let l3 = i32::from(
                *arg0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l3 {
                0 => {}
                _ => {
                    let l4 = *arg0
                        .add(4 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l5 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l4, l5, 1);
                }
            }
            let l6 = i32::from(
                *arg0.add(6 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l6 {
                0 => {}
                _ => {
                    let l7 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *arg0
                        .add(8 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l7, l8, 1);
                }
            }
            let l9 = i32::from(
                *arg0.add(9 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l9 {
                0 => {}
                _ => {
                    let l10 = *arg0
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l11 = *arg0
                        .add(11 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l10, l11, 1);
                }
            }
            let l12 = *arg0
                .add(12 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l13 = *arg0
                .add(13 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l12, l13, 1);
            let l14 = *arg0
                .add(14 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l15 = *arg0
                .add(15 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l14, l15, 1);
            let l16 = *arg0
                .add(16 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l17 = *arg0
                .add(17 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            let base20 = l16;
            let len20 = l17;
            for i in 0..len20 {
                let base = base20.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let l18 = *base.add(0).cast::<*mut u8>();
                    let l19 = *base
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l18, l19, 1);
                }
            }
            _rt::cabi_dealloc(
                base20,
                len20 * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let l21 = *arg0
                .add(18 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l22 = *arg0
                .add(19 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            let base25 = l21;
            let len25 = l22;
            for i in 0..len25 {
                let base = base25.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let l23 = *base.add(0).cast::<*mut u8>();
                    let l24 = *base
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l23, l24, 1);
                }
            }
            _rt::cabi_dealloc(
                base25,
                len25 * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let l26 = i32::from(
                *arg0.add(20 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l26 {
                0 => {}
                _ => {
                    let l27 = *arg0
                        .add(21 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l28 = *arg0
                        .add(22 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l27, l28, 1);
                }
            }
            let l29 = *arg0
                .add(16 + 24 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l30 = *arg0
                .add(16 + 25 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            let base33 = l29;
            let len33 = l30;
            for i in 0..len33 {
                let base = base33.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let l31 = *base.add(0).cast::<*mut u8>();
                    let l32 = *base
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l31, l32, 1);
                }
            }
            _rt::cabi_dealloc(
                base33,
                len33 * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let l34 = i32::from(
                *arg0.add(16 + 26 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l34 {
                0 => {}
                _ => {
                    let l35 = *arg0
                        .add(16 + 27 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l36 = *arg0
                        .add(16 + 28 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l35, l36, 1);
                }
            }
            let l37 = i32::from(
                *arg0.add(16 + 29 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l37 {
                0 => {}
                _ => {
                    let l38 = *arg0
                        .add(16 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l39 = *arg0
                        .add(16 + 31 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l38, l39, 1);
                }
            }
        }
        _ => {
            let l40 = i32::from(
                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l40 {
                0 => {
                    let l41 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l42 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l41, l42, 1);
                }
                1 => {
                    let l43 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l44 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l43, l44, 1);
                }
                2 => {
                    let l45 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l46 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l45, l46, 1);
                }
                3 => {
                    let l47 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l48 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l47, l48, 1);
                }
                4 => {
                    let l49 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l50 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l49, l50, 1);
                }
                5 => {
                    let l51 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l52 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l51, l52, 1);
                }
                _ => {
                    let l53 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l54 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l53, l54, 1);
                }
            }
        }
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_extract_with_stats_cabi<T: Guest>(
    arg0: *mut u8,
    arg1: usize,
    arg2: *mut u8,
    arg3: usize,
    arg4: i32,
    arg5: *mut u8,
    arg6: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let len1 = arg3;
    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
    let v6 = match arg4 {
        0 => ExtractionMode::Article,
        1 => ExtractionMode::Full,
        2 => ExtractionMode::Metadata,
        n => {
            debug_assert_eq!(n, 3, "invalid enum discriminant");
            let e6 = {
                let base5 = arg5;
                let len5 = arg6;
                let mut result5 = _rt::Vec::with_capacity(len5);
                for i in 0..len5 {
                    let base = base5.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                    let e5 = {
                        let l2 = *base.add(0).cast::<*mut u8>();
                        let l3 = *base
                            .add(::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let len4 = l3;
                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                        _rt::string_lift(bytes4)
                    };
                    result5.push(e5);
                }
                _rt::cabi_dealloc(
                    base5,
                    len5 * (2 * ::core::mem::size_of::<*const u8>()),
                    ::core::mem::size_of::<*const u8>(),
                );
                result5
            };
            ExtractionMode::Custom(e6)
        }
    };
    let result7 = T::extract_with_stats(
        _rt::string_lift(bytes0),
        _rt::string_lift(bytes1),
        v6,
    );
    let ptr8 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result7 {
        Ok(e) => {
            *ptr8.add(0).cast::<u8>() = (0i32) as u8;
            let (t9_0, t9_1) = e;
            let ExtractedContent {
                url: url10,
                title: title10,
                byline: byline10,
                published_iso: published_iso10,
                markdown: markdown10,
                text: text10,
                links: links10,
                media: media10,
                language: language10,
                reading_time: reading_time10,
                quality_score: quality_score10,
                word_count: word_count10,
                categories: categories10,
                site_name: site_name10,
                description: description10,
            } = t9_0;
            let vec11 = (url10.into_bytes()).into_boxed_slice();
            let ptr11 = vec11.as_ptr().cast::<u8>();
            let len11 = vec11.len();
            ::core::mem::forget(vec11);
            *ptr8.add(8 + 1 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
            *ptr8.add(8).cast::<*mut u8>() = ptr11.cast_mut();
            match title10 {
                Some(e) => {
                    *ptr8
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    let vec12 = (e.into_bytes()).into_boxed_slice();
                    let ptr12 = vec12.as_ptr().cast::<u8>();
                    let len12 = vec12.len();
                    ::core::mem::forget(vec12);
                    *ptr8
                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len12;
                    *ptr8
                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr12.cast_mut();
                }
                None => {
                    *ptr8
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            match byline10 {
                Some(e) => {
                    *ptr8
                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    let vec13 = (e.into_bytes()).into_boxed_slice();
                    let ptr13 = vec13.as_ptr().cast::<u8>();
                    let len13 = vec13.len();
                    ::core::mem::forget(vec13);
                    *ptr8
                        .add(8 + 7 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len13;
                    *ptr8
                        .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr13.cast_mut();
                }
                None => {
                    *ptr8
                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            match published_iso10 {
                Some(e) => {
                    *ptr8
                        .add(8 + 8 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    let vec14 = (e.into_bytes()).into_boxed_slice();
                    let ptr14 = vec14.as_ptr().cast::<u8>();
                    let len14 = vec14.len();
                    ::core::mem::forget(vec14);
                    *ptr8
                        .add(8 + 10 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len14;
                    *ptr8
                        .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr14.cast_mut();
                }
                None => {
                    *ptr8
                        .add(8 + 8 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            let vec15 = (markdown10.into_bytes()).into_boxed_slice();
            let ptr15 = vec15.as_ptr().cast::<u8>();
            let len15 = vec15.len();
            ::core::mem::forget(vec15);
            *ptr8.add(8 + 12 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len15;
            *ptr8.add(8 + 11 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr15
                .cast_mut();
            let vec16 = (text10.into_bytes()).into_boxed_slice();
            let ptr16 = vec16.as_ptr().cast::<u8>();
            let len16 = vec16.len();
            ::core::mem::forget(vec16);
            *ptr8.add(8 + 14 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len16;
            *ptr8.add(8 + 13 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr16
                .cast_mut();
            let vec18 = links10;
            let len18 = vec18.len();
            let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                vec18.len() * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let result18 = if layout18.size() != 0 {
                let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout18);
                }
                ptr
            } else {
                ::core::ptr::null_mut()
            };
            for (i, e) in vec18.into_iter().enumerate() {
                let base = result18.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let vec17 = (e.into_bytes()).into_boxed_slice();
                    let ptr17 = vec17.as_ptr().cast::<u8>();
                    let len17 = vec17.len();
                    ::core::mem::forget(vec17);
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len17;
                    *base.add(0).cast::<*mut u8>() = ptr17.cast_mut();
                }
            }
            *ptr8.add(8 + 16 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len18;
            *ptr8.add(8 + 15 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result18;
            let vec20 = media10;
            let len20 = vec20.len();
            let layout20 = _rt::alloc::Layout::from_size_align_unchecked(
                vec20.len() * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let result20 = if layout20.size() != 0 {
                let ptr = _rt::alloc::alloc(layout20).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout20);
                }
                ptr
            } else {
                ::core::ptr::null_mut()
            };
            for (i, e) in vec20.into_iter().enumerate() {
                let base = result20.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let vec19 = (e.into_bytes()).into_boxed_slice();
                    let ptr19 = vec19.as_ptr().cast::<u8>();
                    let len19 = vec19.len();
                    ::core::mem::forget(vec19);
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len19;
                    *base.add(0).cast::<*mut u8>() = ptr19.cast_mut();
                }
            }
            *ptr8.add(8 + 18 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len20;
            *ptr8.add(8 + 17 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result20;
            match language10 {
                Some(e) => {
                    *ptr8
                        .add(8 + 19 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    let vec21 = (e.into_bytes()).into_boxed_slice();
                    let ptr21 = vec21.as_ptr().cast::<u8>();
                    let len21 = vec21.len();
                    ::core::mem::forget(vec21);
                    *ptr8
                        .add(8 + 21 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len21;
                    *ptr8
                        .add(8 + 20 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr21.cast_mut();
                }
                None => {
                    *ptr8
                        .add(8 + 19 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            match reading_time10 {
                Some(e) => {
                    *ptr8
                        .add(8 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    *ptr8
                        .add(12 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(e);
                }
                None => {
                    *ptr8
                        .add(8 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            match quality_score10 {
                Some(e) => {
                    *ptr8
                        .add(16 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    *ptr8
                        .add(17 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (_rt::as_i32(e)) as u8;
                }
                None => {
                    *ptr8
                        .add(16 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            match word_count10 {
                Some(e) => {
                    *ptr8
                        .add(20 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    *ptr8
                        .add(24 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(e);
                }
                None => {
                    *ptr8
                        .add(20 + 22 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            let vec23 = categories10;
            let len23 = vec23.len();
            let layout23 = _rt::alloc::Layout::from_size_align_unchecked(
                vec23.len() * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let result23 = if layout23.size() != 0 {
                let ptr = _rt::alloc::alloc(layout23).cast::<u8>();
                if ptr.is_null() {
                    _rt::alloc::handle_alloc_error(layout23);
                }
                ptr
            } else {
                ::core::ptr::null_mut()
            };
            for (i, e) in vec23.into_iter().enumerate() {
                let base = result23.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let vec22 = (e.into_bytes()).into_boxed_slice();
                    let ptr22 = vec22.as_ptr().cast::<u8>();
                    let len22 = vec22.len();
                    ::core::mem::forget(vec22);
                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len22;
                    *base.add(0).cast::<*mut u8>() = ptr22.cast_mut();
                }
            }
            *ptr8.add(24 + 24 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len23;
            *ptr8.add(24 + 23 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result23;
            match site_name10 {
                Some(e) => {
                    *ptr8
                        .add(24 + 25 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    let vec24 = (e.into_bytes()).into_boxed_slice();
                    let ptr24 = vec24.as_ptr().cast::<u8>();
                    let len24 = vec24.len();
                    ::core::mem::forget(vec24);
                    *ptr8
                        .add(24 + 27 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len24;
                    *ptr8
                        .add(24 + 26 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr24.cast_mut();
                }
                None => {
                    *ptr8
                        .add(24 + 25 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            match description10 {
                Some(e) => {
                    *ptr8
                        .add(24 + 28 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    let vec25 = (e.into_bytes()).into_boxed_slice();
                    let ptr25 = vec25.as_ptr().cast::<u8>();
                    let len25 = vec25.len();
                    ::core::mem::forget(vec25);
                    *ptr8
                        .add(24 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len25;
                    *ptr8
                        .add(24 + 29 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr25.cast_mut();
                }
                None => {
                    *ptr8
                        .add(24 + 28 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            let ExtractionStats {
                processing_time_ms: processing_time_ms26,
                memory_used: memory_used26,
                nodes_processed: nodes_processed26,
                links_found: links_found26,
                images_found: images_found26,
            } = t9_1;
            *ptr8.add(32 + 30 * ::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(
                processing_time_ms26,
            );
            *ptr8.add(40 + 30 * ::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(
                memory_used26,
            );
            match nodes_processed26 {
                Some(e) => {
                    *ptr8
                        .add(48 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (1i32) as u8;
                    *ptr8
                        .add(52 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(e);
                }
                None => {
                    *ptr8
                        .add(48 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (0i32) as u8;
                }
            };
            *ptr8.add(56 + 30 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                links_found26,
            );
            *ptr8.add(60 + 30 * ::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(
                images_found26,
            );
        }
        Err(e) => {
            *ptr8.add(0).cast::<u8>() = (1i32) as u8;
            match e {
                ExtractionError::InvalidHtml(e) => {
                    *ptr8.add(8).cast::<u8>() = (0i32) as u8;
                    let vec27 = (e.into_bytes()).into_boxed_slice();
                    let ptr27 = vec27.as_ptr().cast::<u8>();
                    let len27 = vec27.len();
                    ::core::mem::forget(vec27);
                    *ptr8
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len27;
                    *ptr8
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr27.cast_mut();
                }
                ExtractionError::NetworkError(e) => {
                    *ptr8.add(8).cast::<u8>() = (1i32) as u8;
                    let vec28 = (e.into_bytes()).into_boxed_slice();
                    let ptr28 = vec28.as_ptr().cast::<u8>();
                    let len28 = vec28.len();
                    ::core::mem::forget(vec28);
                    *ptr8
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len28;
                    *ptr8
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr28.cast_mut();
                }
                ExtractionError::ParseError(e) => {
                    *ptr8.add(8).cast::<u8>() = (2i32) as u8;
                    let vec29 = (e.into_bytes()).into_boxed_slice();
                    let ptr29 = vec29.as_ptr().cast::<u8>();
                    let len29 = vec29.len();
                    ::core::mem::forget(vec29);
                    *ptr8
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len29;
                    *ptr8
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr29.cast_mut();
                }
                ExtractionError::ResourceLimit(e) => {
                    *ptr8.add(8).cast::<u8>() = (3i32) as u8;
                    let vec30 = (e.into_bytes()).into_boxed_slice();
                    let ptr30 = vec30.as_ptr().cast::<u8>();
                    let len30 = vec30.len();
                    ::core::mem::forget(vec30);
                    *ptr8
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len30;
                    *ptr8
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr30.cast_mut();
                }
                ExtractionError::ExtractorError(e) => {
                    *ptr8.add(8).cast::<u8>() = (4i32) as u8;
                    let vec31 = (e.into_bytes()).into_boxed_slice();
                    let ptr31 = vec31.as_ptr().cast::<u8>();
                    let len31 = vec31.len();
                    ::core::mem::forget(vec31);
                    *ptr8
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len31;
                    *ptr8
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr31.cast_mut();
                }
                ExtractionError::InternalError(e) => {
                    *ptr8.add(8).cast::<u8>() = (5i32) as u8;
                    let vec32 = (e.into_bytes()).into_boxed_slice();
                    let ptr32 = vec32.as_ptr().cast::<u8>();
                    let len32 = vec32.len();
                    ::core::mem::forget(vec32);
                    *ptr8
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len32;
                    *ptr8
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr32.cast_mut();
                }
                ExtractionError::UnsupportedMode(e) => {
                    *ptr8.add(8).cast::<u8>() = (6i32) as u8;
                    let vec33 = (e.into_bytes()).into_boxed_slice();
                    let ptr33 = vec33.as_ptr().cast::<u8>();
                    let len33 = vec33.len();
                    ::core::mem::forget(vec33);
                    *ptr8
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len33;
                    *ptr8
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr33.cast_mut();
                }
            }
        }
    };
    ptr8
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_extract_with_stats<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {
            let l1 = *arg0.add(8).cast::<*mut u8>();
            let l2 = *arg0
                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
            let l3 = i32::from(
                *arg0.add(8 + 2 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l3 {
                0 => {}
                _ => {
                    let l4 = *arg0
                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l5 = *arg0
                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l4, l5, 1);
                }
            }
            let l6 = i32::from(
                *arg0.add(8 + 5 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l6 {
                0 => {}
                _ => {
                    let l7 = *arg0
                        .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l8 = *arg0
                        .add(8 + 7 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l7, l8, 1);
                }
            }
            let l9 = i32::from(
                *arg0.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l9 {
                0 => {}
                _ => {
                    let l10 = *arg0
                        .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l11 = *arg0
                        .add(8 + 10 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l10, l11, 1);
                }
            }
            let l12 = *arg0
                .add(8 + 11 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l13 = *arg0
                .add(8 + 12 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l12, l13, 1);
            let l14 = *arg0
                .add(8 + 13 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l15 = *arg0
                .add(8 + 14 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l14, l15, 1);
            let l16 = *arg0
                .add(8 + 15 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l17 = *arg0
                .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            let base20 = l16;
            let len20 = l17;
            for i in 0..len20 {
                let base = base20.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let l18 = *base.add(0).cast::<*mut u8>();
                    let l19 = *base
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l18, l19, 1);
                }
            }
            _rt::cabi_dealloc(
                base20,
                len20 * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let l21 = *arg0
                .add(8 + 17 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l22 = *arg0
                .add(8 + 18 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            let base25 = l21;
            let len25 = l22;
            for i in 0..len25 {
                let base = base25.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let l23 = *base.add(0).cast::<*mut u8>();
                    let l24 = *base
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l23, l24, 1);
                }
            }
            _rt::cabi_dealloc(
                base25,
                len25 * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let l26 = i32::from(
                *arg0.add(8 + 19 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l26 {
                0 => {}
                _ => {
                    let l27 = *arg0
                        .add(8 + 20 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l28 = *arg0
                        .add(8 + 21 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l27, l28, 1);
                }
            }
            let l29 = *arg0
                .add(24 + 23 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l30 = *arg0
                .add(24 + 24 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            let base33 = l29;
            let len33 = l30;
            for i in 0..len33 {
                let base = base33.add(i * (2 * ::core::mem::size_of::<*const u8>()));
                {
                    let l31 = *base.add(0).cast::<*mut u8>();
                    let l32 = *base
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l31, l32, 1);
                }
            }
            _rt::cabi_dealloc(
                base33,
                len33 * (2 * ::core::mem::size_of::<*const u8>()),
                ::core::mem::size_of::<*const u8>(),
            );
            let l34 = i32::from(
                *arg0.add(24 + 25 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l34 {
                0 => {}
                _ => {
                    let l35 = *arg0
                        .add(24 + 26 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l36 = *arg0
                        .add(24 + 27 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l35, l36, 1);
                }
            }
            let l37 = i32::from(
                *arg0.add(24 + 28 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l37 {
                0 => {}
                _ => {
                    let l38 = *arg0
                        .add(24 + 29 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l39 = *arg0
                        .add(24 + 30 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l38, l39, 1);
                }
            }
        }
        _ => {
            let l40 = i32::from(*arg0.add(8).cast::<u8>());
            match l40 {
                0 => {
                    let l41 = *arg0
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l42 = *arg0
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l41, l42, 1);
                }
                1 => {
                    let l43 = *arg0
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l44 = *arg0
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l43, l44, 1);
                }
                2 => {
                    let l45 = *arg0
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l46 = *arg0
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l45, l46, 1);
                }
                3 => {
                    let l47 = *arg0
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l48 = *arg0
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l47, l48, 1);
                }
                4 => {
                    let l49 = *arg0
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l50 = *arg0
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l49, l50, 1);
                }
                5 => {
                    let l51 = *arg0
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l52 = *arg0
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l51, l52, 1);
                }
                _ => {
                    let l53 = *arg0
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l54 = *arg0
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l53, l54, 1);
                }
            }
        }
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_validate_html_cabi<T: Guest>(
    arg0: *mut u8,
    arg1: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let result1 = T::validate_html(_rt::string_lift(bytes0));
    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result1 {
        Ok(e) => {
            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
            *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e {
                true => 1,
                false => 0,
            }) as u8;
        }
        Err(e) => {
            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
            match e {
                ExtractionError::InvalidHtml(e) => {
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                        as u8;
                    let vec3 = (e.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr2.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr3.cast_mut();
                }
                ExtractionError::NetworkError(e) => {
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                        as u8;
                    let vec4 = (e.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr2.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                }
                ExtractionError::ParseError(e) => {
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32)
                        as u8;
                    let vec5 = (e.into_bytes()).into_boxed_slice();
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    ::core::mem::forget(vec5);
                    *ptr2.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr5.cast_mut();
                }
                ExtractionError::ResourceLimit(e) => {
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32)
                        as u8;
                    let vec6 = (e.into_bytes()).into_boxed_slice();
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    ::core::mem::forget(vec6);
                    *ptr2.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                    *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr6.cast_mut();
                }
                ExtractionError::ExtractorError(e) => {
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32)
                        as u8;
                    let vec7 = (e.into_bytes()).into_boxed_slice();
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    ::core::mem::forget(vec7);
                    *ptr2.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr7.cast_mut();
                }
                ExtractionError::InternalError(e) => {
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32)
                        as u8;
                    let vec8 = (e.into_bytes()).into_boxed_slice();
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    ::core::mem::forget(vec8);
                    *ptr2.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                    *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr8.cast_mut();
                }
                ExtractionError::UnsupportedMode(e) => {
                    *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (6i32)
                        as u8;
                    let vec9 = (e.into_bytes()).into_boxed_slice();
                    let ptr9 = vec9.as_ptr().cast::<u8>();
                    let len9 = vec9.len();
                    ::core::mem::forget(vec9);
                    *ptr2.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr2
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr9.cast_mut();
                }
            }
        }
    };
    ptr2
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_validate_html<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {}
        _ => {
            let l1 = i32::from(
                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l1 {
                0 => {
                    let l2 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l3 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                }
                1 => {
                    let l4 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l5 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l4, l5, 1);
                }
                2 => {
                    let l6 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l6, l7, 1);
                }
                3 => {
                    let l8 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l8, l9, 1);
                }
                4 => {
                    let l10 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l11 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l10, l11, 1);
                }
                5 => {
                    let l12 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l13 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l12, l13, 1);
                }
                _ => {
                    let l14 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l15 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l14, l15, 1);
                }
            }
        }
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_health_check_cabi<T: Guest>() -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::health_check();
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    let HealthStatus {
        status: status2,
        version: version2,
        trek_version: trek_version2,
        capabilities: capabilities2,
        memory_usage: memory_usage2,
        extraction_count: extraction_count2,
    } = result0;
    let vec3 = (status2.into_bytes()).into_boxed_slice();
    let ptr3 = vec3.as_ptr().cast::<u8>();
    let len3 = vec3.len();
    ::core::mem::forget(vec3);
    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
    let vec4 = (version2.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr().cast::<u8>();
    let len4 = vec4.len();
    ::core::mem::forget(vec4);
    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
    *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4
        .cast_mut();
    let vec5 = (trek_version2.into_bytes()).into_boxed_slice();
    let ptr5 = vec5.as_ptr().cast::<u8>();
    let len5 = vec5.len();
    ::core::mem::forget(vec5);
    *ptr1.add(5 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
    *ptr1.add(4 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5
        .cast_mut();
    let vec7 = capabilities2;
    let len7 = vec7.len();
    let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
        vec7.len() * (2 * ::core::mem::size_of::<*const u8>()),
        ::core::mem::size_of::<*const u8>(),
    );
    let result7 = if layout7.size() != 0 {
        let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
        if ptr.is_null() {
            _rt::alloc::handle_alloc_error(layout7);
        }
        ptr
    } else {
        ::core::ptr::null_mut()
    };
    for (i, e) in vec7.into_iter().enumerate() {
        let base = result7.add(i * (2 * ::core::mem::size_of::<*const u8>()));
        {
            let vec6 = (e.into_bytes()).into_boxed_slice();
            let ptr6 = vec6.as_ptr().cast::<u8>();
            let len6 = vec6.len();
            ::core::mem::forget(vec6);
            *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
        }
    }
    *ptr1.add(7 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
    *ptr1.add(6 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result7;
    match memory_usage2 {
        Some(e) => {
            *ptr1.add(8 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
            *ptr1.add(8 + 8 * ::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(
                e,
            );
        }
        None => {
            *ptr1.add(8 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
        }
    };
    match extraction_count2 {
        Some(e) => {
            *ptr1.add(16 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
            *ptr1.add(24 + 8 * ::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(
                e,
            );
        }
        None => {
            *ptr1.add(16 + 8 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
        }
    };
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_health_check<T: Guest>(arg0: *mut u8) {
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l0, l1, 1);
    let l2 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l3 = *arg0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l2, l3, 1);
    let l4 = *arg0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l5 = *arg0.add(5 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l4, l5, 1);
    let l6 = *arg0.add(6 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l7 = *arg0.add(7 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    let base10 = l6;
    let len10 = l7;
    for i in 0..len10 {
        let base = base10.add(i * (2 * ::core::mem::size_of::<*const u8>()));
        {
            let l8 = *base.add(0).cast::<*mut u8>();
            let l9 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l8, l9, 1);
        }
    }
    _rt::cabi_dealloc(
        base10,
        len10 * (2 * ::core::mem::size_of::<*const u8>()),
        ::core::mem::size_of::<*const u8>(),
    );
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_get_info_cabi<T: Guest>() -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::get_info();
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    let ComponentInfo {
        name: name2,
        version: version2,
        component_model_version: component_model_version2,
        features: features2,
        supported_modes: supported_modes2,
        build_timestamp: build_timestamp2,
        git_commit: git_commit2,
    } = result0;
    let vec3 = (name2.into_bytes()).into_boxed_slice();
    let ptr3 = vec3.as_ptr().cast::<u8>();
    let len3 = vec3.len();
    ::core::mem::forget(vec3);
    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
    let vec4 = (version2.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr().cast::<u8>();
    let len4 = vec4.len();
    ::core::mem::forget(vec4);
    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
    *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4
        .cast_mut();
    let vec5 = (component_model_version2.into_bytes()).into_boxed_slice();
    let ptr5 = vec5.as_ptr().cast::<u8>();
    let len5 = vec5.len();
    ::core::mem::forget(vec5);
    *ptr1.add(5 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
    *ptr1.add(4 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr5
        .cast_mut();
    let vec7 = features2;
    let len7 = vec7.len();
    let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
        vec7.len() * (2 * ::core::mem::size_of::<*const u8>()),
        ::core::mem::size_of::<*const u8>(),
    );
    let result7 = if layout7.size() != 0 {
        let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
        if ptr.is_null() {
            _rt::alloc::handle_alloc_error(layout7);
        }
        ptr
    } else {
        ::core::ptr::null_mut()
    };
    for (i, e) in vec7.into_iter().enumerate() {
        let base = result7.add(i * (2 * ::core::mem::size_of::<*const u8>()));
        {
            let vec6 = (e.into_bytes()).into_boxed_slice();
            let ptr6 = vec6.as_ptr().cast::<u8>();
            let len6 = vec6.len();
            ::core::mem::forget(vec6);
            *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
        }
    }
    *ptr1.add(7 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
    *ptr1.add(6 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result7;
    let vec9 = supported_modes2;
    let len9 = vec9.len();
    let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
        vec9.len() * (2 * ::core::mem::size_of::<*const u8>()),
        ::core::mem::size_of::<*const u8>(),
    );
    let result9 = if layout9.size() != 0 {
        let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
        if ptr.is_null() {
            _rt::alloc::handle_alloc_error(layout9);
        }
        ptr
    } else {
        ::core::ptr::null_mut()
    };
    for (i, e) in vec9.into_iter().enumerate() {
        let base = result9.add(i * (2 * ::core::mem::size_of::<*const u8>()));
        {
            let vec8 = (e.into_bytes()).into_boxed_slice();
            let ptr8 = vec8.as_ptr().cast::<u8>();
            let len8 = vec8.len();
            ::core::mem::forget(vec8);
            *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
            *base.add(0).cast::<*mut u8>() = ptr8.cast_mut();
        }
    }
    *ptr1.add(9 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
    *ptr1.add(8 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result9;
    match build_timestamp2 {
        Some(e) => {
            *ptr1.add(10 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
            let vec10 = (e.into_bytes()).into_boxed_slice();
            let ptr10 = vec10.as_ptr().cast::<u8>();
            let len10 = vec10.len();
            ::core::mem::forget(vec10);
            *ptr1.add(12 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len10;
            *ptr1.add(11 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr10
                .cast_mut();
        }
        None => {
            *ptr1.add(10 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
        }
    };
    match git_commit2 {
        Some(e) => {
            *ptr1.add(13 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                as u8;
            let vec11 = (e.into_bytes()).into_boxed_slice();
            let ptr11 = vec11.as_ptr().cast::<u8>();
            let len11 = vec11.len();
            ::core::mem::forget(vec11);
            *ptr1.add(15 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
            *ptr1.add(14 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr11
                .cast_mut();
        }
        None => {
            *ptr1.add(13 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                as u8;
        }
    };
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_get_info<T: Guest>(arg0: *mut u8) {
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l0, l1, 1);
    let l2 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l3 = *arg0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l2, l3, 1);
    let l4 = *arg0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l5 = *arg0.add(5 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    _rt::cabi_dealloc(l4, l5, 1);
    let l6 = *arg0.add(6 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l7 = *arg0.add(7 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    let base10 = l6;
    let len10 = l7;
    for i in 0..len10 {
        let base = base10.add(i * (2 * ::core::mem::size_of::<*const u8>()));
        {
            let l8 = *base.add(0).cast::<*mut u8>();
            let l9 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l8, l9, 1);
        }
    }
    _rt::cabi_dealloc(
        base10,
        len10 * (2 * ::core::mem::size_of::<*const u8>()),
        ::core::mem::size_of::<*const u8>(),
    );
    let l11 = *arg0.add(8 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
    let l12 = *arg0.add(9 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
    let base15 = l11;
    let len15 = l12;
    for i in 0..len15 {
        let base = base15.add(i * (2 * ::core::mem::size_of::<*const u8>()));
        {
            let l13 = *base.add(0).cast::<*mut u8>();
            let l14 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l13, l14, 1);
        }
    }
    _rt::cabi_dealloc(
        base15,
        len15 * (2 * ::core::mem::size_of::<*const u8>()),
        ::core::mem::size_of::<*const u8>(),
    );
    let l16 = i32::from(
        *arg0.add(10 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    match l16 {
        0 => {}
        _ => {
            let l17 = *arg0
                .add(11 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l18 = *arg0
                .add(12 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l17, l18, 1);
        }
    }
    let l19 = i32::from(
        *arg0.add(13 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
    );
    match l19 {
        0 => {}
        _ => {
            let l20 = *arg0
                .add(14 * ::core::mem::size_of::<*const u8>())
                .cast::<*mut u8>();
            let l21 = *arg0
                .add(15 * ::core::mem::size_of::<*const u8>())
                .cast::<usize>();
            _rt::cabi_dealloc(l20, l21, 1);
        }
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_reset_state_cabi<T: Guest>() -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::reset_state();
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    match result0 {
        Ok(e) => {
            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
            let vec2 = (e.into_bytes()).into_boxed_slice();
            let ptr2 = vec2.as_ptr().cast::<u8>();
            let len2 = vec2.len();
            ::core::mem::forget(vec2);
            *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
            *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2
                .cast_mut();
        }
        Err(e) => {
            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
            match e {
                ExtractionError::InvalidHtml(e) => {
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32)
                        as u8;
                    let vec3 = (e.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr3.cast_mut();
                }
                ExtractionError::NetworkError(e) => {
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32)
                        as u8;
                    let vec4 = (e.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                }
                ExtractionError::ParseError(e) => {
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32)
                        as u8;
                    let vec5 = (e.into_bytes()).into_boxed_slice();
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    ::core::mem::forget(vec5);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr5.cast_mut();
                }
                ExtractionError::ResourceLimit(e) => {
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32)
                        as u8;
                    let vec6 = (e.into_bytes()).into_boxed_slice();
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    ::core::mem::forget(vec6);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr6.cast_mut();
                }
                ExtractionError::ExtractorError(e) => {
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (4i32)
                        as u8;
                    let vec7 = (e.into_bytes()).into_boxed_slice();
                    let ptr7 = vec7.as_ptr().cast::<u8>();
                    let len7 = vec7.len();
                    ::core::mem::forget(vec7);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr7.cast_mut();
                }
                ExtractionError::InternalError(e) => {
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (5i32)
                        as u8;
                    let vec8 = (e.into_bytes()).into_boxed_slice();
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    ::core::mem::forget(vec8);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr8.cast_mut();
                }
                ExtractionError::UnsupportedMode(e) => {
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (6i32)
                        as u8;
                    let vec9 = (e.into_bytes()).into_boxed_slice();
                    let ptr9 = vec9.as_ptr().cast::<u8>();
                    let len9 = vec9.len();
                    ::core::mem::forget(vec9);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr9.cast_mut();
                }
            }
        }
    };
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_reset_state<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {
            let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
            let l2 = *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l1, l2, 1);
        }
        _ => {
            let l3 = i32::from(
                *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
            );
            match l3 {
                0 => {
                    let l4 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l5 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l4, l5, 1);
                }
                1 => {
                    let l6 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l6, l7, 1);
                }
                2 => {
                    let l8 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l8, l9, 1);
                }
                3 => {
                    let l10 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l11 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l10, l11, 1);
                }
                4 => {
                    let l12 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l13 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l12, l13, 1);
                }
                5 => {
                    let l14 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l15 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l14, l15, 1);
                }
                _ => {
                    let l16 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l17 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l16, l17, 1);
                }
            }
        }
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_get_modes_cabi<T: Guest>() -> *mut u8 {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let result0 = T::get_modes();
    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
    let vec3 = result0;
    let len3 = vec3.len();
    let layout3 = _rt::alloc::Layout::from_size_align_unchecked(
        vec3.len() * (2 * ::core::mem::size_of::<*const u8>()),
        ::core::mem::size_of::<*const u8>(),
    );
    let result3 = if layout3.size() != 0 {
        let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
        if ptr.is_null() {
            _rt::alloc::handle_alloc_error(layout3);
        }
        ptr
    } else {
        ::core::ptr::null_mut()
    };
    for (i, e) in vec3.into_iter().enumerate() {
        let base = result3.add(i * (2 * ::core::mem::size_of::<*const u8>()));
        {
            let vec2 = (e.into_bytes()).into_boxed_slice();
            let ptr2 = vec2.as_ptr().cast::<u8>();
            let len2 = vec2.len();
            ::core::mem::forget(vec2);
            *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
        }
    }
    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
    *ptr1.add(0).cast::<*mut u8>() = result3;
    ptr1
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_get_modes<T: Guest>(arg0: *mut u8) {
    let l0 = *arg0.add(0).cast::<*mut u8>();
    let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
    let base4 = l0;
    let len4 = l1;
    for i in 0..len4 {
        let base = base4.add(i * (2 * ::core::mem::size_of::<*const u8>()));
        {
            let l2 = *base.add(0).cast::<*mut u8>();
            let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            _rt::cabi_dealloc(l2, l3, 1);
        }
    }
    _rt::cabi_dealloc(
        base4,
        len4 * (2 * ::core::mem::size_of::<*const u8>()),
        ::core::mem::size_of::<*const u8>(),
    );
}
pub trait Guest {
    /// Primary extraction function with enhanced error handling
    fn extract(
        html: _rt::String,
        url: _rt::String,
        mode: ExtractionMode,
    ) -> Result<ExtractedContent, ExtractionError>;
    /// Extract content with detailed statistics
    fn extract_with_stats(
        html: _rt::String,
        url: _rt::String,
        mode: ExtractionMode,
    ) -> Result<(ExtractedContent, ExtractionStats), ExtractionError>;
    /// Validate HTML content without full extraction
    fn validate_html(html: _rt::String) -> Result<bool, ExtractionError>;
    /// Health check for component monitoring
    fn health_check() -> HealthStatus;
    /// Get detailed component information
    fn get_info() -> ComponentInfo;
    /// Reset component state and clear caches
    fn reset_state() -> Result<_rt::String, ExtractionError>;
    /// Get supported extraction modes
    fn get_modes() -> _rt::Vec<_rt::String>;
}
#[doc(hidden)]
macro_rules! __export_world_extractor_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "extract")] unsafe extern "C" fn
        export_extract(arg0 : * mut u8, arg1 : usize, arg2 : * mut u8, arg3 : usize, arg4
        : i32, arg5 : * mut u8, arg6 : usize,) -> * mut u8 { unsafe {
        $($path_to_types)*:: _export_extract_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4,
        arg5, arg6) } } #[unsafe (export_name = "cabi_post_extract")] unsafe extern "C"
        fn _post_return_extract(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
        __post_return_extract::<$ty > (arg0) } } #[unsafe (export_name =
        "extract-with-stats")] unsafe extern "C" fn export_extract_with_stats(arg0 : *
        mut u8, arg1 : usize, arg2 : * mut u8, arg3 : usize, arg4 : i32, arg5 : * mut u8,
        arg6 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
        _export_extract_with_stats_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4, arg5,
        arg6) } } #[unsafe (export_name = "cabi_post_extract-with-stats")] unsafe extern
        "C" fn _post_return_extract_with_stats(arg0 : * mut u8,) { unsafe {
        $($path_to_types)*:: __post_return_extract_with_stats::<$ty > (arg0) } } #[unsafe
        (export_name = "validate-html")] unsafe extern "C" fn export_validate_html(arg0 :
        * mut u8, arg1 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
        _export_validate_html_cabi::<$ty > (arg0, arg1) } } #[unsafe (export_name =
        "cabi_post_validate-html")] unsafe extern "C" fn _post_return_validate_html(arg0
        : * mut u8,) { unsafe { $($path_to_types)*:: __post_return_validate_html::<$ty >
        (arg0) } } #[unsafe (export_name = "health-check")] unsafe extern "C" fn
        export_health_check() -> * mut u8 { unsafe { $($path_to_types)*::
        _export_health_check_cabi::<$ty > () } } #[unsafe (export_name =
        "cabi_post_health-check")] unsafe extern "C" fn _post_return_health_check(arg0 :
        * mut u8,) { unsafe { $($path_to_types)*:: __post_return_health_check::<$ty >
        (arg0) } } #[unsafe (export_name = "get-info")] unsafe extern "C" fn
        export_get_info() -> * mut u8 { unsafe { $($path_to_types)*::
        _export_get_info_cabi::<$ty > () } } #[unsafe (export_name =
        "cabi_post_get-info")] unsafe extern "C" fn _post_return_get_info(arg0 : * mut
        u8,) { unsafe { $($path_to_types)*:: __post_return_get_info::<$ty > (arg0) } }
        #[unsafe (export_name = "reset-state")] unsafe extern "C" fn export_reset_state()
        -> * mut u8 { unsafe { $($path_to_types)*:: _export_reset_state_cabi::<$ty > () }
        } #[unsafe (export_name = "cabi_post_reset-state")] unsafe extern "C" fn
        _post_return_reset_state(arg0 : * mut u8,) { unsafe { $($path_to_types)*::
        __post_return_reset_state::<$ty > (arg0) } } #[unsafe (export_name =
        "get-modes")] unsafe extern "C" fn export_get_modes() -> * mut u8 { unsafe {
        $($path_to_types)*:: _export_get_modes_cabi::<$ty > () } } #[unsafe (export_name
        = "cabi_post_get-modes")] unsafe extern "C" fn _post_return_get_modes(arg0 : *
        mut u8,) { unsafe { $($path_to_types)*:: __post_return_get_modes::<$ty > (arg0) }
        } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_extractor_cabi;
#[repr(align(8))]
struct _RetArea(
    [::core::mem::MaybeUninit<u8>; 64 + 30 * ::core::mem::size_of::<*const u8>()],
);
static mut _RET_AREA: _RetArea = _RetArea(
    [::core::mem::MaybeUninit::uninit(); 64 + 30 * ::core::mem::size_of::<*const u8>()],
);
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::vec::Vec;
    pub use alloc_crate::string::String;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub use alloc_crate::alloc;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_extractor_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_extractor_cabi!($ty with_types_in
        $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_extractor_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:riptide:extractor@0.2.0:extractor:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1112] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd8\x07\x01A\x02\x01\
A$\x01ps\x01q\x04\x07article\0\0\x04full\0\0\x08metadata\0\0\x06custom\x01\0\0\x03\
\0\x0fextraction-mode\x03\0\x01\x01ks\x01ky\x01k}\x01r\x0f\x03urls\x05title\x03\x06\
byline\x03\x0dpublished-iso\x03\x08markdowns\x04texts\x05links\0\x05media\0\x08l\
anguage\x03\x0creading-time\x04\x0dquality-score\x05\x0aword-count\x04\x0acatego\
ries\0\x09site-name\x03\x0bdescription\x03\x03\0\x11extracted-content\x03\0\x06\x01\
q\x07\x0cinvalid-html\x01s\0\x0dnetwork-error\x01s\0\x0bparse-error\x01s\0\x0ere\
source-limit\x01s\0\x0fextractor-error\x01s\0\x0einternal-error\x01s\0\x10unsupp\
orted-mode\x01s\0\x03\0\x10extraction-error\x03\0\x08\x01kw\x01r\x06\x06statuss\x07\
versions\x0ctrek-versions\x0ccapabilities\0\x0cmemory-usage\x0a\x10extraction-co\
unt\x0a\x03\0\x0dhealth-status\x03\0\x0b\x01r\x07\x04names\x07versions\x17compon\
ent-model-versions\x08features\0\x0fsupported-modes\0\x0fbuild-timestamp\x03\x0a\
git-commit\x03\x03\0\x0ecomponent-info\x03\0\x0d\x01r\x05\x12processing-time-msw\
\x0bmemory-usedw\x0fnodes-processed\x04\x0blinks-foundy\x0cimages-foundy\x03\0\x10\
extraction-stats\x03\0\x0f\x01j\x01\x07\x01\x09\x01@\x03\x04htmls\x03urls\x04mod\
e\x02\0\x11\x04\0\x07extract\x01\x12\x01o\x02\x07\x10\x01j\x01\x13\x01\x09\x01@\x03\
\x04htmls\x03urls\x04mode\x02\0\x14\x04\0\x12extract-with-stats\x01\x15\x01j\x01\
\x7f\x01\x09\x01@\x01\x04htmls\0\x16\x04\0\x0dvalidate-html\x01\x17\x01@\0\0\x0c\
\x04\0\x0chealth-check\x01\x18\x01@\0\0\x0e\x04\0\x08get-info\x01\x19\x01j\x01s\x01\
\x09\x01@\0\0\x1a\x04\0\x0breset-state\x01\x1b\x01@\0\0\0\x04\0\x09get-modes\x01\
\x1c\x04\0!riptide:extractor/extractor@0.2.0\x04\0\x0b\x0f\x01\0\x09extractor\x03\
\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-\
bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
