//! Metadata extraction with ML insights for byline/date detection

use anyhow::Result;
use chrono::{DateTime, Utc, NaiveDateTime};
use regex::Regex;
use scraper::{Html, Selector};
use serde::{Deserialize, Serialize};
use schemars::JsonSchema;
use std::collections::HashMap;

/// Document metadata with validation
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct DocumentMetadata {
    pub title: Option<String>,
    pub description: Option<String>,
    pub author: Option<String>,
    pub published_date: Option<DateTime<Utc>>,
    pub modified_date: Option<DateTime<Utc>>,
    pub keywords: Vec<String>,
    pub language: Option<String>,
    pub canonical_url: Option<String>,
    pub image_url: Option<String>,
    pub site_name: Option<String>,
    pub article_section: Option<String>,
    pub word_count: Option<usize>,
    pub reading_time: Option<usize>,
    pub confidence_scores: MetadataConfidence,
    pub extraction_method: ExtractionMethod,
}

/// Confidence scores for metadata extraction
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct MetadataConfidence {
    pub title: f64,
    pub author: f64,
    pub date: f64,
    pub description: f64,
    pub overall: f64,
}

/// Method used for metadata extraction
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ExtractionMethod {
    pub open_graph: bool,
    pub json_ld: bool,
    pub microdata: bool,
    pub meta_tags: bool,
    pub heuristics: bool,
}

/// Extract comprehensive metadata from HTML content
pub async fn extract_metadata(html: &str, url: &str) -> Result<DocumentMetadata> {
    let document = Html::parse_document(html);
    let mut metadata = DocumentMetadata::default();
    let mut extraction_method = ExtractionMethod::default();

    // Extract from different sources with confidence scoring
    extract_open_graph(&document, &mut metadata, &mut extraction_method)?;
    extract_json_ld(&document, &mut metadata, &mut extraction_method)?;
    extract_meta_tags(&document, &mut metadata, &mut extraction_method)?;
    extract_microdata(&document, &mut metadata, &mut extraction_method)?;
    extract_heuristics(&document, &mut metadata, &mut extraction_method, url)?;

    // Calculate confidence scores
    metadata.confidence_scores = calculate_confidence_scores(&metadata, &extraction_method);
    metadata.extraction_method = extraction_method;

    // Validate and clean metadata
    validate_metadata(&mut metadata)?;

    Ok(metadata)
}

impl Default for DocumentMetadata {
    fn default() -> Self {
        Self {
            title: None,
            description: None,
            author: None,
            published_date: None,
            modified_date: None,
            keywords: Vec::new(),
            language: None,
            canonical_url: None,
            image_url: None,
            site_name: None,
            article_section: None,
            word_count: None,
            reading_time: None,
            confidence_scores: MetadataConfidence::default(),
            extraction_method: ExtractionMethod::default(),
        }
    }
}

impl Default for MetadataConfidence {
    fn default() -> Self {
        Self {
            title: 0.0,
            author: 0.0,
            date: 0.0,
            description: 0.0,
            overall: 0.0,
        }
    }
}

impl Default for ExtractionMethod {
    fn default() -> Self {
        Self {
            open_graph: false,
            json_ld: false,
            microdata: false,
            meta_tags: false,
            heuristics: false,
        }
    }
}

/// Extract Open Graph metadata
fn extract_open_graph(
    document: &Html,
    metadata: &mut DocumentMetadata,
    method: &mut ExtractionMethod,
) -> Result<()> {
    let og_selectors = [
        ("title", "meta[property='og:title']"),
        ("description", "meta[property='og:description']"),
        ("image", "meta[property='og:image']"),
        ("url", "meta[property='og:url']"),
        ("site_name", "meta[property='og:site_name']"),
        ("type", "meta[property='og:type']"),
        ("published_time", "meta[property='article:published_time']"),
        ("modified_time", "meta[property='article:modified_time']"),
        ("author", "meta[property='article:author']"),
        ("section", "meta[property='article:section']"),
    ];

    let mut found_og = false;

    for (field, selector_str) in &og_selectors {
        if let Ok(selector) = Selector::parse(selector_str) {
            if let Some(element) = document.select(&selector).next() {
                if let Some(content) = element.value().attr("content") {
                    match *field {
                        "title" => {
                            if metadata.title.is_none() {
                                metadata.title = Some(content.to_string());
                                found_og = true;
                            }
                        }
                        "description" => {
                            if metadata.description.is_none() {
                                metadata.description = Some(content.to_string());
                                found_og = true;
                            }
                        }
                        "image" => {
                            metadata.image_url = Some(content.to_string());
                            found_og = true;
                        }
                        "url" => {
                            metadata.canonical_url = Some(content.to_string());
                            found_og = true;
                        }
                        "site_name" => {
                            metadata.site_name = Some(content.to_string());
                            found_og = true;
                        }
                        "published_time" => {
                            if let Ok(date) = parse_date(content) {
                                metadata.published_date = Some(date);
                                found_og = true;
                            }
                        }
                        "modified_time" => {
                            if let Ok(date) = parse_date(content) {
                                metadata.modified_date = Some(date);
                                found_og = true;
                            }
                        }
                        "author" => {
                            if metadata.author.is_none() {
                                metadata.author = Some(content.to_string());
                                found_og = true;
                            }
                        }
                        "section" => {
                            metadata.article_section = Some(content.to_string());
                            found_og = true;
                        }
                        _ => {}
                    }
                }
            }
        }
    }

    method.open_graph = found_og;
    Ok(())
}

/// Extract JSON-LD structured data
fn extract_json_ld(
    document: &Html,
    metadata: &mut DocumentMetadata,
    method: &mut ExtractionMethod,
) -> Result<()> {
    let selector = Selector::parse("script[type='application/ld+json']").unwrap();

    for element in document.select(&selector) {
        let json_text = element.text().collect::<String>();

        if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(&json_text) {
            extract_from_json_ld(&json_value, metadata)?;
            method.json_ld = true;
        }
    }

    Ok(())
}

/// Extract data from JSON-LD structure
fn extract_from_json_ld(json: &serde_json::Value, metadata: &mut DocumentMetadata) -> Result<()> {
    // Handle both single objects and arrays
    let items = if json.is_array() {
        json.as_array().unwrap()
    } else {
        std::slice::from_ref(json)
    };

    for item in items {
        if let Some(obj) = item.as_object() {
            // Extract title/headline
            if metadata.title.is_none() {
                if let Some(headline) = obj.get("headline").and_then(|v| v.as_str()) {
                    metadata.title = Some(headline.to_string());
                } else if let Some(name) = obj.get("name").and_then(|v| v.as_str()) {
                    metadata.title = Some(name.to_string());
                }
            }

            // Extract description
            if metadata.description.is_none() {
                if let Some(desc) = obj.get("description").and_then(|v| v.as_str()) {
                    metadata.description = Some(desc.to_string());
                }
            }

            // Extract author
            if metadata.author.is_none() {
                if let Some(author_obj) = obj.get("author") {
                    let author_name = extract_author_from_json_ld(author_obj);
                    if !author_name.is_empty() {
                        metadata.author = Some(author_name);
                    }
                }
            }

            // Extract dates
            if let Some(date_str) = obj.get("datePublished").and_then(|v| v.as_str()) {
                if let Ok(date) = parse_date(date_str) {
                    metadata.published_date = Some(date);
                }
            }

            if let Some(date_str) = obj.get("dateModified").and_then(|v| v.as_str()) {
                if let Ok(date) = parse_date(date_str) {
                    metadata.modified_date = Some(date);
                }
            }

            // Extract keywords
            if let Some(keywords) = obj.get("keywords") {
                let extracted_keywords = extract_keywords_from_json_ld(keywords);
                metadata.keywords.extend(extracted_keywords);
            }

            // Extract image
            if metadata.image_url.is_none() {
                if let Some(image) = obj.get("image") {
                    let image_url = extract_image_from_json_ld(image);
                    if !image_url.is_empty() {
                        metadata.image_url = Some(image_url);
                    }
                }
            }

            // Extract language
            if metadata.language.is_none() {
                if let Some(lang) = obj.get("inLanguage").and_then(|v| v.as_str()) {
                    metadata.language = Some(lang.to_string());
                }
            }

            // Extract word count
            if metadata.word_count.is_none() {
                if let Some(count) = obj.get("wordCount").and_then(|v| v.as_u64()) {
                    metadata.word_count = Some(count as usize);
                }
            }
        }
    }

    Ok(())
}

/// Extract author from JSON-LD author object
fn extract_author_from_json_ld(author: &serde_json::Value) -> String {
    if let Some(author_str) = author.as_str() {
        return author_str.to_string();
    }

    if let Some(author_obj) = author.as_object() {
        if let Some(name) = author_obj.get("name").and_then(|v| v.as_str()) {
            return name.to_string();
        }
    }

    if let Some(author_array) = author.as_array() {
        if let Some(first_author) = author_array.first() {
            return extract_author_from_json_ld(first_author);
        }
    }

    String::new()
}

/// Extract keywords from JSON-LD keywords field
fn extract_keywords_from_json_ld(keywords: &serde_json::Value) -> Vec<String> {
    let mut result = Vec::new();

    if let Some(keywords_str) = keywords.as_str() {
        // Split by comma or semicolon
        result.extend(
            keywords_str
                .split(&[',', ';'][..])
                .map(|s| s.trim().to_string())
                .filter(|s| !s.is_empty())
        );
    } else if let Some(keywords_array) = keywords.as_array() {
        for keyword in keywords_array {
            if let Some(keyword_str) = keyword.as_str() {
                result.push(keyword_str.to_string());
            }
        }
    }

    result
}

/// Extract image URL from JSON-LD image field
fn extract_image_from_json_ld(image: &serde_json::Value) -> String {
    if let Some(image_str) = image.as_str() {
        return image_str.to_string();
    }

    if let Some(image_obj) = image.as_object() {
        if let Some(url) = image_obj.get("url").and_then(|v| v.as_str()) {
            return url.to_string();
        }
    }

    if let Some(image_array) = image.as_array() {
        if let Some(first_image) = image_array.first() {
            return extract_image_from_json_ld(first_image);
        }
    }

    String::new()
}

/// Extract standard meta tags
fn extract_meta_tags(
    document: &Html,
    metadata: &mut DocumentMetadata,
    method: &mut ExtractionMethod,
) -> Result<()> {
    let meta_selectors = [
        ("description", "meta[name='description']"),
        ("keywords", "meta[name='keywords']"),
        ("author", "meta[name='author']"),
        ("language", "meta[name='language']"),
        ("robots", "meta[name='robots']"),
    ];

    let mut found_meta = false;

    for (field, selector_str) in &meta_selectors {
        if let Ok(selector) = Selector::parse(selector_str) {
            if let Some(element) = document.select(&selector).next() {
                if let Some(content) = element.value().attr("content") {
                    match *field {
                        "description" => {
                            if metadata.description.is_none() {
                                metadata.description = Some(content.to_string());
                                found_meta = true;
                            }
                        }
                        "keywords" => {
                            let keywords: Vec<String> = content
                                .split(',')
                                .map(|s| s.trim().to_string())
                                .filter(|s| !s.is_empty())
                                .collect();
                            metadata.keywords.extend(keywords);
                            found_meta = true;
                        }
                        "author" => {
                            if metadata.author.is_none() {
                                metadata.author = Some(content.to_string());
                                found_meta = true;
                            }
                        }
                        "language" => {
                            if metadata.language.is_none() {
                                metadata.language = Some(content.to_string());
                                found_meta = true;
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
    }

    method.meta_tags = found_meta;
    Ok(())
}

/// Extract microdata
fn extract_microdata(
    document: &Html,
    metadata: &mut DocumentMetadata,
    method: &mut ExtractionMethod,
) -> Result<()> {
    // Look for itemscope and itemtype attributes
    let selector = Selector::parse("[itemscope][itemtype]").unwrap();

    for element in document.select(&selector) {
        if let Some(itemtype) = element.value().attr("itemtype") {
            if itemtype.contains("schema.org") {
                extract_schema_microdata(element, metadata)?;
                method.microdata = true;
            }
        }
    }

    Ok(())
}

/// Extract Schema.org microdata
fn extract_schema_microdata(
    _element: scraper::ElementRef,
    _metadata: &mut DocumentMetadata,
) -> Result<()> {
    // Simplified microdata extraction
    // In a full implementation, this would parse itemprop attributes
    Ok(())
}

/// Extract metadata using heuristics
fn extract_heuristics(
    document: &Html,
    metadata: &mut DocumentMetadata,
    method: &mut ExtractionMethod,
    url: &str,
) -> Result<()> {
    let mut found_heuristic = false;

    // Extract title from title tag if not found
    if metadata.title.is_none() {
        if let Ok(selector) = Selector::parse("title") {
            if let Some(element) = document.select(&selector).next() {
                let title = element.text().collect::<String>().trim().to_string();
                if !title.is_empty() {
                    metadata.title = Some(title);
                    found_heuristic = true;
                }
            }
        }
    }

    // Extract author using various selectors
    if metadata.author.is_none() {
        let author_selectors = [
            ".author",
            ".byline",
            ".writer",
            "[rel='author']",
            ".post-author",
            ".article-author",
        ];

        for selector_str in &author_selectors {
            if let Ok(selector) = Selector::parse(selector_str) {
                if let Some(element) = document.select(&selector).next() {
                    let author = element.text().collect::<String>().trim().to_string();
                    if !author.is_empty() && is_valid_author_name(&author) {
                        metadata.author = Some(author);
                        found_heuristic = true;
                        break;
                    }
                }
            }
        }
    }

    // Extract date using various selectors and patterns
    if metadata.published_date.is_none() {
        extract_date_heuristics(document, metadata)?;
        if metadata.published_date.is_some() {
            found_heuristic = true;
        }
    }

    // Extract canonical URL if not found
    if metadata.canonical_url.is_none() {
        if let Ok(selector) = Selector::parse("link[rel='canonical']") {
            if let Some(element) = document.select(&selector).next() {
                if let Some(href) = element.value().attr("href") {
                    metadata.canonical_url = Some(href.to_string());
                    found_heuristic = true;
                }
            }
        }
    }

    // Use provided URL as fallback
    if metadata.canonical_url.is_none() {
        metadata.canonical_url = Some(url.to_string());
    }

    method.heuristics = found_heuristic;
    Ok(())
}

/// Extract dates using heuristic patterns
fn extract_date_heuristics(document: &Html, metadata: &mut DocumentMetadata) -> Result<()> {
    let date_selectors = [
        "time[datetime]",
        ".date",
        ".published",
        ".post-date",
        ".article-date",
        ".timestamp",
    ];

    // Try datetime attribute first
    if let Ok(selector) = Selector::parse("time[datetime]") {
        if let Some(element) = document.select(&selector).next() {
            if let Some(datetime) = element.value().attr("datetime") {
                if let Ok(date) = parse_date(datetime) {
                    metadata.published_date = Some(date);
                    return Ok(());
                }
            }
        }
    }

    // Try text content of date elements
    for selector_str in &date_selectors {
        if let Ok(selector) = Selector::parse(selector_str) {
            if let Some(element) = document.select(&selector).next() {
                let date_text = element.text().collect::<String>();
                if let Ok(date) = parse_date_text(&date_text) {
                    metadata.published_date = Some(date);
                    return Ok(());
                }
            }
        }
    }

    Ok(())
}

/// Parse date from various formats
fn parse_date(date_str: &str) -> Result<DateTime<Utc>> {
    // Try ISO 8601 format first
    if let Ok(date) = DateTime::parse_from_rfc3339(date_str) {
        return Ok(date.with_timezone(&Utc));
    }

    // Try other common formats
    let formats = [
        "%Y-%m-%d",
        "%Y/%m/%d",
        "%m/%d/%Y",
        "%d/%m/%Y",
        "%B %d, %Y",
        "%b %d, %Y",
        "%Y-%m-%d %H:%M:%S",
        "%Y-%m-%dT%H:%M:%S",
    ];

    for format in &formats {
        if let Ok(naive_date) = NaiveDateTime::parse_from_str(date_str, format) {
            return Ok(DateTime::from_naive_utc_and_offset(naive_date, Utc));
        }
    }

    Err(anyhow::anyhow!("Unable to parse date: {}", date_str))
}

/// Parse date from text content with regex patterns
fn parse_date_text(text: &str) -> Result<DateTime<Utc>> {
    let date_patterns = [
        r"\b(\d{4})-(\d{1,2})-(\d{1,2})\b",
        r"\b(\d{1,2})/(\d{1,2})/(\d{4})\b",
        r"\b([A-Za-z]+)\s+(\d{1,2}),?\s+(\d{4})\b",
    ];

    for pattern_str in &date_patterns {
        if let Ok(regex) = Regex::new(pattern_str) {
            if let Some(captures) = regex.captures(text) {
                if let Some(date_match) = captures.get(0) {
                    if let Ok(date) = parse_date(date_match.as_str()) {
                        return Ok(date);
                    }
                }
            }
        }
    }

    Err(anyhow::anyhow!("No date pattern found in text"))
}

/// Validate if a string looks like a valid author name
fn is_valid_author_name(name: &str) -> bool {
    // Simple validation - not too short, not too long, contains letters
    name.len() >= 2 &&
    name.len() <= 100 &&
    name.chars().any(|c| c.is_alphabetic()) &&
    !name.to_lowercase().contains("admin") &&
    !name.to_lowercase().contains("user")
}

/// Calculate confidence scores for extracted metadata
fn calculate_confidence_scores(
    metadata: &DocumentMetadata,
    method: &ExtractionMethod,
) -> MetadataConfidence {
    let mut confidence = MetadataConfidence::default();

    // Title confidence
    confidence.title = if metadata.title.is_some() {
        let mut score = 0.5_f64;
        if method.open_graph { score += 0.3; }
        if method.json_ld { score += 0.2; }
        if method.meta_tags { score += 0.1; }
        score.min(1.0_f64)
    } else {
        0.0
    };

    // Author confidence
    confidence.author = if metadata.author.is_some() {
        let mut score = 0.4_f64;
        if method.open_graph { score += 0.3; }
        if method.json_ld { score += 0.3; }
        if method.meta_tags { score += 0.2; }
        if method.heuristics { score += 0.1; }
        score.min(1.0_f64)
    } else {
        0.0
    };

    // Date confidence
    confidence.date = if metadata.published_date.is_some() {
        let mut score = 0.6_f64;
        if method.open_graph { score += 0.25; }
        if method.json_ld { score += 0.25; }
        if method.heuristics { score += 0.1; }
        score.min(1.0_f64)
    } else {
        0.0
    };

    // Description confidence
    confidence.description = if metadata.description.is_some() {
        let mut score = 0.5_f64;
        if method.open_graph { score += 0.3; }
        if method.json_ld { score += 0.2; }
        if method.meta_tags { score += 0.2; }
        score.min(1.0_f64)
    } else {
        0.0
    };

    // Overall confidence
    confidence.overall = (confidence.title + confidence.author + confidence.date + confidence.description) / 4.0;

    confidence
}

/// Validate and clean metadata
fn validate_metadata(metadata: &mut DocumentMetadata) -> Result<()> {
    // Clean title
    if let Some(ref mut title) = metadata.title {
        *title = title.trim().to_string();
        if title.is_empty() {
            metadata.title = None;
        }
    }

    // Clean description
    if let Some(ref mut description) = metadata.description {
        *description = description.trim().to_string();
        if description.is_empty() {
            metadata.description = None;
        }
    }

    // Clean author
    if let Some(ref mut author) = metadata.author {
        *author = author.trim().to_string();
        if author.is_empty() || !is_valid_author_name(author) {
            metadata.author = None;
        }
    }

    // Deduplicate keywords
    metadata.keywords.sort();
    metadata.keywords.dedup();

    // Calculate word count and reading time if not present
    if metadata.word_count.is_none() {
        // This would be calculated from the main content
        // For now, we'll leave it as None
    }

    if metadata.reading_time.is_none() && metadata.word_count.is_some() {
        // Average reading speed: 200 words per minute
        let words = metadata.word_count.unwrap();
        metadata.reading_time = Some((words / 200).max(1));
    }

    Ok(())
}