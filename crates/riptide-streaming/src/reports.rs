//! HTML report generation with dynamic templates and visualizations\n//!\n//! This module provides comprehensive HTML report generation for extraction results,\n//! including charts, tables, and interactive visualizations.\n\nuse crate::{ExtractionResult, StreamingError, StreamingResult};\nuse anyhow::Result;\nuse handlebars::{Handlebars, Helper, Context, RenderContext, Output, HelperResult};\nuse plotters::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::io::Cursor;\nuse base64::Engine;\n\n/// Report format options\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ReportFormat {\n    Html,\n    Json,\n    Csv,\n    Pdf,\n}\n\n/// Report configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ReportConfig {\n    pub title: String,\n    pub include_charts: bool,\n    pub include_raw_data: bool,\n    pub include_metadata: bool,\n    pub chart_width: u32,\n    pub chart_height: u32,\n    pub theme: ReportTheme,\n}\n\n/// Report theme configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ReportTheme {\n    Light,\n    Dark,\n    Corporate,\n    Modern,\n}\n\nimpl Default for ReportConfig {\n    fn default() -> Self {\n        Self {\n            title: \"RipTide Extraction Report\".to_string(),\n            include_charts: true,\n            include_raw_data: false,\n            include_metadata: true,\n            chart_width: 800,\n            chart_height: 400,\n            theme: ReportTheme::Modern,\n        }\n    }\n}\n\n/// Report data structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ReportData {\n    pub extraction_id: String,\n    pub title: String,\n    pub generation_time: chrono::DateTime<chrono::Utc>,\n    pub total_results: usize,\n    pub total_pages: usize,\n    pub total_words: usize,\n    pub total_processing_time: u64,\n    pub average_processing_time: f64,\n    pub success_rate: f64,\n    pub results: Vec<ExtractionResult>,\n    pub domain_stats: HashMap<String, DomainStats>,\n    pub timeline: Vec<TimelineEntry>,\n    pub word_cloud_data: Vec<WordFrequency>,\n    pub charts: HashMap<String, String>, // Base64 encoded chart images\n}\n\n/// Statistics for a domain\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DomainStats {\n    pub domain: String,\n    pub count: usize,\n    pub total_words: usize,\n    pub average_words: f64,\n    pub success_rate: f64,\n    pub average_processing_time: f64,\n}\n\n/// Timeline entry for extraction progress\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TimelineEntry {\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n    pub event: String,\n    pub count: usize,\n    pub rate: f64,\n}\n\n/// Word frequency data for word clouds\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WordFrequency {\n    pub word: String,\n    pub frequency: usize,\n    pub percentage: f64,\n}\n\n/// HTML report generator\n#[derive(Debug)]\npub struct ReportGenerator {\n    handlebars: Handlebars<'static>,\n    config: ReportConfig,\n}\n\nimpl ReportGenerator {\n    /// Create a new report generator\n    pub fn new() -> Self {\n        Self::with_config(ReportConfig::default())\n    }\n\n    /// Create a new report generator with custom configuration\n    pub fn with_config(config: ReportConfig) -> Self {\n        let mut handlebars = Handlebars::new();\n        \n        // Register templates\n        handlebars.register_template_string(\"main\", MAIN_TEMPLATE)\n            .expect(\"Failed to register main template\");\n        handlebars.register_template_string(\"summary\", SUMMARY_TEMPLATE)\n            .expect(\"Failed to register summary template\");\n        handlebars.register_template_string(\"results\", RESULTS_TEMPLATE)\n            .expect(\"Failed to register results template\");\n        handlebars.register_template_string(\"charts\", CHARTS_TEMPLATE)\n            .expect(\"Failed to register charts template\");\n        \n        // Register helpers\n        handlebars.register_helper(\"format_duration\", Box::new(format_duration));\n        handlebars.register_helper(\"format_number\", Box::new(format_number));\n        handlebars.register_helper(\"format_percentage\", Box::new(format_percentage));\n        handlebars.register_helper(\"truncate\", Box::new(truncate));\n        handlebars.register_helper(\"highlight_keywords\", Box::new(highlight_keywords));\n        \n        Self {\n            handlebars,\n            config,\n        }\n    }\n\n    /// Generate a report for extraction results\n    pub async fn generate_report(&self, extraction_id: &str, format: ReportFormat) -> Result<Vec<u8>> {\n        // This would normally fetch results from storage\n        // For now, we'll generate sample data\n        let results = self.fetch_extraction_results(extraction_id).await?;\n        let report_data = self.prepare_report_data(extraction_id, results).await?;\n        \n        match format {\n            ReportFormat::Html => self.generate_html_report(&report_data).await,\n            ReportFormat::Json => self.generate_json_report(&report_data).await,\n            ReportFormat::Csv => self.generate_csv_report(&report_data).await,\n            ReportFormat::Pdf => self.generate_pdf_report(&report_data).await,\n        }\n    }\n\n    /// Generate HTML report\n    async fn generate_html_report(&self, data: &ReportData) -> Result<Vec<u8>> {\n        let mut context = serde_json::to_value(data)?;\n        \n        // Add configuration to context\n        if let Some(obj) = context.as_object_mut() {\n            obj.insert(\"config\".to_string(), serde_json::to_value(&self.config)?);\n            obj.insert(\"theme_css\".to_string(), serde_json::Value::String(self.get_theme_css()));\n        }\n        \n        let html = self.handlebars.render(\"main\", &context)?;\n        Ok(html.into_bytes())\n    }\n\n    /// Generate JSON report\n    async fn generate_json_report(&self, data: &ReportData) -> Result<Vec<u8>> {\n        let json = serde_json::to_string_pretty(data)?;\n        Ok(json.into_bytes())\n    }\n\n    /// Generate CSV report\n    async fn generate_csv_report(&self, data: &ReportData) -> Result<Vec<u8>> {\n        let mut csv = String::new();\n        \n        // Header\n        csv.push_str(\"ID,URL,Title,Word Count,Processing Time (ms),Timestamp\\n\");\n        \n        // Data rows\n        for result in &data.results {\n            csv.push_str(&format!(\n                \"{},{},{},{},{},{}\\n\",\n                result.id,\n                result.url,\n                result.title.as_deref().unwrap_or(\"N/A\"),\n                result.word_count,\n                result.extraction_time_ms,\n                result.timestamp.format(\"%Y-%m-%d %H:%M:%S\")\n            ));\n        }\n        \n        Ok(csv.into_bytes())\n    }\n\n    /// Generate PDF report (placeholder)\n    async fn generate_pdf_report(&self, _data: &ReportData) -> Result<Vec<u8>> {\n        // This would require a PDF generation library like wkhtmltopdf or similar\n        // For now, return HTML as bytes\n        self.generate_html_report(_data).await\n    }\n\n    /// Prepare report data from extraction results\n    async fn prepare_report_data(&self, extraction_id: &str, results: Vec<ExtractionResult>) -> Result<ReportData> {\n        let total_results = results.len();\n        let total_words: usize = results.iter().map(|r| r.word_count).sum();\n        let total_processing_time: u64 = results.iter().map(|r| r.extraction_time_ms).sum();\n        let average_processing_time = if total_results > 0 {\n            total_processing_time as f64 / total_results as f64\n        } else {\n            0.0\n        };\n        \n        // Calculate domain statistics\n        let domain_stats = self.calculate_domain_stats(&results);\n        \n        // Generate timeline\n        let timeline = self.generate_timeline(&results);\n        \n        // Generate word cloud data\n        let word_cloud_data = self.generate_word_cloud_data(&results);\n        \n        // Generate charts if enabled\n        let charts = if self.config.include_charts {\n            self.generate_charts(&results, &domain_stats, &timeline).await?\n        } else {\n            HashMap::new()\n        };\n        \n        Ok(ReportData {\n            extraction_id: extraction_id.to_string(),\n            title: self.config.title.clone(),\n            generation_time: chrono::Utc::now(),\n            total_results,\n            total_pages: results.len(), // Assuming one page per result\n            total_words,\n            total_processing_time,\n            average_processing_time,\n            success_rate: 100.0, // Would be calculated based on actual success/failure data\n            results,\n            domain_stats,\n            timeline,\n            word_cloud_data,\n            charts,\n        })\n    }\n\n    /// Calculate domain statistics\n    fn calculate_domain_stats(&self, results: &[ExtractionResult]) -> HashMap<String, DomainStats> {\n        let mut stats: HashMap<String, Vec<&ExtractionResult>> = HashMap::new();\n        \n        // Group results by domain\n        for result in results {\n            if let Ok(url) = url::Url::parse(&result.url) {\n                if let Some(domain) = url.domain() {\n                    stats.entry(domain.to_string()).or_default().push(result);\n                }\n            }\n        }\n        \n        // Calculate statistics for each domain\n        stats.into_iter().map(|(domain, domain_results)| {\n            let count = domain_results.len();\n            let total_words: usize = domain_results.iter().map(|r| r.word_count).sum();\n            let average_words = total_words as f64 / count as f64;\n            let total_time: u64 = domain_results.iter().map(|r| r.extraction_time_ms).sum();\n            let average_processing_time = total_time as f64 / count as f64;\n            \n            (domain.clone(), DomainStats {\n                domain,\n                count,\n                total_words,\n                average_words,\n                success_rate: 100.0, // Would be calculated from actual data\n                average_processing_time,\n            })\n        }).collect()\n    }\n\n    /// Generate timeline entries\n    fn generate_timeline(&self, results: &[ExtractionResult]) -> Vec<TimelineEntry> {\n        let mut timeline = Vec::new();\n        let mut sorted_results: Vec<_> = results.iter().collect();\n        sorted_results.sort_by_key(|r| r.timestamp);\n        \n        // Group by hour for timeline\n        let mut hourly_counts: HashMap<chrono::DateTime<chrono::Utc>, usize> = HashMap::new();\n        \n        for result in sorted_results {\n            let hour = result.timestamp.with_minute(0).unwrap().with_second(0).unwrap().with_nanosecond(0).unwrap();\n            *hourly_counts.entry(hour).or_insert(0) += 1;\n        }\n        \n        for (timestamp, count) in hourly_counts {\n            timeline.push(TimelineEntry {\n                timestamp,\n                event: \"Extractions Completed\".to_string(),\n                count,\n                rate: count as f64, // Could calculate rate per hour\n            });\n        }\n        \n        timeline.sort_by_key(|t| t.timestamp);\n        timeline\n    }\n\n    /// Generate word cloud data\n    fn generate_word_cloud_data(&self, results: &[ExtractionResult]) -> Vec<WordFrequency> {\n        let mut word_counts: HashMap<String, usize> = HashMap::new();\n        let mut total_words = 0;\n        \n        for result in results {\n            if let Some(title) = &result.title {\n                let words: Vec<&str> = title.split_whitespace()\n                    .map(|w| w.trim_matches(|c: char| !c.is_alphanumeric()))\n                    .filter(|w| w.len() > 3) // Filter out short words\n                    .collect();\n                \n                for word in words {\n                    let word = word.to_lowercase();\n                    *word_counts.entry(word).or_insert(0) += 1;\n                    total_words += 1;\n                }\n            }\n        }\n        \n        let mut word_frequencies: Vec<_> = word_counts.into_iter()\n            .map(|(word, frequency)| WordFrequency {\n                word,\n                frequency,\n                percentage: frequency as f64 / total_words as f64 * 100.0,\n            })\n            .collect();\n        \n        word_frequencies.sort_by(|a, b| b.frequency.cmp(&a.frequency));\n        word_frequencies.truncate(50); // Top 50 words\n        \n        word_frequencies\n    }\n\n    /// Generate charts\n    async fn generate_charts(\n        &self,\n        results: &[ExtractionResult],\n        domain_stats: &HashMap<String, DomainStats>,\n        timeline: &[TimelineEntry]\n    ) -> Result<HashMap<String, String>> {\n        let mut charts = HashMap::new();\n        \n        // Processing time distribution chart\n        if let Ok(chart_data) = self.create_processing_time_chart(results) {\n            charts.insert(\"processing_time\".to_string(), chart_data);\n        }\n        \n        // Domain distribution pie chart\n        if let Ok(chart_data) = self.create_domain_pie_chart(domain_stats) {\n            charts.insert(\"domain_distribution\".to_string(), chart_data);\n        }\n        \n        // Timeline chart\n        if let Ok(chart_data) = self.create_timeline_chart(timeline) {\n            charts.insert(\"timeline\".to_string(), chart_data);\n        }\n        \n        // Word count distribution\n        if let Ok(chart_data) = self.create_word_count_chart(results) {\n            charts.insert(\"word_count\".to_string(), chart_data);\n        }\n        \n        Ok(charts)\n    }\n\n    /// Create processing time distribution chart\n    fn create_processing_time_chart(&self, results: &[ExtractionResult]) -> Result<String> {\n        let mut buffer = Vec::new();\n        {\n            let root = BitMapBackend::with_buffer(&mut buffer, (self.config.chart_width, self.config.chart_height))\n                .into_drawing_area();\n            root.fill(&WHITE)?;\n            \n            let times: Vec<u64> = results.iter().map(|r| r.extraction_time_ms).collect();\n            \n            // Create histogram buckets\n            let max_time = times.iter().max().cloned().unwrap_or(0);\n            let bucket_size = (max_time / 10).max(1);\n            let mut buckets = vec![0; 10];\n            \n            for time in times {\n                let bucket = ((time / bucket_size) as usize).min(9);\n                buckets[bucket] += 1;\n            }\n            \n            let mut chart = ChartBuilder::on(&root)\n                .caption(\"Processing Time Distribution\", (\"sans-serif\", 30))\n                .margin(20)\n                .x_label_area_size(40)\n                .y_label_area_size(40)\n                .build_cartesian_2d(0..10, 0..*buckets.iter().max().unwrap_or(&1))?;\n            \n            chart.configure_mesh().draw()?;\n            \n            chart.draw_series(\n                buckets.iter().enumerate().map(|(i, &count)| {\n                    Rectangle::new([(i, 0), (i, count)], BLUE.filled())\n                })\n            )?;\n            \n            root.present()?;\n        }\n        \n        let base64 = base64::engine::general_purpose::STANDARD.encode(&buffer);\n        Ok(format!(\"data:image/png;base64,{}\", base64))\n    }\n\n    /// Create domain distribution pie chart (simplified)\n    fn create_domain_pie_chart(&self, domain_stats: &HashMap<String, DomainStats>) -> Result<String> {\n        let mut buffer = Vec::new();\n        {\n            let root = BitMapBackend::with_buffer(&mut buffer, (self.config.chart_width, self.config.chart_height))\n                .into_drawing_area();\n            root.fill(&WHITE)?;\n            \n            // For simplicity, create a bar chart instead of pie chart\n            let mut domains: Vec<_> = domain_stats.values().collect();\n            domains.sort_by(|a, b| b.count.cmp(&a.count));\n            domains.truncate(10); // Top 10 domains\n            \n            let max_count = domains.iter().map(|d| d.count).max().unwrap_or(1);\n            \n            let mut chart = ChartBuilder::on(&root)\n                .caption(\"Top Domains by Count\", (\"sans-serif\", 30))\n                .margin(20)\n                .x_label_area_size(80)\n                .y_label_area_size(40)\n                .build_cartesian_2d(0..domains.len(), 0..max_count)?;\n            \n            chart.configure_mesh()\n                .x_desc(\"Domain\")\n                .y_desc(\"Count\")\n                .draw()?;\n            \n            chart.draw_series(\n                domains.iter().enumerate().map(|(i, domain)| {\n                    Rectangle::new([(i, 0), (i, domain.count)], BLUE.filled())\n                })\n            )?;\n            \n            root.present()?;\n        }\n        \n        let base64 = base64::engine::general_purpose::STANDARD.encode(&buffer);\n        Ok(format!(\"data:image/png;base64,{}\", base64))\n    }\n\n    /// Create timeline chart\n    fn create_timeline_chart(&self, timeline: &[TimelineEntry]) -> Result<String> {\n        let mut buffer = Vec::new();\n        {\n            let root = BitMapBackend::with_buffer(&mut buffer, (self.config.chart_width, self.config.chart_height))\n                .into_drawing_area();\n            root.fill(&WHITE)?;\n            \n            if timeline.is_empty() {\n                return Ok(String::new());\n            }\n            \n            let start_time = timeline.first().unwrap().timestamp;\n            let end_time = timeline.last().unwrap().timestamp;\n            let max_count = timeline.iter().map(|t| t.count).max().unwrap_or(1);\n            \n            let mut chart = ChartBuilder::on(&root)\n                .caption(\"Extraction Timeline\", (\"sans-serif\", 30))\n                .margin(20)\n                .x_label_area_size(40)\n                .y_label_area_size(40)\n                .build_cartesian_2d(start_time..end_time, 0..max_count)?;\n            \n            chart.configure_mesh().draw()?;\n            \n            chart.draw_series(LineSeries::new(\n                timeline.iter().map(|t| (t.timestamp, t.count)),\n                &BLUE\n            ))?;\n            \n            root.present()?;\n        }\n        \n        let base64 = base64::engine::general_purpose::STANDARD.encode(&buffer);\n        Ok(format!(\"data:image/png;base64,{}\", base64))\n    }\n\n    /// Create word count distribution chart\n    fn create_word_count_chart(&self, results: &[ExtractionResult]) -> Result<String> {\n        let mut buffer = Vec::new();\n        {\n            let root = BitMapBackend::with_buffer(&mut buffer, (self.config.chart_width, self.config.chart_height))\n                .into_drawing_area();\n            root.fill(&WHITE)?;\n            \n            let word_counts: Vec<usize> = results.iter().map(|r| r.word_count).collect();\n            \n            // Create histogram buckets\n            let max_words = word_counts.iter().max().cloned().unwrap_or(0);\n            let bucket_size = (max_words / 10).max(1);\n            let mut buckets = vec![0; 10];\n            \n            for count in word_counts {\n                let bucket = (count / bucket_size).min(9);\n                buckets[bucket] += 1;\n            }\n            \n            let mut chart = ChartBuilder::on(&root)\n                .caption(\"Word Count Distribution\", (\"sans-serif\", 30))\n                .margin(20)\n                .x_label_area_size(40)\n                .y_label_area_size(40)\n                .build_cartesian_2d(0..10, 0..*buckets.iter().max().unwrap_or(&1))?;\n            \n            chart.configure_mesh().draw()?;\n            \n            chart.draw_series(\n                buckets.iter().enumerate().map(|(i, &count)| {\n                    Rectangle::new([(i, 0), (i, count)], GREEN.filled())\n                })\n            )?;\n            \n            root.present()?;\n        }\n        \n        let base64 = base64::engine::general_purpose::STANDARD.encode(&buffer);\n        Ok(format!(\"data:image/png;base64,{}\", base64))\n    }\n\n    /// Get theme CSS\n    fn get_theme_css(&self) -> String {\n        match self.config.theme {\n            ReportTheme::Light => LIGHT_THEME_CSS.to_string(),\n            ReportTheme::Dark => DARK_THEME_CSS.to_string(),\n            ReportTheme::Corporate => CORPORATE_THEME_CSS.to_string(),\n            ReportTheme::Modern => MODERN_THEME_CSS.to_string(),\n        }\n    }\n\n    /// Fetch extraction results (placeholder)\n    async fn fetch_extraction_results(&self, _extraction_id: &str) -> Result<Vec<ExtractionResult>> {\n        // This would normally fetch from storage\n        // For now, return sample data\n        Ok(vec![\n            ExtractionResult {\n                id: \"result-1\".to_string(),\n                url: \"https://example.com/page1\".to_string(),\n                title: Some(\"Example Page 1\".to_string()),\n                content: \"This is sample content from page 1\".to_string(),\n                metadata: HashMap::new(),\n                timestamp: chrono::Utc::now(),\n                extraction_time_ms: 250,\n                word_count: 8,\n                links: vec![],\n                images: vec![],\n            },\n            ExtractionResult {\n                id: \"result-2\".to_string(),\n                url: \"https://example.com/page2\".to_string(),\n                title: Some(\"Example Page 2\".to_string()),\n                content: \"This is sample content from page 2 with more words\".to_string(),\n                metadata: HashMap::new(),\n                timestamp: chrono::Utc::now(),\n                extraction_time_ms: 180,\n                word_count: 11,\n                links: vec![],\n                images: vec![],\n            },\n        ])\n    }\n}\n\nimpl Default for ReportGenerator {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n// Handlebars helpers\nfn format_duration(h: &Helper, _: &Handlebars, _: &Context, _: &mut RenderContext, out: &mut dyn Output) -> HelperResult {\n    let duration_ms = h.param(0)\n        .and_then(|v| v.value().as_u64())\n        .unwrap_or(0);\n    \n    let formatted = if duration_ms < 1000 {\n        format!(\"{}ms\", duration_ms)\n    } else if duration_ms < 60000 {\n        format!(\"{:.1}s\", duration_ms as f64 / 1000.0)\n    } else {\n        format!(\"{:.1}m\", duration_ms as f64 / 60000.0)\n    };\n    \n    out.write(&formatted)?;\n    Ok(())\n}\n\nfn format_number(h: &Helper, _: &Handlebars, _: &Context, _: &mut RenderContext, out: &mut dyn Output) -> HelperResult {\n    let number = h.param(0)\n        .and_then(|v| v.value().as_u64())\n        .unwrap_or(0);\n    \n    let formatted = if number < 1000 {\n        number.to_string()\n    } else if number < 1000000 {\n        format!(\"{:.1}K\", number as f64 / 1000.0)\n    } else {\n        format!(\"{:.1}M\", number as f64 / 1000000.0)\n    };\n    \n    out.write(&formatted)?;\n    Ok(())\n}\n\nfn format_percentage(h: &Helper, _: &Handlebars, _: &Context, _: &mut RenderContext, out: &mut dyn Output) -> HelperResult {\n    let percentage = h.param(0)\n        .and_then(|v| v.value().as_f64())\n        .unwrap_or(0.0);\n    \n    let formatted = format!(\"{:.1}%\", percentage);\n    out.write(&formatted)?;\n    Ok(())\n}\n\nfn truncate(h: &Helper, _: &Handlebars, _: &Context, _: &mut RenderContext, out: &mut dyn Output) -> HelperResult {\n    let text = h.param(0)\n        .and_then(|v| v.value().as_str())\n        .unwrap_or(\"\");\n    let length = h.param(1)\n        .and_then(|v| v.value().as_u64())\n        .unwrap_or(100) as usize;\n    \n    let truncated = if text.len() > length {\n        format!(\"{}...\", &text[..length])\n    } else {\n        text.to_string()\n    };\n    \n    out.write(&truncated)?;\n    Ok(())\n}\n\nfn highlight_keywords(h: &Helper, _: &Handlebars, _: &Context, _: &mut RenderContext, out: &mut dyn Output) -> HelperResult {\n    let text = h.param(0)\n        .and_then(|v| v.value().as_str())\n        .unwrap_or(\"\");\n    \n    // Simple keyword highlighting (would be more sophisticated in real implementation)\n    let highlighted = text.replace(\"extraction\", \"<mark>extraction</mark>\")\n        .replace(\"data\", \"<mark>data</mark>\")\n        .replace(\"content\", \"<mark>content</mark>\");\n    \n    out.write(&highlighted)?;\n    Ok(())\n}\n\n// Template constants\nconst MAIN_TEMPLATE: &str = r#\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>{{title}}</title>\n    <style>{{{theme_css}}}</style>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>{{title}}</h1>\n            <div class=\"generation-info\">\n                Generated on {{generation_time}} for extraction: <code>{{extraction_id}}</code>\n            </div>\n        </header>\n        \n        {{> summary}}\n        \n        {{#if config.include_charts}}\n        {{> charts}}\n        {{/if}}\n        \n        {{> results}}\n    </div>\n</body>\n</html>\n\"#;\n\nconst SUMMARY_TEMPLATE: &str = r#\"\n<section class=\"summary\">\n    <h2>Summary</h2>\n    <div class=\"stats-grid\">\n        <div class=\"stat-card\">\n            <h3>{{format_number total_results}}</h3>\n            <p>Total Results</p>\n        </div>\n        <div class=\"stat-card\">\n            <h3>{{format_number total_words}}</h3>\n            <p>Total Words</p>\n        </div>\n        <div class=\"stat-card\">\n            <h3>{{format_duration total_processing_time}}</h3>\n            <p>Total Processing Time</p>\n        </div>\n        <div class=\"stat-card\">\n            <h3>{{format_percentage success_rate}}</h3>\n            <p>Success Rate</p>\n        </div>\n    </div>\n</section>\n\"#;\n\nconst RESULTS_TEMPLATE: &str = r#\"\n<section class=\"results\">\n    <h2>Extraction Results</h2>\n    <div class=\"results-table\">\n        <table>\n            <thead>\n                <tr>\n                    <th>URL</th>\n                    <th>Title</th>\n                    <th>Word Count</th>\n                    <th>Processing Time</th>\n                    <th>Timestamp</th>\n                </tr>\n            </thead>\n            <tbody>\n                {{#each results}}\n                <tr>\n                    <td><a href=\"{{url}}\" target=\"_blank\">{{truncate url 50}}</a></td>\n                    <td>{{title}}</td>\n                    <td>{{word_count}}</td>\n                    <td>{{format_duration extraction_time_ms}}</td>\n                    <td>{{timestamp}}</td>\n                </tr>\n                {{/each}}\n            </tbody>\n        </table>\n    </div>\n</section>\n\"#;\n\nconst CHARTS_TEMPLATE: &str = r#\"\n<section class=\"charts\">\n    <h2>Analytics</h2>\n    <div class=\"charts-grid\">\n        {{#if charts.processing_time}}\n        <div class=\"chart\">\n            <h3>Processing Time Distribution</h3>\n            <img src=\"{{charts.processing_time}}\" alt=\"Processing Time Chart\" />\n        </div>\n        {{/if}}\n        \n        {{#if charts.domain_distribution}}\n        <div class=\"chart\">\n            <h3>Domain Distribution</h3>\n            <img src=\"{{charts.domain_distribution}}\" alt=\"Domain Distribution Chart\" />\n        </div>\n        {{/if}}\n        \n        {{#if charts.timeline}}\n        <div class=\"chart\">\n            <h3>Extraction Timeline</h3>\n            <img src=\"{{charts.timeline}}\" alt=\"Timeline Chart\" />\n        </div>\n        {{/if}}\n        \n        {{#if charts.word_count}}\n        <div class=\"chart\">\n            <h3>Word Count Distribution</h3>\n            <img src=\"{{charts.word_count}}\" alt=\"Word Count Chart\" />\n        </div>\n        {{/if}}\n    </div>\n</section>\n\"#;\n\nconst MODERN_THEME_CSS: &str = r#\"\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    line-height: 1.6;\n    color: #333;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    margin: 0;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    background: white;\n    border-radius: 12px;\n    box-shadow: 0 20px 40px rgba(0,0,0,0.1);\n    overflow: hidden;\n}\n\nheader {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 40px;\n    text-align: center;\n}\n\nheader h1 {\n    margin: 0;\n    font-size: 2.5em;\n    font-weight: 300;\n}\n\n.generation-info {\n    margin-top: 10px;\n    opacity: 0.9;\n}\n\nsection {\n    padding: 40px;\n}\n\n.stats-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-top: 20px;\n}\n\n.stat-card {\n    background: #f8f9fa;\n    padding: 30px;\n    border-radius: 8px;\n    text-align: center;\n    border-left: 4px solid #667eea;\n}\n\n.stat-card h3 {\n    font-size: 2em;\n    margin: 0;\n    color: #667eea;\n}\n\n.stat-card p {\n    margin: 10px 0 0 0;\n    color: #666;\n}\n\n.charts-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));\n    gap: 30px;\n    margin-top: 20px;\n}\n\n.chart {\n    text-align: center;\n}\n\n.chart img {\n    max-width: 100%;\n    border-radius: 8px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.1);\n}\n\ntable {\n    width: 100%;\n    border-collapse: collapse;\n    margin-top: 20px;\n}\n\nth, td {\n    padding: 12px;\n    text-align: left;\n    border-bottom: 1px solid #ddd;\n}\n\nth {\n    background: #f8f9fa;\n    font-weight: 600;\n    color: #333;\n}\n\ntr:hover {\n    background: #f8f9fa;\n}\n\na {\n    color: #667eea;\n    text-decoration: none;\n}\n\na:hover {\n    text-decoration: underline;\n}\n\ncode {\n    background: rgba(102, 126, 234, 0.1);\n    padding: 2px 6px;\n    border-radius: 4px;\n    font-family: 'Monaco', 'Courier New', monospace;\n}\n\nmark {\n    background: #fff3cd;\n    padding: 1px 3px;\n    border-radius: 2px;\n}\n\"#;\n\nconst LIGHT_THEME_CSS: &str = r#\"\nbody { font-family: Arial, sans-serif; background: #f5f5f5; }\n.container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; }\nheader { background: #007bff; color: white; padding: 20px; }\n.stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; }\n.stat-card { background: #f8f9fa; padding: 20px; border-radius: 5px; }\ntable { width: 100%; border-collapse: collapse; }\nth, td { padding: 10px; border: 1px solid #ddd; }\n\"#;\n\nconst DARK_THEME_CSS: &str = r#\"\nbody { font-family: Arial, sans-serif; background: #1a1a1a; color: #ffffff; }\n.container { max-width: 1200px; margin: 0 auto; background: #2d2d2d; padding: 20px; }\nheader { background: #0d6efd; color: white; padding: 20px; }\n.stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; }\n.stat-card { background: #3d3d3d; padding: 20px; border-radius: 5px; }\ntable { width: 100%; border-collapse: collapse; }\nth, td { padding: 10px; border: 1px solid #555; }\nth { background: #3d3d3d; }\n\"#;\n\nconst CORPORATE_THEME_CSS: &str = r#\"\nbody { font-family: 'Times New Roman', serif; background: #ffffff; color: #333; }\n.container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border: 1px solid #ccc; }\nheader { background: #2c3e50; color: white; padding: 30px; text-align: center; }\n.stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; }\n.stat-card { background: #ecf0f1; padding: 20px; border: 1px solid #bdc3c7; }\ntable { width: 100%; border-collapse: collapse; }\nth, td { padding: 12px; border: 1px solid #bdc3c7; }\nth { background: #ecf0f1; }\n\"#;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_report_generator_creation() {\n        let generator = ReportGenerator::new();\n        assert_eq!(generator.config.title, \"RipTide Extraction Report\");\n    }\n\n    #[test]\n    fn test_report_config_default() {\n        let config = ReportConfig::default();\n        assert!(config.include_charts);\n        assert!(config.include_metadata);\n        assert!(!config.include_raw_data);\n    }\n\n    #[tokio::test]\n    async fn test_generate_json_report() {\n        let generator = ReportGenerator::new();\n        let results = vec![\n            ExtractionResult {\n                id: \"test-1\".to_string(),\n                url: \"https://example.com\".to_string(),\n                title: Some(\"Test\".to_string()),\n                content: \"Test content\".to_string(),\n                metadata: HashMap::new(),\n                timestamp: chrono::Utc::now(),\n                extraction_time_ms: 100,\n                word_count: 2,\n                links: vec![],\n                images: vec![],\n            }\n        ];\n        \n        let report_data = generator.prepare_report_data(\"test-extraction\", results).await.unwrap();\n        let json_report = generator.generate_json_report(&report_data).await.unwrap();\n        \n        let json_str = String::from_utf8(json_report).unwrap();\n        assert!(json_str.contains(\"test-extraction\"));\n        assert!(json_str.contains(\"Test\"));\n    }\n\n    #[tokio::test]\n    async fn test_generate_csv_report() {\n        let generator = ReportGenerator::new();\n        let results = vec![\n            ExtractionResult {\n                id: \"test-1\".to_string(),\n                url: \"https://example.com\".to_string(),\n                title: Some(\"Test\".to_string()),\n                content: \"Test content\".to_string(),\n                metadata: HashMap::new(),\n                timestamp: chrono::Utc::now(),\n                extraction_time_ms: 100,\n                word_count: 2,\n                links: vec![],\n                images: vec![],\n            }\n        ];\n        \n        let report_data = generator.prepare_report_data(\"test-extraction\", results).await.unwrap();\n        let csv_report = generator.generate_csv_report(&report_data).await.unwrap();\n        \n        let csv_str = String::from_utf8(csv_report).unwrap();\n        assert!(csv_str.contains(\"ID,URL,Title\"));\n        assert!(csv_str.contains(\"test-1\"));\n        assert!(csv_str.contains(\"https://example.com\"));\n    }\n\n    #[test]\n    fn test_domain_stats_calculation() {\n        let generator = ReportGenerator::new();\n        let results = vec![\n            ExtractionResult {\n                id: \"1\".to_string(),\n                url: \"https://example.com/page1\".to_string(),\n                title: None,\n                content: \"\".to_string(),\n                metadata: HashMap::new(),\n                timestamp: chrono::Utc::now(),\n                extraction_time_ms: 100,\n                word_count: 10,\n                links: vec![],\n                images: vec![],\n            },\n            ExtractionResult {\n                id: \"2\".to_string(),\n                url: \"https://example.com/page2\".to_string(),\n                title: None,\n                content: \"\".to_string(),\n                metadata: HashMap::new(),\n                timestamp: chrono::Utc::now(),\n                extraction_time_ms: 200,\n                word_count: 20,\n                links: vec![],\n                images: vec![],\n            },\n        ];\n        \n        let domain_stats = generator.calculate_domain_stats(&results);\n        let example_stats = domain_stats.get(\"example.com\").unwrap();\n        \n        assert_eq!(example_stats.count, 2);\n        assert_eq!(example_stats.total_words, 30);\n        assert_eq!(example_stats.average_words, 15.0);\n        assert_eq!(example_stats.average_processing_time, 150.0);\n    }\n}\n"
