//! OpenAPI specification and tool registry for RipTide streaming endpoints\n//!\n//! This module provides OpenAPI documentation for streaming endpoints and\n//! manages a registry of available tools and integrations.\n\nuse crate::{StreamingError, StreamingResult};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse utoipa::ToSchema;\nuse uuid::Uuid;\n\n/// OpenAPI specification builder for RipTide streaming\n#[derive(Debug, Clone)]\npub struct OpenApiBuilder {\n    title: String,\n    version: String,\n    description: String,\n    servers: Vec<ServerInfo>,\n    tools: ToolRegistry,\n}\n\n/// Server information for OpenAPI spec\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ServerInfo {\n    pub url: String,\n    pub description: String,\n    pub variables: HashMap<String, ServerVariable>,\n}\n\n/// Server variable for OpenAPI spec\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ServerVariable {\n    pub default: String,\n    pub description: Option<String>,\n    pub enum_values: Option<Vec<String>>,\n}\n\n/// Tool registry for managing available integrations\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolRegistry {\n    pub tools: HashMap<String, ToolInfo>,\n    pub categories: HashMap<String, Vec<String>>,\n    pub integrations: HashMap<String, IntegrationInfo>,\n}\n\n/// Information about a tool or integration\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ToolInfo {\n    pub id: String,\n    pub name: String,\n    pub description: String,\n    pub version: String,\n    pub category: String,\n    pub endpoints: Vec<EndpointInfo>,\n    pub authentication: AuthenticationInfo,\n    pub rate_limits: Option<RateLimitInfo>,\n    pub documentation_url: Option<String>,\n    pub supported_formats: Vec<String>,\n    pub status: ToolStatus,\n}\n\n/// Tool status\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum ToolStatus {\n    Active,\n    Deprecated,\n    Beta,\n    Maintenance,\n}\n\n/// Endpoint information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct EndpointInfo {\n    pub path: String,\n    pub method: String,\n    pub summary: String,\n    pub description: String,\n    pub parameters: Vec<ParameterInfo>,\n    pub request_body: Option<RequestBodyInfo>,\n    pub responses: HashMap<String, ResponseInfo>,\n    pub tags: Vec<String>,\n    pub streaming: bool,\n}\n\n/// Parameter information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ParameterInfo {\n    pub name: String,\n    pub in_location: ParameterLocation,\n    pub description: String,\n    pub required: bool,\n    pub schema: ParameterSchema,\n}\n\n/// Parameter location\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum ParameterLocation {\n    Query,\n    Path,\n    Header,\n    Cookie,\n}\n\n/// Parameter schema\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ParameterSchema {\n    pub type_name: String,\n    pub format: Option<String>,\n    pub enum_values: Option<Vec<String>>,\n    pub default: Option<serde_json::Value>,\n    pub example: Option<serde_json::Value>,\n}\n\n/// Request body information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct RequestBodyInfo {\n    pub description: String,\n    pub required: bool,\n    pub content: HashMap<String, MediaTypeInfo>,\n}\n\n/// Media type information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct MediaTypeInfo {\n    pub schema: serde_json::Value,\n    pub example: Option<serde_json::Value>,\n    pub examples: Option<HashMap<String, ExampleInfo>>,\n}\n\n/// Example information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ExampleInfo {\n    pub summary: String,\n    pub description: Option<String>,\n    pub value: serde_json::Value,\n}\n\n/// Response information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ResponseInfo {\n    pub description: String,\n    pub content: Option<HashMap<String, MediaTypeInfo>>,\n    pub headers: Option<HashMap<String, HeaderInfo>>,\n}\n\n/// Header information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct HeaderInfo {\n    pub description: String,\n    pub required: bool,\n    pub schema: ParameterSchema,\n}\n\n/// Authentication information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationInfo {\n    pub type_name: AuthenticationType,\n    pub description: String,\n    pub configuration: serde_json::Value,\n}\n\n/// Authentication type\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum AuthenticationType {\n    None,\n    ApiKey,\n    Bearer,\n    Basic,\n    OAuth2,\n    Custom,\n}\n\n/// Rate limit information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct RateLimitInfo {\n    pub requests_per_minute: u32,\n    pub burst_size: u32,\n    pub reset_strategy: ResetStrategy,\n}\n\n/// Rate limit reset strategy\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum ResetStrategy {\n    Fixed,\n    Sliding,\n    TokenBucket,\n}\n\n/// Integration information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct IntegrationInfo {\n    pub id: String,\n    pub name: String,\n    pub description: String,\n    pub provider: String,\n    pub configuration: IntegrationConfig,\n    pub health_check: HealthCheckInfo,\n    pub metrics: Option<MetricsInfo>,\n}\n\n/// Integration configuration\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct IntegrationConfig {\n    pub base_url: String,\n    pub timeout_seconds: u64,\n    pub retry_attempts: u32,\n    pub custom_headers: HashMap<String, String>,\n    pub tls_verification: bool,\n}\n\n/// Health check information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct HealthCheckInfo {\n    pub endpoint: String,\n    pub method: String,\n    pub expected_status: u16,\n    pub timeout_seconds: u64,\n    pub interval_seconds: u64,\n}\n\n/// Metrics information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct MetricsInfo {\n    pub endpoint: String,\n    pub format: MetricsFormat,\n    pub labels: HashMap<String, String>,\n}\n\n/// Metrics format\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum MetricsFormat {\n    Prometheus,\n    Json,\n    Statsd,\n}\n\nimpl OpenApiBuilder {\n    /// Create a new OpenAPI builder\n    pub fn new() -> Self {\n        Self {\n            title: \"RipTide Streaming API\".to_string(),\n            version: \"1.0.0\".to_string(),\n            description: \"Real-time extraction results streaming and report generation API\".to_string(),\n            servers: Vec::new(),\n            tools: ToolRegistry::new(),\n        }\n    }\n\n    /// Set the API title\n    pub fn title<S: Into<String>>(mut self, title: S) -> Self {\n        self.title = title.into();\n        self\n    }\n\n    /// Set the API version\n    pub fn version<S: Into<String>>(mut self, version: S) -> Self {\n        self.version = version.into();\n        self\n    }\n\n    /// Set the API description\n    pub fn description<S: Into<String>>(mut self, description: S) -> Self {\n        self.description = description.into();\n        self\n    }\n\n    /// Add a server\n    pub fn add_server(mut self, server: ServerInfo) -> Self {\n        self.servers.push(server);\n        self\n    }\n\n    /// Add a tool to the registry\n    pub fn add_tool(mut self, tool: ToolInfo) -> Self {\n        self.tools.add_tool(tool);\n        self\n    }\n\n    /// Build the OpenAPI specification\n    pub fn build(self) -> OpenApiSpec {\n        OpenApiSpec {\n            openapi: \"3.0.3\".to_string(),\n            info: ApiInfo {\n                title: self.title,\n                version: self.version,\n                description: self.description,\n            },\n            servers: self.servers,\n            paths: self.build_paths(),\n            components: self.build_components(),\n            tools: self.tools,\n        }\n    }\n\n    /// Build the paths section\n    fn build_paths(&self) -> HashMap<String, PathItem> {\n        let mut paths = HashMap::new();\n\n        // Streaming endpoints\n        paths.insert(\"/streams\".to_string(), PathItem {\n            get: Some(self.build_list_streams_operation()),\n            post: Some(self.build_create_stream_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/streams/{stream_id}\".to_string(), PathItem {\n            get: Some(self.build_get_stream_operation()),\n            delete: Some(self.build_delete_stream_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/streams/{stream_id}/ndjson\".to_string(), PathItem {\n            get: Some(self.build_ndjson_stream_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/streams/{stream_id}/ws\".to_string(), PathItem {\n            get: Some(self.build_websocket_operation()),\n            ..Default::default()\n        });\n\n        // Report endpoints\n        paths.insert(\"/reports\".to_string(), PathItem {\n            get: Some(self.build_list_reports_operation()),\n            post: Some(self.build_generate_report_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/reports/{report_id}\".to_string(), PathItem {\n            get: Some(self.build_get_report_operation()),\n            delete: Some(self.build_delete_report_operation()),\n            ..Default::default()\n        });\n\n        // Tool registry endpoints\n        paths.insert(\"/tools\".to_string(), PathItem {\n            get: Some(self.build_list_tools_operation()),\n            post: Some(self.build_register_tool_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/tools/{tool_id}\".to_string(), PathItem {\n            get: Some(self.build_get_tool_operation()),\n            put: Some(self.build_update_tool_operation()),\n            delete: Some(self.build_unregister_tool_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/tools/{tool_id}/health\".to_string(), PathItem {\n            get: Some(self.build_tool_health_operation()),\n            ..Default::default()\n        });\n\n        paths\n    }\n\n    /// Build the components section\n    fn build_components(&self) -> ComponentsInfo {\n        ComponentsInfo {\n            schemas: self.build_schemas(),\n            security_schemes: self.build_security_schemes(),\n        }\n    }\n\n    /// Build schemas\n    fn build_schemas(&self) -> HashMap<String, serde_json::Value> {\n        let mut schemas = HashMap::new();\n        \n        // Add common schemas\n        schemas.insert(\"StreamInfo\".to_string(), serde_json::json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"id\": { \"type\": \"string\", \"format\": \"uuid\" },\n                \"extraction_id\": { \"type\": \"string\" },\n                \"start_time\": { \"type\": \"string\", \"format\": \"date-time\" },\n                \"total_items\": { \"type\": \"integer\", \"nullable\": true },\n                \"processed_items\": { \"type\": \"integer\" },\n                \"status\": { \"$ref\": \"#/components/schemas/StreamStatus\" }\n            },\n            \"required\": [\"id\", \"extraction_id\", \"start_time\", \"processed_items\", \"status\"]\n        }));\n\n        schemas.insert(\"StreamStatus\".to_string(), serde_json::json!({\n            \"type\": \"string\",\n            \"enum\": [\"Active\", \"Paused\", \"Completed\", \"Failed\"]\n        }));\n\n        schemas.insert(\"ExtractionResult\".to_string(), serde_json::json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"id\": { \"type\": \"string\" },\n                \"url\": { \"type\": \"string\", \"format\": \"uri\" },\n                \"title\": { \"type\": \"string\", \"nullable\": true },\n                \"content\": { \"type\": \"string\" },\n                \"metadata\": { \"type\": \"object\" },\n                \"timestamp\": { \"type\": \"string\", \"format\": \"date-time\" },\n                \"extraction_time_ms\": { \"type\": \"integer\" },\n                \"word_count\": { \"type\": \"integer\" },\n                \"links\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n                \"images\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }\n            },\n            \"required\": [\"id\", \"url\", \"content\", \"metadata\", \"timestamp\", \"extraction_time_ms\", \"word_count\", \"links\", \"images\"]\n        }));\n\n        schemas.insert(\"ReportRequest\".to_string(), serde_json::json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"extraction_id\": { \"type\": \"string\" },\n                \"format\": { \"type\": \"string\", \"enum\": [\"html\", \"json\", \"csv\", \"pdf\"] },\n                \"config\": { \"$ref\": \"#/components/schemas/ReportConfig\" }\n            },\n            \"required\": [\"extraction_id\", \"format\"]\n        }));\n\n        schemas.insert(\"ToolInfo\".to_string(), serde_json::json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"id\": { \"type\": \"string\" },\n                \"name\": { \"type\": \"string\" },\n                \"description\": { \"type\": \"string\" },\n                \"version\": { \"type\": \"string\" },\n                \"category\": { \"type\": \"string\" },\n                \"status\": { \"type\": \"string\", \"enum\": [\"Active\", \"Deprecated\", \"Beta\", \"Maintenance\"] }\n            },\n            \"required\": [\"id\", \"name\", \"description\", \"version\", \"category\", \"status\"]\n        }));\n\n        schemas\n    }\n\n    /// Build security schemes\n    fn build_security_schemes(&self) -> HashMap<String, serde_json::Value> {\n        let mut schemes = HashMap::new();\n\n        schemes.insert(\"ApiKeyAuth\".to_string(), serde_json::json!({\n            \"type\": \"apiKey\",\n            \"in\": \"header\",\n            \"name\": \"X-API-Key\"\n        }));\n\n        schemes.insert(\"BearerAuth\".to_string(), serde_json::json!({\n            \"type\": \"http\",\n            \"scheme\": \"bearer\",\n            \"bearerFormat\": \"JWT\"\n        }));\n\n        schemes\n    }\n\n    // Operation builders (simplified for brevity)\n    fn build_list_streams_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"List active streams\".to_string(),\n            description: \"Get a list of all active extraction streams\".to_string(),\n            tags: vec![\"Streaming\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_create_stream_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"Create new stream\".to_string(),\n            description: \"Start a new extraction stream\".to_string(),\n            tags: vec![\"Streaming\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_ndjson_stream_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"NDJSON stream\".to_string(),\n            description: \"Stream extraction results in NDJSON format\".to_string(),\n            tags: vec![\"Streaming\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_websocket_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"WebSocket stream\".to_string(),\n            description: \"Stream extraction results via WebSocket\".to_string(),\n            tags: vec![\"Streaming\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_generate_report_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"Generate report\".to_string(),\n            description: \"Generate a report for extraction results\".to_string(),\n            tags: vec![\"Reports\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_list_tools_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"List tools\".to_string(),\n            description: \"Get a list of all registered tools\".to_string(),\n            tags: vec![\"Tools\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_register_tool_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"Register tool\".to_string(),\n            description: \"Register a new tool or integration\".to_string(),\n            tags: vec![\"Tools\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    // Placeholder implementations for other operations\n    fn build_get_stream_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_delete_stream_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_list_reports_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_get_report_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_delete_report_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_get_tool_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_update_tool_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_unregister_tool_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_tool_health_operation(&self) -> OperationInfo { OperationInfo::default() }\n}\n\nimpl Default for OpenApiBuilder {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Complete OpenAPI specification\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OpenApiSpec {\n    pub openapi: String,\n    pub info: ApiInfo,\n    pub servers: Vec<ServerInfo>,\n    pub paths: HashMap<String, PathItem>,\n    pub components: ComponentsInfo,\n    pub tools: ToolRegistry,\n}\n\n/// API information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ApiInfo {\n    pub title: String,\n    pub version: String,\n    pub description: String,\n}\n\n/// Path item information\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct PathItem {\n    pub get: Option<OperationInfo>,\n    pub post: Option<OperationInfo>,\n    pub put: Option<OperationInfo>,\n    pub delete: Option<OperationInfo>,\n    pub patch: Option<OperationInfo>,\n}\n\n/// Operation information\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct OperationInfo {\n    pub summary: String,\n    pub description: String,\n    pub tags: Vec<String>,\n    pub parameters: Vec<ParameterInfo>,\n    pub responses: HashMap<String, ResponseInfo>,\n}\n\n/// Components information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ComponentsInfo {\n    pub schemas: HashMap<String, serde_json::Value>,\n    pub security_schemes: HashMap<String, serde_json::Value>,\n}\n\nimpl ToolRegistry {\n    /// Create a new tool registry\n    pub fn new() -> Self {\n        Self {\n            tools: HashMap::new(),\n            categories: HashMap::new(),\n            integrations: HashMap::new(),\n        }\n    }\n\n    /// Add a tool to the registry\n    pub fn add_tool(&mut self, tool: ToolInfo) {\n        // Add to category\n        self.categories\n            .entry(tool.category.clone())\n            .or_insert_with(Vec::new)\n            .push(tool.id.clone());\n        \n        self.tools.insert(tool.id.clone(), tool);\n    }\n\n    /// Remove a tool from the registry\n    pub fn remove_tool(&mut self, tool_id: &str) -> Option<ToolInfo> {\n        if let Some(tool) = self.tools.remove(tool_id) {\n            // Remove from category\n            if let Some(category_tools) = self.categories.get_mut(&tool.category) {\n                category_tools.retain(|id| id != tool_id);\n                if category_tools.is_empty() {\n                    self.categories.remove(&tool.category);\n                }\n            }\n            Some(tool)\n        } else {\n            None\n        }\n    }\n\n    /// Get a tool by ID\n    pub fn get_tool(&self, tool_id: &str) -> Option<&ToolInfo> {\n        self.tools.get(tool_id)\n    }\n\n    /// Get tools by category\n    pub fn get_tools_by_category(&self, category: &str) -> Vec<&ToolInfo> {\n        self.categories\n            .get(category)\n            .map(|tool_ids| {\n                tool_ids\n                    .iter()\n                    .filter_map(|id| self.tools.get(id))\n                    .collect()\n            })\n            .unwrap_or_default()\n    }\n\n    /// List all tools\n    pub fn list_tools(&self) -> Vec<&ToolInfo> {\n        self.tools.values().collect()\n    }\n\n    /// List all categories\n    pub fn list_categories(&self) -> Vec<&String> {\n        self.categories.keys().collect()\n    }\n\n    /// Add an integration\n    pub fn add_integration(&mut self, integration: IntegrationInfo) {\n        self.integrations.insert(integration.id.clone(), integration);\n    }\n\n    /// Get an integration\n    pub fn get_integration(&self, integration_id: &str) -> Option<&IntegrationInfo> {\n        self.integrations.get(integration_id)\n    }\n\n    /// Export as Postman collection\n    pub fn export_postman_collection(&self) -> PostmanCollection {\n        PostmanCollection {\n            info: PostmanInfo {\n                name: \"RipTide Streaming API\".to_string(),\n                description: \"Collection for RipTide streaming and reporting API\".to_string(),\n                schema: \"https://schema.getpostman.com/json/collection/v2.1.0/collection.json\".to_string(),\n            },\n            items: self.build_postman_items(),\n            variables: vec![],\n        }\n    }\n\n    /// Build Postman collection items\n    fn build_postman_items(&self) -> Vec<PostmanItem> {\n        let mut items = Vec::new();\n\n        // Add streaming endpoints\n        items.push(PostmanItem {\n            name: \"Streaming\".to_string(),\n            description: \"Streaming endpoints\".to_string(),\n            items: vec![\n                PostmanRequest {\n                    name: \"List Streams\".to_string(),\n                    request: PostmanRequestInfo {\n                        method: \"GET\".to_string(),\n                        url: \"{{base_url}}/streams\".to_string(),\n                        headers: vec![],\n                        body: None,\n                    },\n                },\n                PostmanRequest {\n                    name: \"Create Stream\".to_string(),\n                    request: PostmanRequestInfo {\n                        method: \"POST\".to_string(),\n                        url: \"{{base_url}}/streams\".to_string(),\n                        headers: vec![],\n                        body: Some(PostmanBody {\n                            mode: \"raw\".to_string(),\n                            raw: r#\"{\n  \"extraction_id\": \"example-extraction\",\n  \"config\": {\n    \"buffer_size\": 1000,\n    \"include_progress\": true\n  }\n}\"#.to_string(),\n                        }),\n                    },\n                },\n            ],\n        });\n\n        // Add report endpoints\n        items.push(PostmanItem {\n            name: \"Reports\".to_string(),\n            description: \"Report generation endpoints\".to_string(),\n            items: vec![\n                PostmanRequest {\n                    name: \"Generate Report\".to_string(),\n                    request: PostmanRequestInfo {\n                        method: \"POST\".to_string(),\n                        url: \"{{base_url}}/reports\".to_string(),\n                        headers: vec![],\n                        body: Some(PostmanBody {\n                            mode: \"raw\".to_string(),\n                            raw: r#\"{\n  \"extraction_id\": \"example-extraction\",\n  \"format\": \"html\",\n  \"config\": {\n    \"include_charts\": true,\n    \"theme\": \"modern\"\n  }\n}\"#.to_string(),\n                        }),\n                    },\n                },\n            ],\n        });\n\n        items\n    }\n}\n\nimpl Default for ToolRegistry {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Postman collection structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanCollection {\n    pub info: PostmanInfo,\n    pub items: Vec<PostmanItem>,\n    pub variables: Vec<PostmanVariable>,\n}\n\n/// Postman collection info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanInfo {\n    pub name: String,\n    pub description: String,\n    pub schema: String,\n}\n\n/// Postman collection item\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanItem {\n    pub name: String,\n    pub description: String,\n    pub items: Vec<PostmanRequest>,\n}\n\n/// Postman request\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanRequest {\n    pub name: String,\n    pub request: PostmanRequestInfo,\n}\n\n/// Postman request info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanRequestInfo {\n    pub method: String,\n    pub url: String,\n    pub headers: Vec<PostmanHeader>,\n    pub body: Option<PostmanBody>,\n}\n\n/// Postman header\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanHeader {\n    pub key: String,\n    pub value: String,\n}\n\n/// Postman body\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanBody {\n    pub mode: String,\n    pub raw: String,\n}\n\n/// Postman variable\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanVariable {\n    pub key: String,\n    pub value: String,\n    pub description: String,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_openapi_builder() {\n        let spec = OpenApiBuilder::new()\n            .title(\"Test API\")\n            .version(\"2.0.0\")\n            .description(\"Test description\")\n            .build();\n        \n        assert_eq!(spec.info.title, \"Test API\");\n        assert_eq!(spec.info.version, \"2.0.0\");\n        assert_eq!(spec.info.description, \"Test description\");\n        assert!(!spec.paths.is_empty());\n    }\n\n    #[test]\n    fn test_tool_registry() {\n        let mut registry = ToolRegistry::new();\n        \n        let tool = ToolInfo {\n            id: \"test-tool\".to_string(),\n            name: \"Test Tool\".to_string(),\n            description: \"A test tool\".to_string(),\n            version: \"1.0.0\".to_string(),\n            category: \"testing\".to_string(),\n            endpoints: vec![],\n            authentication: AuthenticationInfo {\n                type_name: AuthenticationType::None,\n                description: \"No authentication\".to_string(),\n                configuration: serde_json::json!({}),\n            },\n            rate_limits: None,\n            documentation_url: None,\n            supported_formats: vec![\"json\".to_string()],\n            status: ToolStatus::Active,\n        };\n        \n        registry.add_tool(tool);\n        \n        assert_eq!(registry.tools.len(), 1);\n        assert!(registry.get_tool(\"test-tool\").is_some());\n        assert_eq!(registry.get_tools_by_category(\"testing\").len(), 1);\n    }\n\n    #[test]\n    fn test_postman_export() {\n        let registry = ToolRegistry::new();\n        let collection = registry.export_postman_collection();\n        \n        assert_eq!(collection.info.name, \"RipTide Streaming API\");\n        assert!(!collection.items.is_empty());\n    }\n\n    #[test]\n    fn test_tool_removal() {\n        let mut registry = ToolRegistry::new();\n        \n        let tool = ToolInfo {\n            id: \"test-tool\".to_string(),\n            name: \"Test Tool\".to_string(),\n            description: \"A test tool\".to_string(),\n            version: \"1.0.0\".to_string(),\n            category: \"testing\".to_string(),\n            endpoints: vec![],\n            authentication: AuthenticationInfo {\n                type_name: AuthenticationType::None,\n                description: \"No authentication\".to_string(),\n                configuration: serde_json::json!({}),\n            },\n            rate_limits: None,\n            documentation_url: None,\n            supported_formats: vec![\"json\".to_string()],\n            status: ToolStatus::Active,\n        };\n        \n        registry.add_tool(tool);\n        assert_eq!(registry.tools.len(), 1);\n        \n        let removed = registry.remove_tool(\"test-tool\");\n        assert!(removed.is_some());\n        assert_eq!(registry.tools.len(), 0);\n        assert!(registry.categories.is_empty());\n    }\n}\n"
