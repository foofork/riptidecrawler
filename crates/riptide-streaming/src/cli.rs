//! RipTide CLI tool for streaming extraction and report generation\n//!\n//! This is the main CLI binary for RipTide streaming operations,\n//! providing commands for extraction, streaming, and report generation.\n\nuse anyhow::{Context, Result};\nuse clap::{Parser, Subcommand, ValueEnum};\nuse colored::*;\nuse indicatif::{ProgressBar, ProgressStyle};\nuse riptide_streaming::{\n    config::{ConfigManager, RiptideConfig},\n    ndjson::{NdjsonStreamBuilder, to_bytes_stream},\n    reports::{ReportGenerator, ReportFormat, ReportConfig},\n    BackpressureController, StreamingCoordinator, ExtractionResult,\n};\nuse std::collections::HashMap;\nuse std::io::{self, Write};\nuse std::path::PathBuf;\nuse std::time::Duration;\nuse tokio::time::timeout;\nuse tokio_stream::StreamExt;\nuse url::Url;\n\n/// RipTide CLI - Real-time extraction streaming and reporting\n#[derive(Parser)]\n#[command(name = \"riptide-cli\")]\n#[command(about = \"A CLI for RipTide streaming extraction and reporting\")]\n#[command(version = \"1.0.0\")]\nstruct Cli {\n    /// Global configuration file\n    #[arg(short, long, global = true)]\n    config: Option<PathBuf>,\n    \n    /// Verbose output\n    #[arg(short, long, global = true)]\n    verbose: bool,\n    \n    /// Quiet mode (minimal output)\n    #[arg(short, long, global = true)]\n    quiet: bool,\n    \n    /// Disable colored output\n    #[arg(long, global = true)]\n    no_color: bool,\n    \n    /// Output format\n    #[arg(short, long, global = true, value_enum, default_value = \"json\")]\n    format: OutputFormat,\n    \n    #[command(subcommand)]\n    command: Commands,\n}\n\n/// Output format for CLI commands\n#[derive(Clone, ValueEnum)]\nenum OutputFormat {\n    Json,\n    Table,\n    Yaml,\n    Csv,\n}\n\n/// Available CLI commands\n#[derive(Subcommand)]\nenum Commands {\n    /// Extract content from URLs\n    Extract {\n        /// URLs to extract from\n        urls: Vec<String>,\n        \n        /// Output file (default: stdout)\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n        \n        /// Enable streaming mode\n        #[arg(short, long)]\n        stream: bool,\n        \n        /// Maximum concurrent extractions\n        #[arg(short, long, default_value = \"5\")]\n        concurrency: usize,\n        \n        /// Timeout per extraction (seconds)\n        #[arg(short, long, default_value = \"30\")]\n        timeout: u64,\n    },\n    \n    /// Stream extraction results in real-time\n    Stream {\n        /// Extraction ID to stream\n        extraction_id: String,\n        \n        /// Output format\n        #[arg(short, long, value_enum, default_value = \"ndjson\")]\n        format: StreamFormat,\n        \n        /// Follow mode (keep streaming)\n        #[arg(short, long)]\n        follow: bool,\n        \n        /// Buffer size for streaming\n        #[arg(short, long, default_value = \"1000\")]\n        buffer_size: usize,\n    },\n    \n    /// Generate reports from extraction results\n    Report {\n        /// Extraction ID to generate report for\n        extraction_id: String,\n        \n        /// Report format\n        #[arg(short, long, value_enum, default_value = \"html\")]\n        format: ReportOutputFormat,\n        \n        /// Output file\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n        \n        /// Report template (optional)\n        #[arg(short, long)]\n        template: Option<PathBuf>,\n        \n        /// Include charts and visualizations\n        #[arg(long)]\n        charts: bool,\n        \n        /// Include raw data in report\n        #[arg(long)]\n        raw_data: bool,\n    },\n    \n    /// Configuration management\n    Config {\n        #[command(subcommand)]\n        action: ConfigAction,\n    },\n    \n    /// Server management\n    Server {\n        #[command(subcommand)]\n        action: ServerAction,\n    },\n    \n    /// Tool and integration management\n    Tools {\n        #[command(subcommand)]\n        action: ToolAction,\n    },\n}\n\n/// Stream output formats\n#[derive(Clone, ValueEnum)]\nenum StreamFormat {\n    Ndjson,\n    Json,\n    Raw,\n}\n\n/// Report output formats\n#[derive(Clone, ValueEnum)]\nenum ReportOutputFormat {\n    Html,\n    Json,\n    Csv,\n    Pdf,\n}\n\n/// Configuration actions\n#[derive(Subcommand)]\nenum ConfigAction {\n    /// Show current configuration\n    Show,\n    \n    /// Edit configuration\n    Edit,\n    \n    /// Set a configuration value\n    Set {\n        /// Configuration key\n        key: String,\n        /// Configuration value\n        value: String,\n    },\n    \n    /// Get a configuration value\n    Get {\n        /// Configuration key\n        key: String,\n    },\n    \n    /// Reset to default configuration\n    Reset,\n    \n    /// Validate configuration\n    Validate,\n}\n\n/// Server actions\n#[derive(Subcommand)]\nenum ServerAction {\n    /// Start the streaming server\n    Start {\n        /// Host to bind to\n        #[arg(long, default_value = \"localhost\")]\n        host: String,\n        \n        /// Port to bind to\n        #[arg(long, default_value = \"8080\")]\n        port: u16,\n        \n        /// Run in daemon mode\n        #[arg(short, long)]\n        daemon: bool,\n    },\n    \n    /// Stop the streaming server\n    Stop,\n    \n    /// Show server status\n    Status,\n    \n    /// Show server logs\n    Logs {\n        /// Follow logs\n        #[arg(short, long)]\n        follow: bool,\n        \n        /// Number of lines to show\n        #[arg(short, long, default_value = \"100\")]\n        lines: usize,\n    },\n}\n\n/// Tool actions\n#[derive(Subcommand)]\nenum ToolAction {\n    /// List available tools\n    List {\n        /// Filter by category\n        #[arg(short, long)]\n        category: Option<String>,\n    },\n    \n    /// Show tool information\n    Info {\n        /// Tool ID\n        tool_id: String,\n    },\n    \n    /// Register a new tool\n    Register {\n        /// Tool definition file\n        file: PathBuf,\n    },\n    \n    /// Unregister a tool\n    Unregister {\n        /// Tool ID\n        tool_id: String,\n    },\n    \n    /// Test tool health\n    Health {\n        /// Tool ID\n        tool_id: String,\n    },\n    \n    /// Export tools as Postman collection\n    Export {\n        /// Output file\n        #[arg(short, long)]\n        output: PathBuf,\n    },\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let cli = Cli::parse();\n    \n    // Initialize logging\n    init_logging(cli.verbose, cli.quiet)?;\n    \n    // Load configuration\n    let mut config_manager = if let Some(config_file) = &cli.config {\n        ConfigManager::load_from_file(config_file)\n            .with_context(|| format!(\"Failed to load config from {}\", config_file.display()))?\n    } else {\n        ConfigManager::load().unwrap_or_else(|_| {\n            eprintln!(\"{}\", \"Warning: Using default configuration\".yellow());\n            ConfigManager::new().expect(\"Failed to create default config\")\n        })\n    };\n    \n    // Set global options\n    if cli.no_color {\n        colored::control::set_override(false);\n    }\n    \n    // Execute command\n    match cli.command {\n        Commands::Extract { urls, output, stream, concurrency, timeout } => {\n            handle_extract(urls, output, stream, concurrency, timeout, &cli, &config_manager).await\n        }\n        Commands::Stream { extraction_id, format, follow, buffer_size } => {\n            handle_stream(extraction_id, format, follow, buffer_size, &cli).await\n        }\n        Commands::Report { extraction_id, format, output, template, charts, raw_data } => {\n            handle_report(extraction_id, format, output, template, charts, raw_data, &cli).await\n        }\n        Commands::Config { action } => {\n            handle_config(action, &mut config_manager, &cli).await\n        }\n        Commands::Server { action } => {\n            handle_server(action, &config_manager, &cli).await\n        }\n        Commands::Tools { action } => {\n            handle_tools(action, &config_manager, &cli).await\n        }\n    }\n}\n\n/// Initialize logging based on verbosity\nfn init_logging(verbose: bool, quiet: bool) -> Result<()> {\n    use tracing_subscriber::{EnvFilter, fmt::format::FmtSpan};\n    \n    let filter = if quiet {\n        EnvFilter::new(\"error\")\n    } else if verbose {\n        EnvFilter::new(\"debug\")\n    } else {\n        EnvFilter::new(\"info\")\n    };\n    \n    tracing_subscriber::fmt()\n        .with_env_filter(filter)\n        .with_span_events(FmtSpan::CLOSE)\n        .with_target(verbose)\n        .init();\n    \n    Ok(())\n}\n\n/// Handle extract command\nasync fn handle_extract(\n    urls: Vec<String>,\n    output: Option<PathBuf>,\n    stream: bool,\n    concurrency: usize,\n    timeout_secs: u64,\n    cli: &Cli,\n    config: &ConfigManager,\n) -> Result<()> {\n    if urls.is_empty() {\n        eprintln!(\"{}\", \"Error: No URLs provided\".red());\n        return Ok(());\n    }\n    \n    // Validate URLs\n    let mut valid_urls = Vec::new();\n    for url_str in urls {\n        match Url::parse(&url_str) {\n            Ok(url) => valid_urls.push(url),\n            Err(e) => {\n                eprintln!(\"{}: {}\", \"Warning: Invalid URL\".yellow(), url_str);\n                if cli.verbose {\n                    eprintln!(\"  Error: {}\", e);\n                }\n            }\n        }\n    }\n    \n    if valid_urls.is_empty() {\n        eprintln!(\"{}\", \"Error: No valid URLs to process\".red());\n        return Ok(());\n    }\n    \n    println!(\"{} {} URLs\", \"Extracting from\".green(), valid_urls.len());\n    \n    // Setup progress bar\n    let progress = if !cli.quiet {\n        let pb = ProgressBar::new(valid_urls.len() as u64);\n        pb.set_style(ProgressStyle::default_bar()\n            .template(\"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} {msg}\")\n            .unwrap()\n            .progress_chars(\"#>-\"));\n        Some(pb)\n    } else {\n        None\n    };\n    \n    // Create output writer\n    let mut output_writer: Box<dyn Write> = if let Some(path) = output {\n        Box::new(std::fs::File::create(path)?)\n    } else {\n        Box::new(io::stdout())\n    };\n    \n    // Setup streaming coordinator if in stream mode\n    if stream {\n        let mut coordinator = StreamingCoordinator::new();\n        let extraction_id = uuid::Uuid::new_v4().to_string();\n        let stream_id = coordinator.start_stream(extraction_id.clone()).await?;\n        \n        // Create NDJSON stream\n        let ndjson_stream = NdjsonStreamBuilder::new()\n            .buffer_size(1000)\n            .include_progress(true)\n            .build(stream_id, extraction_id);\n        \n        ndjson_stream.start().await?;\n        \n        // Process URLs with streaming\n        for (i, url) in valid_urls.iter().enumerate() {\n            if let Some(pb) = &progress {\n                pb.set_message(format!(\"Processing {}\", url));\n            }\n            \n            // Simulate extraction (in real implementation, this would call riptide-core)\n            let result = simulate_extraction(url, timeout_secs).await?;\n            \n            // Send result to stream\n            ndjson_stream.send_result(result).await?;\n            \n            if let Some(pb) = &progress {\n                pb.inc(1);\n            }\n            \n            // Update coordinator progress\n            coordinator.update_progress(stream_id, i + 1, Some(valid_urls.len())).await?;\n        }\n        \n        // End stream\n        ndjson_stream.end().await?;\n        coordinator.complete_stream(stream_id).await?;\n        \n        // Convert stream to bytes and write to output\n        let bytes_stream = to_bytes_stream(ndjson_stream);\n        tokio::pin!(bytes_stream);\n        \n        while let Some(bytes_result) = bytes_stream.next().await {\n            let bytes = bytes_result?;\n            output_writer.write_all(&bytes)?;\n        }\n    } else {\n        // Batch processing without streaming\n        let mut results = Vec::new();\n        \n        for (i, url) in valid_urls.iter().enumerate() {\n            if let Some(pb) = &progress {\n                pb.set_message(format!(\"Processing {}\", url));\n            }\n            \n            let result = simulate_extraction(url, timeout_secs).await?;\n            results.push(result);\n            \n            if let Some(pb) = &progress {\n                pb.inc(1);\n            }\n        }\n        \n        // Output results based on format\n        match cli.format {\n            OutputFormat::Json => {\n                let json = serde_json::to_string_pretty(&results)?;\n                writeln!(output_writer, \"{}\", json)?;\n            }\n            OutputFormat::Table => {\n                // Simple table output\n                writeln!(output_writer, \"{:<10} {:<50} {:<20} {:<10}\", \"ID\", \"URL\", \"Title\", \"Words\")?;\n                writeln!(output_writer, \"{}\", \"-\".repeat(90))?;\n                for result in results {\n                    writeln!(output_writer, \"{:<10} {:<50} {:<20} {:<10}\", \n                        &result.id[..8],\n                        truncate_string(&result.url, 47),\n                        result.title.as_deref().unwrap_or(\"N/A\"),\n                        result.word_count\n                    )?;\n                }\n            }\n            OutputFormat::Yaml => {\n                let yaml = serde_yaml::to_string(&results)?;\n                write!(output_writer, \"{}\", yaml)?;\n            }\n            OutputFormat::Csv => {\n                writeln!(output_writer, \"id,url,title,content,word_count,extraction_time_ms\")?;\n                for result in results {\n                    writeln!(output_writer, \"{},{},{},{},{},{}\",\n                        result.id,\n                        result.url,\n                        result.title.as_deref().unwrap_or(\"\"),\n                        result.content.replace(',', \";\"),\n                        result.word_count,\n                        result.extraction_time_ms\n                    )?;\n                }\n            }\n        }\n    }\n    \n    if let Some(pb) = progress {\n        pb.finish_with_message(\"Extraction completed\");\n    }\n    \n    println!(\"{} extraction\", \"Completed\".green().bold());\n    Ok(())\n}\n\n/// Handle stream command\nasync fn handle_stream(\n    extraction_id: String,\n    format: StreamFormat,\n    follow: bool,\n    buffer_size: usize,\n    cli: &Cli,\n) -> Result<()> {\n    println!(\"{} stream for extraction: {}\", \"Starting\".green(), extraction_id);\n    \n    // This would connect to the actual streaming endpoint\n    // For now, simulate streaming\n    \n    let timeout_duration = if follow {\n        Duration::from_secs(3600) // 1 hour for follow mode\n    } else {\n        Duration::from_secs(30)\n    };\n    \n    match timeout(timeout_duration, simulate_stream(&extraction_id, format, buffer_size)).await {\n        Ok(result) => result,\n        Err(_) => {\n            eprintln!(\"{}\", \"Stream timeout\".yellow());\n            Ok(())\n        }\n    }\n}\n\n/// Handle report command\nasync fn handle_report(\n    extraction_id: String,\n    format: ReportOutputFormat,\n    output: Option<PathBuf>,\n    _template: Option<PathBuf>,\n    charts: bool,\n    raw_data: bool,\n    cli: &Cli,\n) -> Result<()> {\n    println!(\"{} report for extraction: {}\", \"Generating\".green(), extraction_id);\n    \n    let report_format = match format {\n        ReportOutputFormat::Html => ReportFormat::Html,\n        ReportOutputFormat::Json => ReportFormat::Json,\n        ReportOutputFormat::Csv => ReportFormat::Csv,\n        ReportOutputFormat::Pdf => ReportFormat::Pdf,\n    };\n    \n    let config = ReportConfig {\n        title: format!(\"RipTide Report - {}\", extraction_id),\n        include_charts: charts,\n        include_raw_data: raw_data,\n        include_metadata: true,\n        chart_width: 800,\n        chart_height: 400,\n        theme: riptide_streaming::reports::ReportTheme::Modern,\n    };\n    \n    let generator = ReportGenerator::with_config(config);\n    let report_data = generator.generate_report(&extraction_id, report_format).await?;\n    \n    // Write report to file or stdout\n    if let Some(output_path) = output {\n        std::fs::write(&output_path, report_data)?;\n        println!(\"{} report saved to: {}\", \"Successfully\".green(), output_path.display());\n    } else {\n        io::stdout().write_all(&report_data)?;\n    }\n    \n    Ok(())\n}\n\n/// Handle config command\nasync fn handle_config(\n    action: ConfigAction,\n    config_manager: &mut ConfigManager,\n    cli: &Cli,\n) -> Result<()> {\n    match action {\n        ConfigAction::Show => {\n            if cli.format == OutputFormat::Json {\n                let json = serde_json::to_string_pretty(config_manager.config())?;\n                println!(\"{}\", json);\n            } else {\n                println!(\"{}\", config_manager.summary());\n            }\n        }\n        ConfigAction::Edit => {\n            println!(\"{}\", \"Opening configuration for editing...\".green());\n            // This would open the config file in an editor\n            println!(\"{}\", \"Note: Edit functionality not yet implemented\".yellow());\n        }\n        ConfigAction::Set { key, value } => {\n            println!(\"{} {} = {}\", \"Setting\".green(), key, value);\n            // This would set the configuration value\n            println!(\"{}\", \"Note: Set functionality not yet implemented\".yellow());\n        }\n        ConfigAction::Get { key } => {\n            println!(\"{} {}\", \"Getting\".green(), key);\n            // This would get the configuration value\n            println!(\"{}\", \"Note: Get functionality not yet implemented\".yellow());\n        }\n        ConfigAction::Reset => {\n            config_manager.reset_to_defaults()?;\n            config_manager.save()?;\n            println!(\"{}\", \"Configuration reset to defaults\".green());\n        }\n        ConfigAction::Validate => {\n            match config_manager.validate() {\n                Ok(()) => println!(\"{}\", \"Configuration is valid\".green()),\n                Err(e) => {\n                    eprintln!(\"{}: {}\", \"Configuration validation failed\".red(), e);\n                    return Err(e);\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Handle server command\nasync fn handle_server(\n    action: ServerAction,\n    config: &ConfigManager,\n    _cli: &Cli,\n) -> Result<()> {\n    match action {\n        ServerAction::Start { host, port, daemon } => {\n            println!(\"{} server on {}:{}\", \"Starting\".green(), host, port);\n            if daemon {\n                println!(\"{}\", \"Note: Daemon mode not yet implemented\".yellow());\n            }\n            // This would start the actual server\n            println!(\"{}\", \"Note: Server functionality not yet implemented\".yellow());\n        }\n        ServerAction::Stop => {\n            println!(\"{}\", \"Stopping server...\".yellow());\n            println!(\"{}\", \"Note: Server functionality not yet implemented\".yellow());\n        }\n        ServerAction::Status => {\n            println!(\"{}\", \"Checking server status...\".blue());\n            println!(\"{}\", \"Note: Server functionality not yet implemented\".yellow());\n        }\n        ServerAction::Logs { follow, lines } => {\n            println!(\"{} {} lines of logs\", \"Showing\".blue(), lines);\n            if follow {\n                println!(\"{}\", \"Following logs...\".blue());\n            }\n            println!(\"{}\", \"Note: Server functionality not yet implemented\".yellow());\n        }\n    }\n    Ok(())\n}\n\n/// Handle tools command\nasync fn handle_tools(\n    action: ToolAction,\n    _config: &ConfigManager,\n    cli: &Cli,\n) -> Result<()> {\n    match action {\n        ToolAction::List { category } => {\n            println!(\"{} tools\", \"Listing\".green());\n            if let Some(cat) = category {\n                println!(\"Category: {}\", cat);\n            }\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Info { tool_id } => {\n            println!(\"{} tool: {}\", \"Showing info for\".green(), tool_id);\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Register { file } => {\n            println!(\"{} tool from: {}\", \"Registering\".green(), file.display());\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Unregister { tool_id } => {\n            println!(\"{} tool: {}\", \"Unregistering\".yellow(), tool_id);\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Health { tool_id } => {\n            println!(\"{} health for tool: {}\", \"Checking\".blue(), tool_id);\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Export { output } => {\n            println!(\"{} Postman collection to: {}\", \"Exporting\".green(), output.display());\n            \n            // Create a sample Postman collection\n            let registry = riptide_streaming::openapi::ToolRegistry::new();\n            let collection = registry.export_postman_collection();\n            \n            let json = serde_json::to_string_pretty(&collection)?;\n            std::fs::write(&output, json)?;\n            \n            println!(\"{} exported Postman collection\", \"Successfully\".green());\n        }\n    }\n    Ok(())\n}\n\n/// Simulate extraction for demonstration\nasync fn simulate_extraction(url: &Url, timeout_secs: u64) -> Result<ExtractionResult> {\n    // Simulate processing time\n    let processing_time = rand::random::<u64>() % (timeout_secs * 100) + 50;\n    tokio::time::sleep(Duration::from_millis(processing_time)).await;\n    \n    let content = format!(\"Sample content extracted from {}\", url);\n    let word_count = content.split_whitespace().count();\n    \n    Ok(ExtractionResult {\n        id: uuid::Uuid::new_v4().to_string(),\n        url: url.to_string(),\n        title: Some(format!(\"Page Title for {}\", url.host_str().unwrap_or(\"unknown\"))),\n        content,\n        metadata: HashMap::new(),\n        timestamp: chrono::Utc::now(),\n        extraction_time_ms: processing_time,\n        word_count,\n        links: vec![],\n        images: vec![],\n    })\n}\n\n/// Simulate streaming for demonstration\nasync fn simulate_stream(\n    extraction_id: &str,\n    format: StreamFormat,\n    _buffer_size: usize,\n) -> Result<()> {\n    println!(\"Streaming extraction: {} (format: {:?})\", extraction_id, format);\n    \n    // Simulate streaming data\n    for i in 1..=10 {\n        let item = serde_json::json!({\n            \"type\": \"extraction_result\",\n            \"id\": format!(\"result-{}\", i),\n            \"url\": format!(\"https://example.com/page{}\", i),\n            \"title\": format!(\"Page {}\", i),\n            \"content\": format!(\"Content from page {}\", i),\n            \"timestamp\": chrono::Utc::now()\n        });\n        \n        match format {\n            StreamFormat::Ndjson => {\n                println!(\"{}\", serde_json::to_string(&item)?);\n            }\n            StreamFormat::Json => {\n                println!(\"{}\", serde_json::to_string_pretty(&item)?);\n            }\n            StreamFormat::Raw => {\n                println!(\"[{}] {}: {}\", \n                    chrono::Utc::now().format(\"%H:%M:%S\"),\n                    item[\"id\"],\n                    item[\"url\"]\n                );\n            }\n        }\n        \n        tokio::time::sleep(Duration::from_millis(500)).await;\n    }\n    \n    Ok(())\n}\n\n/// Truncate string to specified length\nfn truncate_string(s: &str, max_len: usize) -> String {\n    if s.len() <= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", &s[..max_len.saturating_sub(3)])\n    }\n}\n\nuse rand; // Add this for the random simulation\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_truncate_string() {\n        assert_eq!(truncate_string(\"short\", 10), \"short\");\n        assert_eq!(truncate_string(\"very long string that should be truncated\", 10), \"very lo...\");\n    }\n    \n    #[tokio::test]\n    async fn test_simulate_extraction() {\n        let url = Url::parse(\"https://example.com\").unwrap();\n        let result = simulate_extraction(&url, 5).await.unwrap();\n        \n        assert_eq!(result.url, \"https://example.com/\");\n        assert!(result.content.contains(\"example.com\"));\n        assert!(result.word_count > 0);\n    }\n}\n"