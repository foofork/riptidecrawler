//! Backpressure handling for streaming operations\n//!\n//! This module provides sophisticated backpressure control to prevent memory\n//! exhaustion and ensure smooth streaming performance under varying load conditions.\n\nuse crate::{StreamingError, StreamingResult};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{Semaphore, RwLock, mpsc};\nuse uuid::Uuid;\nuse serde::{Deserialize, Serialize};\nuse tokio::time::interval;\n\n/// Backpressure control configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BackpressureConfig {\n    /// Maximum number of items in flight per stream\n    pub max_in_flight: usize,\n    /// Maximum memory usage in bytes\n    pub max_memory_bytes: u64,\n    /// Maximum total items across all streams\n    pub max_total_items: usize,\n    /// Backpressure activation threshold (0.0 - 1.0)\n    pub activation_threshold: f64,\n    /// Recovery threshold (0.0 - 1.0)\n    pub recovery_threshold: f64,\n    /// Check interval for resource monitoring\n    pub check_interval: Duration,\n    /// Enable adaptive backpressure\n    pub adaptive: bool,\n}\n\nimpl Default for BackpressureConfig {\n    fn default() -> Self {\n        Self {\n            max_in_flight: 1000,\n            max_memory_bytes: 100 * 1024 * 1024, // 100 MB\n            max_total_items: 10000,\n            activation_threshold: 0.8,\n            recovery_threshold: 0.6,\n            check_interval: Duration::from_millis(500),\n            adaptive: true,\n        }\n    }\n}\n\n/// Backpressure status\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum BackpressureStatus {\n    Normal,\n    Warning,\n    Critical,\n    Throttled,\n}\n\n/// Stream resource usage\n#[derive(Debug, Clone)]\nstruct StreamResources {\n    in_flight_items: usize,\n    memory_usage: u64,\n    last_activity: Instant,\n    throttle_until: Option<Instant>,\n}\n\n/// Backpressure metrics\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BackpressureMetrics {\n    pub total_streams: usize,\n    pub total_in_flight: usize,\n    pub total_memory_usage: u64,\n    pub status: BackpressureStatus,\n    pub throttled_streams: usize,\n    pub rejection_rate: f64,\n    pub average_wait_time: Duration,\n}\n\n/// Backpressure controller for managing resource usage\n#[derive(Debug)]\npub struct BackpressureController {\n    config: BackpressureConfig,\n    stream_resources: Arc<RwLock<HashMap<Uuid, StreamResources>>>,\n    global_semaphore: Arc<Semaphore>,\n    memory_semaphore: Arc<Semaphore>,\n    metrics: Arc<RwLock<BackpressureMetrics>>,\n    rejection_count: Arc<RwLock<u64>>,\n    total_requests: Arc<RwLock<u64>>,\n    wait_times: Arc<RwLock<Vec<Duration>>>,\n}\n\nimpl BackpressureController {\n    /// Create a new backpressure controller\n    pub fn new(config: BackpressureConfig) -> Self {\n        let global_semaphore = Arc::new(Semaphore::new(config.max_total_items));\n        let memory_semaphore = Arc::new(Semaphore::new(\n            (config.max_memory_bytes / 1024) as usize // Convert to KB for semaphore\n        ));\n        \n        let controller = Self {\n            config: config.clone(),\n            stream_resources: Arc::new(RwLock::new(HashMap::new())),\n            global_semaphore,\n            memory_semaphore,\n            metrics: Arc::new(RwLock::new(BackpressureMetrics {\n                total_streams: 0,\n                total_in_flight: 0,\n                total_memory_usage: 0,\n                status: BackpressureStatus::Normal,\n                throttled_streams: 0,\n                rejection_rate: 0.0,\n                average_wait_time: Duration::from_millis(0),\n            })),\n            rejection_count: Arc::new(RwLock::new(0)),\n            total_requests: Arc::new(RwLock::new(0)),\n            wait_times: Arc::new(RwLock::new(Vec::new())),\n        };\n        \n        // Start background monitoring\n        controller.start_monitoring();\n        \n        controller\n    }\n\n    /// Register a new stream\n    pub async fn register_stream(&self, stream_id: Uuid) -> StreamingResult<()> {\n        let mut resources = self.stream_resources.write().await;\n        resources.insert(stream_id, StreamResources {\n            in_flight_items: 0,\n            memory_usage: 0,\n            last_activity: Instant::now(),\n            throttle_until: None,\n        });\n        \n        self.update_metrics().await;\n        Ok(())\n    }\n\n    /// Attempt to acquire resources for processing an item\n    pub async fn acquire(&self, stream_id: Uuid, estimated_memory: u64) -> StreamingResult<BackpressurePermit> {\n        let start_time = Instant::now();\n        *self.total_requests.write().await += 1;\n        \n        // Check if stream is throttled\n        {\n            let resources = self.stream_resources.read().await;\n            if let Some(stream_res) = resources.get(&stream_id) {\n                if let Some(throttle_until) = stream_res.throttle_until {\n                    if Instant::now() < throttle_until {\n                        *self.rejection_count.write().await += 1;\n                        return Err(StreamingError::BackpressureExceeded);\n                    }\n                }\n            }\n        }\n        \n        // Check stream-specific limits\n        {\n            let resources = self.stream_resources.read().await;\n            if let Some(stream_res) = resources.get(&stream_id) {\n                if stream_res.in_flight_items >= self.config.max_in_flight {\n                    *self.rejection_count.write().await += 1;\n                    return Err(StreamingError::BackpressureExceeded);\n                }\n            }\n        }\n        \n        // Try to acquire global semaphore permit\n        let global_permit = match self.global_semaphore.try_acquire() {\n            Ok(permit) => permit,\n            Err(_) => {\n                *self.rejection_count.write().await += 1;\n                return Err(StreamingError::BackpressureExceeded);\n            }\n        };\n        \n        // Try to acquire memory permit\n        let memory_kb = (estimated_memory / 1024).max(1) as usize;\n        let memory_permit = match self.memory_semaphore.try_acquire_many(memory_kb as u32) {\n            Ok(permit) => Some(permit),\n            Err(_) => {\n                // Release global permit and reject\n                drop(global_permit);\n                *self.rejection_count.write().await += 1;\n                return Err(StreamingError::BackpressureExceeded);\n            }\n        };\n        \n        // Update stream resources\n        {\n            let mut resources = self.stream_resources.write().await;\n            if let Some(stream_res) = resources.get_mut(&stream_id) {\n                stream_res.in_flight_items += 1;\n                stream_res.memory_usage += estimated_memory;\n                stream_res.last_activity = Instant::now();\n            }\n        }\n        \n        // Record wait time\n        let wait_time = start_time.elapsed();\n        {\n            let mut wait_times = self.wait_times.write().await;\n            wait_times.push(wait_time);\n            if wait_times.len() > 1000 {\n                wait_times.remove(0);\n            }\n        }\n        \n        self.update_metrics().await;\n        \n        Ok(BackpressurePermit {\n            stream_id,\n            estimated_memory,\n            controller: self.clone(),\n            _global_permit: global_permit,\n            _memory_permit: memory_permit,\n        })\n    }\n\n    /// Release resources for a stream\n    pub async fn release(&self, stream_id: Uuid, actual_memory: u64) {\n        let mut resources = self.stream_resources.write().await;\n        if let Some(stream_res) = resources.get_mut(&stream_id) {\n            stream_res.in_flight_items = stream_res.in_flight_items.saturating_sub(1);\n            stream_res.memory_usage = stream_res.memory_usage.saturating_sub(actual_memory);\n            stream_res.last_activity = Instant::now();\n        }\n        \n        drop(resources);\n        self.update_metrics().await;\n    }\n\n    /// Unregister a stream\n    pub async fn unregister_stream(&self, stream_id: Uuid) {\n        let mut resources = self.stream_resources.write().await;\n        resources.remove(&stream_id);\n        drop(resources);\n        self.update_metrics().await;\n    }\n\n    /// Get current backpressure metrics\n    pub async fn get_metrics(&self) -> BackpressureMetrics {\n        let metrics = self.metrics.read().await;\n        metrics.clone()\n    }\n\n    /// Update internal metrics\n    async fn update_metrics(&self) {\n        let resources = self.stream_resources.read().await;\n        \n        let total_streams = resources.len();\n        let total_in_flight = resources.values().map(|r| r.in_flight_items).sum();\n        let total_memory_usage = resources.values().map(|r| r.memory_usage).sum();\n        let throttled_streams = resources.values()\n            .filter(|r| r.throttle_until.map_or(false, |t| Instant::now() < t))\n            .count();\n        \n        // Calculate rejection rate\n        let rejections = *self.rejection_count.read().await;\n        let total_reqs = *self.total_requests.read().await;\n        let rejection_rate = if total_reqs > 0 {\n            rejections as f64 / total_reqs as f64\n        } else {\n            0.0\n        };\n        \n        // Calculate average wait time\n        let wait_times = self.wait_times.read().await;\n        let average_wait_time = if !wait_times.is_empty() {\n            let total: Duration = wait_times.iter().sum();\n            total / wait_times.len() as u32\n        } else {\n            Duration::from_millis(0)\n        };\n        \n        // Determine status\n        let memory_usage_ratio = total_memory_usage as f64 / self.config.max_memory_bytes as f64;\n        let items_usage_ratio = total_in_flight as f64 / self.config.max_total_items as f64;\n        let max_usage = memory_usage_ratio.max(items_usage_ratio);\n        \n        let status = if max_usage >= self.config.activation_threshold {\n            if max_usage >= 0.95 {\n                BackpressureStatus::Critical\n            } else {\n                BackpressureStatus::Throttled\n            }\n        } else if max_usage >= 0.7 {\n            BackpressureStatus::Warning\n        } else {\n            BackpressureStatus::Normal\n        };\n        \n        let mut metrics = self.metrics.write().await;\n        *metrics = BackpressureMetrics {\n            total_streams,\n            total_in_flight,\n            total_memory_usage,\n            status,\n            throttled_streams,\n            rejection_rate,\n            average_wait_time,\n        };\n    }\n\n    /// Start background monitoring task\n    fn start_monitoring(&self) {\n        let controller = self.clone();\n        tokio::spawn(async move {\n            let mut interval = interval(controller.config.check_interval);\n            \n            loop {\n                interval.tick().await;\n                controller.monitor_and_adjust().await;\n            }\n        });\n    }\n\n    /// Monitor resources and adjust throttling\n    async fn monitor_and_adjust(&self) {\n        if !self.config.adaptive {\n            return;\n        }\n        \n        let metrics = self.get_metrics().await;\n        let now = Instant::now();\n        \n        // Clean up old streams\n        {\n            let mut resources = self.stream_resources.write().await;\n            let inactive_streams: Vec<Uuid> = resources\n                .iter()\n                .filter(|(_, res)| now.duration_since(res.last_activity) > Duration::from_secs(300))\n                .map(|(id, _)| *id)\n                .collect();\n            \n            for stream_id in inactive_streams {\n                resources.remove(&stream_id);\n            }\n        }\n        \n        // Adjust throttling based on current load\n        match metrics.status {\n            BackpressureStatus::Critical => {\n                self.apply_throttling(Duration::from_secs(5)).await;\n            }\n            BackpressureStatus::Throttled => {\n                self.apply_throttling(Duration::from_secs(2)).await;\n            }\n            BackpressureStatus::Warning => {\n                self.apply_throttling(Duration::from_millis(500)).await;\n            }\n            BackpressureStatus::Normal => {\n                self.clear_throttling().await;\n            }\n        }\n    }\n\n    /// Apply throttling to all streams\n    async fn apply_throttling(&self, duration: Duration) {\n        let mut resources = self.stream_resources.write().await;\n        let throttle_until = Instant::now() + duration;\n        \n        for stream_res in resources.values_mut() {\n            stream_res.throttle_until = Some(throttle_until);\n        }\n    }\n\n    /// Clear throttling from all streams\n    async fn clear_throttling(&self) {\n        let mut resources = self.stream_resources.write().await;\n        \n        for stream_res in resources.values_mut() {\n            stream_res.throttle_until = None;\n        }\n    }\n}\n\nimpl Clone for BackpressureController {\n    fn clone(&self) -> Self {\n        Self {\n            config: self.config.clone(),\n            stream_resources: Arc::clone(&self.stream_resources),\n            global_semaphore: Arc::clone(&self.global_semaphore),\n            memory_semaphore: Arc::clone(&self.memory_semaphore),\n            metrics: Arc::clone(&self.metrics),\n            rejection_count: Arc::clone(&self.rejection_count),\n            total_requests: Arc::clone(&self.total_requests),\n            wait_times: Arc::clone(&self.wait_times),\n        }\n    }\n}\n\n/// Permit for processing an item with backpressure control\npub struct BackpressurePermit {\n    stream_id: Uuid,\n    estimated_memory: u64,\n    controller: BackpressureController,\n    _global_permit: tokio::sync::SemaphorePermit<'static>,\n    _memory_permit: Option<tokio::sync::SemaphorePermit<'static>>,\n}\n\nimpl BackpressurePermit {\n    /// Get the stream ID this permit is for\n    pub fn stream_id(&self) -> Uuid {\n        self.stream_id\n    }\n    \n    /// Get the estimated memory usage\n    pub fn estimated_memory(&self) -> u64 {\n        self.estimated_memory\n    }\n}\n\nimpl Drop for BackpressurePermit {\n    fn drop(&mut self) {\n        let controller = self.controller.clone();\n        let stream_id = self.stream_id;\n        let memory = self.estimated_memory;\n        \n        tokio::spawn(async move {\n            controller.release(stream_id, memory).await;\n        });\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tokio::time::sleep;\n\n    #[tokio::test]\n    async fn test_backpressure_controller_creation() {\n        let config = BackpressureConfig::default();\n        let controller = BackpressureController::new(config);\n        \n        let metrics = controller.get_metrics().await;\n        assert_eq!(metrics.total_streams, 0);\n        assert!(matches!(metrics.status, BackpressureStatus::Normal));\n    }\n\n    #[tokio::test]\n    async fn test_stream_registration() {\n        let config = BackpressureConfig::default();\n        let controller = BackpressureController::new(config);\n        let stream_id = Uuid::new_v4();\n        \n        controller.register_stream(stream_id).await.unwrap();\n        \n        let metrics = controller.get_metrics().await;\n        assert_eq!(metrics.total_streams, 1);\n    }\n\n    #[tokio::test]\n    async fn test_resource_acquisition() {\n        let config = BackpressureConfig::default();\n        let controller = BackpressureController::new(config);\n        let stream_id = Uuid::new_v4();\n        \n        controller.register_stream(stream_id).await.unwrap();\n        \n        let permit = controller.acquire(stream_id, 1024).await.unwrap();\n        assert_eq!(permit.stream_id(), stream_id);\n        assert_eq!(permit.estimated_memory(), 1024);\n        \n        let metrics = controller.get_metrics().await;\n        assert_eq!(metrics.total_in_flight, 1);\n        \n        drop(permit);\n        \n        // Wait for cleanup\n        sleep(Duration::from_millis(10)).await;\n        \n        let metrics = controller.get_metrics().await;\n        assert_eq!(metrics.total_in_flight, 0);\n    }\n\n    #[tokio::test]\n    async fn test_backpressure_limits() {\n        let config = BackpressureConfig {\n            max_in_flight: 2,\n            max_total_items: 2,\n            ..Default::default()\n        };\n        let controller = BackpressureController::new(config);\n        let stream_id = Uuid::new_v4();\n        \n        controller.register_stream(stream_id).await.unwrap();\n        \n        // Acquire maximum permits\n        let _permit1 = controller.acquire(stream_id, 1024).await.unwrap();\n        let _permit2 = controller.acquire(stream_id, 1024).await.unwrap();\n        \n        // Third acquisition should fail\n        let result = controller.acquire(stream_id, 1024).await;\n        assert!(result.is_err());\n        assert!(matches!(result.unwrap_err(), StreamingError::BackpressureExceeded));\n    }\n\n    #[tokio::test]\n    async fn test_memory_limits() {\n        let config = BackpressureConfig {\n            max_memory_bytes: 2048, // 2KB\n            ..Default::default()\n        };\n        let controller = BackpressureController::new(config);\n        let stream_id = Uuid::new_v4();\n        \n        controller.register_stream(stream_id).await.unwrap();\n        \n        // Acquire permit using all available memory\n        let _permit1 = controller.acquire(stream_id, 2048).await.unwrap();\n        \n        // Second acquisition should fail due to memory limit\n        let result = controller.acquire(stream_id, 1024).await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_metrics_calculation() {\n        let config = BackpressureConfig::default();\n        let controller = BackpressureController::new(config);\n        let stream_id = Uuid::new_v4();\n        \n        controller.register_stream(stream_id).await.unwrap();\n        \n        let _permit = controller.acquire(stream_id, 1024).await.unwrap();\n        \n        let metrics = controller.get_metrics().await;\n        assert_eq!(metrics.total_streams, 1);\n        assert_eq!(metrics.total_in_flight, 1);\n        assert_eq!(metrics.total_memory_usage, 1024);\n    }\n}\n"