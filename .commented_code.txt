tests/common/mock_server.rs:15://! #[tokio::test]
tests/common/mock_server.rs:16://! async fn test_html_extraction() {
tests/common/timeouts.rs:13://! #[tokio::test]
tests/common/timeouts.rs:14://! async fn test_fast_operation() {
tests/common/timeouts.rs:19://! #[tokio::test]
tests/common/timeouts.rs:20://! async fn test_database_query() {
tests/common/timeouts.rs:25://! #[tokio::test]
tests/common/timeouts.rs:26://! async fn test_full_workflow() {
tests/integration/week3_integration_tests.rs:476:    // Reconstruct content from chunks (without overlap)
tests/week3/integration_tests.rs:476:    // Reconstruct content from chunks (without overlap)
crates/riptide-headless/src/lib.rs:20://! # async fn example() -> anyhow::Result<()> {
tests/unit/fix_topic_chunker.rs:8:    // Find the trait impl block and move the helper methods out
crates/riptide-facade/tests/scraper_facade_integration.rs:356:// Note: Tests requiring actual network access should be marked with #[ignore]
crates/riptide-streaming/src/cli.rs:1://! RipTide CLI tool for streaming extraction and report generation\n//!\n//! This is the main CLI binary for RipTide streaming operations,\n//! providing commands for extraction, streaming, and report generation.\n\nuse anyhow::{Context, Result};\nuse clap::{Parser, Subcommand, ValueEnum};\nuse colored::*;\nuse indicatif::{ProgressBar, ProgressStyle};\nuse riptide_streaming::{\n    config::{ConfigManager, RiptideConfig},\n    ndjson::{NdjsonStreamBuilder, to_bytes_stream},\n    reports::{ReportGenerator, ReportFormat, ReportConfig},\n    BackpressureController, StreamingCoordinator, ExtractionResult,\n};\nuse std::collections::HashMap;\nuse std::io::{self, Write};\nuse std::path::PathBuf;\nuse std::time::Duration;\nuse tokio::time::timeout;\nuse tokio_stream::StreamExt;\nuse url::Url;\n\n/// RipTide CLI - Real-time extraction streaming and reporting\n#[derive(Parser)]\n#[command(name = \"riptide-cli\")]\n#[command(about = \"A CLI for RipTide streaming extraction and reporting\")]\n#[command(version = \"1.0.0\")]\nstruct Cli {\n    /// Global configuration file\n    #[arg(short, long, global = true)]\n    config: Option<PathBuf>,\n    \n    /// Verbose output\n    #[arg(short, long, global = true)]\n    verbose: bool,\n    \n    /// Quiet mode (minimal output)\n    #[arg(short, long, global = true)]\n    quiet: bool,\n    \n    /// Disable colored output\n    #[arg(long, global = true)]\n    no_color: bool,\n    \n    /// Output format\n    #[arg(short, long, global = true, value_enum, default_value = \"json\")]\n    format: OutputFormat,\n    \n    #[command(subcommand)]\n    command: Commands,\n}\n\n/// Output format for CLI commands\n#[derive(Clone, ValueEnum)]\nenum OutputFormat {\n    Json,\n    Table,\n    Yaml,\n    Csv,\n}\n\n/// Available CLI commands\n#[derive(Subcommand)]\nenum Commands {\n    /// Extract content from URLs\n    Extract {\n        /// URLs to extract from\n        urls: Vec<String>,\n        \n        /// Output file (default: stdout)\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n        \n        /// Enable streaming mode\n        #[arg(short, long)]\n        stream: bool,\n        \n        /// Maximum concurrent extractions\n        #[arg(short, long, default_value = \"5\")]\n        concurrency: usize,\n        \n        /// Timeout per extraction (seconds)\n        #[arg(short, long, default_value = \"30\")]\n        timeout: u64,\n    },\n    \n    /// Stream extraction results in real-time\n    Stream {\n        /// Extraction ID to stream\n        extraction_id: String,\n        \n        /// Output format\n        #[arg(short, long, value_enum, default_value = \"ndjson\")]\n        format: StreamFormat,\n        \n        /// Follow mode (keep streaming)\n        #[arg(short, long)]\n        follow: bool,\n        \n        /// Buffer size for streaming\n        #[arg(short, long, default_value = \"1000\")]\n        buffer_size: usize,\n    },\n    \n    /// Generate reports from extraction results\n    Report {\n        /// Extraction ID to generate report for\n        extraction_id: String,\n        \n        /// Report format\n        #[arg(short, long, value_enum, default_value = \"html\")]\n        format: ReportOutputFormat,\n        \n        /// Output file\n        #[arg(short, long)]\n        output: Option<PathBuf>,\n        \n        /// Report template (optional)\n        #[arg(short, long)]\n        template: Option<PathBuf>,\n        \n        /// Include charts and visualizations\n        #[arg(long)]\n        charts: bool,\n        \n        /// Include raw data in report\n        #[arg(long)]\n        raw_data: bool,\n    },\n    \n    /// Configuration management\n    Config {\n        #[command(subcommand)]\n        action: ConfigAction,\n    },\n    \n    /// Server management\n    Server {\n        #[command(subcommand)]\n        action: ServerAction,\n    },\n    \n    /// Tool and integration management\n    Tools {\n        #[command(subcommand)]\n        action: ToolAction,\n    },\n}\n\n/// Stream output formats\n#[derive(Clone, ValueEnum)]\nenum StreamFormat {\n    Ndjson,\n    Json,\n    Raw,\n}\n\n/// Report output formats\n#[derive(Clone, ValueEnum)]\nenum ReportOutputFormat {\n    Html,\n    Json,\n    Csv,\n    Pdf,\n}\n\n/// Configuration actions\n#[derive(Subcommand)]\nenum ConfigAction {\n    /// Show current configuration\n    Show,\n    \n    /// Edit configuration\n    Edit,\n    \n    /// Set a configuration value\n    Set {\n        /// Configuration key\n        key: String,\n        /// Configuration value\n        value: String,\n    },\n    \n    /// Get a configuration value\n    Get {\n        /// Configuration key\n        key: String,\n    },\n    \n    /// Reset to default configuration\n    Reset,\n    \n    /// Validate configuration\n    Validate,\n}\n\n/// Server actions\n#[derive(Subcommand)]\nenum ServerAction {\n    /// Start the streaming server\n    Start {\n        /// Host to bind to\n        #[arg(long, default_value = \"localhost\")]\n        host: String,\n        \n        /// Port to bind to\n        #[arg(long, default_value = \"8080\")]\n        port: u16,\n        \n        /// Run in daemon mode\n        #[arg(short, long)]\n        daemon: bool,\n    },\n    \n    /// Stop the streaming server\n    Stop,\n    \n    /// Show server status\n    Status,\n    \n    /// Show server logs\n    Logs {\n        /// Follow logs\n        #[arg(short, long)]\n        follow: bool,\n        \n        /// Number of lines to show\n        #[arg(short, long, default_value = \"100\")]\n        lines: usize,\n    },\n}\n\n/// Tool actions\n#[derive(Subcommand)]\nenum ToolAction {\n    /// List available tools\n    List {\n        /// Filter by category\n        #[arg(short, long)]\n        category: Option<String>,\n    },\n    \n    /// Show tool information\n    Info {\n        /// Tool ID\n        tool_id: String,\n    },\n    \n    /// Register a new tool\n    Register {\n        /// Tool definition file\n        file: PathBuf,\n    },\n    \n    /// Unregister a tool\n    Unregister {\n        /// Tool ID\n        tool_id: String,\n    },\n    \n    /// Test tool health\n    Health {\n        /// Tool ID\n        tool_id: String,\n    },\n    \n    /// Export tools as Postman collection\n    Export {\n        /// Output file\n        #[arg(short, long)]\n        output: PathBuf,\n    },\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let cli = Cli::parse();\n    \n    // Initialize logging\n    init_logging(cli.verbose, cli.quiet)?;\n    \n    // Load configuration\n    let mut config_manager = if let Some(config_file) = &cli.config {\n        ConfigManager::load_from_file(config_file)\n            .with_context(|| format!(\"Failed to load config from {}\", config_file.display()))?\n    } else {\n        ConfigManager::load().unwrap_or_else(|_| {\n            eprintln!(\"{}\", \"Warning: Using default configuration\".yellow());\n            ConfigManager::new().expect(\"Failed to create default config\")\n        })\n    };\n    \n    // Set global options\n    if cli.no_color {\n        colored::control::set_override(false);\n    }\n    \n    // Execute command\n    match cli.command {\n        Commands::Extract { urls, output, stream, concurrency, timeout } => {\n            handle_extract(urls, output, stream, concurrency, timeout, &cli, &config_manager).await\n        }\n        Commands::Stream { extraction_id, format, follow, buffer_size } => {\n            handle_stream(extraction_id, format, follow, buffer_size, &cli).await\n        }\n        Commands::Report { extraction_id, format, output, template, charts, raw_data } => {\n            handle_report(extraction_id, format, output, template, charts, raw_data, &cli).await\n        }\n        Commands::Config { action } => {\n            handle_config(action, &mut config_manager, &cli).await\n        }\n        Commands::Server { action } => {\n            handle_server(action, &config_manager, &cli).await\n        }\n        Commands::Tools { action } => {\n            handle_tools(action, &config_manager, &cli).await\n        }\n    }\n}\n\n/// Initialize logging based on verbosity\nfn init_logging(verbose: bool, quiet: bool) -> Result<()> {\n    use tracing_subscriber::{EnvFilter, fmt::format::FmtSpan};\n    \n    let filter = if quiet {\n        EnvFilter::new(\"error\")\n    } else if verbose {\n        EnvFilter::new(\"debug\")\n    } else {\n        EnvFilter::new(\"info\")\n    };\n    \n    tracing_subscriber::fmt()\n        .with_env_filter(filter)\n        .with_span_events(FmtSpan::CLOSE)\n        .with_target(verbose)\n        .init();\n    \n    Ok(())\n}\n\n/// Handle extract command\nasync fn handle_extract(\n    urls: Vec<String>,\n    output: Option<PathBuf>,\n    stream: bool,\n    concurrency: usize,\n    timeout_secs: u64,\n    cli: &Cli,\n    config: &ConfigManager,\n) -> Result<()> {\n    if urls.is_empty() {\n        eprintln!(\"{}\", \"Error: No URLs provided\".red());\n        return Ok(());\n    }\n    \n    // Validate URLs\n    let mut valid_urls = Vec::new();\n    for url_str in urls {\n        match Url::parse(&url_str) {\n            Ok(url) => valid_urls.push(url),\n            Err(e) => {\n                eprintln!(\"{}: {}\", \"Warning: Invalid URL\".yellow(), url_str);\n                if cli.verbose {\n                    eprintln!(\"  Error: {}\", e);\n                }\n            }\n        }\n    }\n    \n    if valid_urls.is_empty() {\n        eprintln!(\"{}\", \"Error: No valid URLs to process\".red());\n        return Ok(());\n    }\n    \n    println!(\"{} {} URLs\", \"Extracting from\".green(), valid_urls.len());\n    \n    // Setup progress bar\n    let progress = if !cli.quiet {\n        let pb = ProgressBar::new(valid_urls.len() as u64);\n        pb.set_style(ProgressStyle::default_bar()\n            .template(\"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} {msg}\")\n            .unwrap()\n            .progress_chars(\"#>-\"));\n        Some(pb)\n    } else {\n        None\n    };\n    \n    // Create output writer\n    let mut output_writer: Box<dyn Write> = if let Some(path) = output {\n        Box::new(std::fs::File::create(path)?)\n    } else {\n        Box::new(io::stdout())\n    };\n    \n    // Setup streaming coordinator if in stream mode\n    if stream {\n        let mut coordinator = StreamingCoordinator::new();\n        let extraction_id = uuid::Uuid::new_v4().to_string();\n        let stream_id = coordinator.start_stream(extraction_id.clone()).await?;\n        \n        // Create NDJSON stream\n        let ndjson_stream = NdjsonStreamBuilder::new()\n            .buffer_size(1000)\n            .include_progress(true)\n            .build(stream_id, extraction_id);\n        \n        ndjson_stream.start().await?;\n        \n        // Process URLs with streaming\n        for (i, url) in valid_urls.iter().enumerate() {\n            if let Some(pb) = &progress {\n                pb.set_message(format!(\"Processing {}\", url));\n            }\n            \n            // Simulate extraction (in real implementation, this would call riptide-core)\n            let result = simulate_extraction(url, timeout_secs).await?;\n            \n            // Send result to stream\n            ndjson_stream.send_result(result).await?;\n            \n            if let Some(pb) = &progress {\n                pb.inc(1);\n            }\n            \n            // Update coordinator progress\n            coordinator.update_progress(stream_id, i + 1, Some(valid_urls.len())).await?;\n        }\n        \n        // End stream\n        ndjson_stream.end().await?;\n        coordinator.complete_stream(stream_id).await?;\n        \n        // Convert stream to bytes and write to output\n        let bytes_stream = to_bytes_stream(ndjson_stream);\n        tokio::pin!(bytes_stream);\n        \n        while let Some(bytes_result) = bytes_stream.next().await {\n            let bytes = bytes_result?;\n            output_writer.write_all(&bytes)?;\n        }\n    } else {\n        // Batch processing without streaming\n        let mut results = Vec::new();\n        \n        for (i, url) in valid_urls.iter().enumerate() {\n            if let Some(pb) = &progress {\n                pb.set_message(format!(\"Processing {}\", url));\n            }\n            \n            let result = simulate_extraction(url, timeout_secs).await?;\n            results.push(result);\n            \n            if let Some(pb) = &progress {\n                pb.inc(1);\n            }\n        }\n        \n        // Output results based on format\n        match cli.format {\n            OutputFormat::Json => {\n                let json = serde_json::to_string_pretty(&results)?;\n                writeln!(output_writer, \"{}\", json)?;\n            }\n            OutputFormat::Table => {\n                // Simple table output\n                writeln!(output_writer, \"{:<10} {:<50} {:<20} {:<10}\", \"ID\", \"URL\", \"Title\", \"Words\")?;\n                writeln!(output_writer, \"{}\", \"-\".repeat(90))?;\n                for result in results {\n                    writeln!(output_writer, \"{:<10} {:<50} {:<20} {:<10}\", \n                        &result.id[..8],\n                        truncate_string(&result.url, 47),\n                        result.title.as_deref().unwrap_or(\"N/A\"),\n                        result.word_count\n                    )?;\n                }\n            }\n            OutputFormat::Yaml => {\n                let yaml = serde_yaml::to_string(&results)?;\n                write!(output_writer, \"{}\", yaml)?;\n            }\n            OutputFormat::Csv => {\n                writeln!(output_writer, \"id,url,title,content,word_count,extraction_time_ms\")?;\n                for result in results {\n                    writeln!(output_writer, \"{},{},{},{},{},{}\",\n                        result.id,\n                        result.url,\n                        result.title.as_deref().unwrap_or(\"\"),\n                        result.content.replace(',', \";\"),\n                        result.word_count,\n                        result.extraction_time_ms\n                    )?;\n                }\n            }\n        }\n    }\n    \n    if let Some(pb) = progress {\n        pb.finish_with_message(\"Extraction completed\");\n    }\n    \n    println!(\"{} extraction\", \"Completed\".green().bold());\n    Ok(())\n}\n\n/// Handle stream command\nasync fn handle_stream(\n    extraction_id: String,\n    format: StreamFormat,\n    follow: bool,\n    buffer_size: usize,\n    cli: &Cli,\n) -> Result<()> {\n    println!(\"{} stream for extraction: {}\", \"Starting\".green(), extraction_id);\n    \n    // This would connect to the actual streaming endpoint\n    // For now, simulate streaming\n    \n    let timeout_duration = if follow {\n        Duration::from_secs(3600) // 1 hour for follow mode\n    } else {\n        Duration::from_secs(30)\n    };\n    \n    match timeout(timeout_duration, simulate_stream(&extraction_id, format, buffer_size)).await {\n        Ok(result) => result,\n        Err(_) => {\n            eprintln!(\"{}\", \"Stream timeout\".yellow());\n            Ok(())\n        }\n    }\n}\n\n/// Handle report command\nasync fn handle_report(\n    extraction_id: String,\n    format: ReportOutputFormat,\n    output: Option<PathBuf>,\n    _template: Option<PathBuf>,\n    charts: bool,\n    raw_data: bool,\n    cli: &Cli,\n) -> Result<()> {\n    println!(\"{} report for extraction: {}\", \"Generating\".green(), extraction_id);\n    \n    let report_format = match format {\n        ReportOutputFormat::Html => ReportFormat::Html,\n        ReportOutputFormat::Json => ReportFormat::Json,\n        ReportOutputFormat::Csv => ReportFormat::Csv,\n        ReportOutputFormat::Pdf => ReportFormat::Pdf,\n    };\n    \n    let config = ReportConfig {\n        title: format!(\"RipTide Report - {}\", extraction_id),\n        include_charts: charts,\n        include_raw_data: raw_data,\n        include_metadata: true,\n        chart_width: 800,\n        chart_height: 400,\n        theme: riptide_streaming::reports::ReportTheme::Modern,\n    };\n    \n    let generator = ReportGenerator::with_config(config);\n    let report_data = generator.generate_report(&extraction_id, report_format).await?;\n    \n    // Write report to file or stdout\n    if let Some(output_path) = output {\n        std::fs::write(&output_path, report_data)?;\n        println!(\"{} report saved to: {}\", \"Successfully\".green(), output_path.display());\n    } else {\n        io::stdout().write_all(&report_data)?;\n    }\n    \n    Ok(())\n}\n\n/// Handle config command\nasync fn handle_config(\n    action: ConfigAction,\n    config_manager: &mut ConfigManager,\n    cli: &Cli,\n) -> Result<()> {\n    match action {\n        ConfigAction::Show => {\n            if cli.format == OutputFormat::Json {\n                let json = serde_json::to_string_pretty(config_manager.config())?;\n                println!(\"{}\", json);\n            } else {\n                println!(\"{}\", config_manager.summary());\n            }\n        }\n        ConfigAction::Edit => {\n            println!(\"{}\", \"Opening configuration for editing...\".green());\n            // This would open the config file in an editor\n            println!(\"{}\", \"Note: Edit functionality not yet implemented\".yellow());\n        }\n        ConfigAction::Set { key, value } => {\n            println!(\"{} {} = {}\", \"Setting\".green(), key, value);\n            // This would set the configuration value\n            println!(\"{}\", \"Note: Set functionality not yet implemented\".yellow());\n        }\n        ConfigAction::Get { key } => {\n            println!(\"{} {}\", \"Getting\".green(), key);\n            // This would get the configuration value\n            println!(\"{}\", \"Note: Get functionality not yet implemented\".yellow());\n        }\n        ConfigAction::Reset => {\n            config_manager.reset_to_defaults()?;\n            config_manager.save()?;\n            println!(\"{}\", \"Configuration reset to defaults\".green());\n        }\n        ConfigAction::Validate => {\n            match config_manager.validate() {\n                Ok(()) => println!(\"{}\", \"Configuration is valid\".green()),\n                Err(e) => {\n                    eprintln!(\"{}: {}\", \"Configuration validation failed\".red(), e);\n                    return Err(e);\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Handle server command\nasync fn handle_server(\n    action: ServerAction,\n    config: &ConfigManager,\n    _cli: &Cli,\n) -> Result<()> {\n    match action {\n        ServerAction::Start { host, port, daemon } => {\n            println!(\"{} server on {}:{}\", \"Starting\".green(), host, port);\n            if daemon {\n                println!(\"{}\", \"Note: Daemon mode not yet implemented\".yellow());\n            }\n            // This would start the actual server\n            println!(\"{}\", \"Note: Server functionality not yet implemented\".yellow());\n        }\n        ServerAction::Stop => {\n            println!(\"{}\", \"Stopping server...\".yellow());\n            println!(\"{}\", \"Note: Server functionality not yet implemented\".yellow());\n        }\n        ServerAction::Status => {\n            println!(\"{}\", \"Checking server status...\".blue());\n            println!(\"{}\", \"Note: Server functionality not yet implemented\".yellow());\n        }\n        ServerAction::Logs { follow, lines } => {\n            println!(\"{} {} lines of logs\", \"Showing\".blue(), lines);\n            if follow {\n                println!(\"{}\", \"Following logs...\".blue());\n            }\n            println!(\"{}\", \"Note: Server functionality not yet implemented\".yellow());\n        }\n    }\n    Ok(())\n}\n\n/// Handle tools command\nasync fn handle_tools(\n    action: ToolAction,\n    _config: &ConfigManager,\n    cli: &Cli,\n) -> Result<()> {\n    match action {\n        ToolAction::List { category } => {\n            println!(\"{} tools\", \"Listing\".green());\n            if let Some(cat) = category {\n                println!(\"Category: {}\", cat);\n            }\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Info { tool_id } => {\n            println!(\"{} tool: {}\", \"Showing info for\".green(), tool_id);\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Register { file } => {\n            println!(\"{} tool from: {}\", \"Registering\".green(), file.display());\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Unregister { tool_id } => {\n            println!(\"{} tool: {}\", \"Unregistering\".yellow(), tool_id);\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Health { tool_id } => {\n            println!(\"{} health for tool: {}\", \"Checking\".blue(), tool_id);\n            println!(\"{}\", \"Note: Tool registry not yet implemented\".yellow());\n        }\n        ToolAction::Export { output } => {\n            println!(\"{} Postman collection to: {}\", \"Exporting\".green(), output.display());\n            \n            // Create a sample Postman collection\n            let registry = riptide_streaming::openapi::ToolRegistry::new();\n            let collection = registry.export_postman_collection();\n            \n            let json = serde_json::to_string_pretty(&collection)?;\n            std::fs::write(&output, json)?;\n            \n            println!(\"{} exported Postman collection\", \"Successfully\".green());\n        }\n    }\n    Ok(())\n}\n\n/// Simulate extraction for demonstration\nasync fn simulate_extraction(url: &Url, timeout_secs: u64) -> Result<ExtractionResult> {\n    // Simulate processing time\n    let processing_time = rand::random::<u64>() % (timeout_secs * 100) + 50;\n    tokio::time::sleep(Duration::from_millis(processing_time)).await;\n    \n    let content = format!(\"Sample content extracted from {}\", url);\n    let word_count = content.split_whitespace().count();\n    \n    Ok(ExtractionResult {\n        id: uuid::Uuid::new_v4().to_string(),\n        url: url.to_string(),\n        title: Some(format!(\"Page Title for {}\", url.host_str().unwrap_or(\"unknown\"))),\n        content,\n        metadata: HashMap::new(),\n        timestamp: chrono::Utc::now(),\n        extraction_time_ms: processing_time,\n        word_count,\n        links: vec![],\n        images: vec![],\n    })\n}\n\n/// Simulate streaming for demonstration\nasync fn simulate_stream(\n    extraction_id: &str,\n    format: StreamFormat,\n    _buffer_size: usize,\n) -> Result<()> {\n    println!(\"Streaming extraction: {} (format: {:?})\", extraction_id, format);\n    \n    // Simulate streaming data\n    for i in 1..=10 {\n        let item = serde_json::json!({\n            \"type\": \"extraction_result\",\n            \"id\": format!(\"result-{}\", i),\n            \"url\": format!(\"https://example.com/page{}\", i),\n            \"title\": format!(\"Page {}\", i),\n            \"content\": format!(\"Content from page {}\", i),\n            \"timestamp\": chrono::Utc::now()\n        });\n        \n        match format {\n            StreamFormat::Ndjson => {\n                println!(\"{}\", serde_json::to_string(&item)?);\n            }\n            StreamFormat::Json => {\n                println!(\"{}\", serde_json::to_string_pretty(&item)?);\n            }\n            StreamFormat::Raw => {\n                println!(\"[{}] {}: {}\", \n                    chrono::Utc::now().format(\"%H:%M:%S\"),\n                    item[\"id\"],\n                    item[\"url\"]\n                );\n            }\n        }\n        \n        tokio::time::sleep(Duration::from_millis(500)).await;\n    }\n    \n    Ok(())\n}\n\n/// Truncate string to specified length\nfn truncate_string(s: &str, max_len: usize) -> String {\n    if s.len() <= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}...\", &s[..max_len.saturating_sub(3)])\n    }\n}\n\nuse rand; // Add this for the random simulation\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_truncate_string() {\n        assert_eq!(truncate_string(\"short\", 10), \"short\");\n        assert_eq!(truncate_string(\"very long string that should be truncated\", 10), \"very lo...\");\n    }\n    \n    #[tokio::test]\n    async fn test_simulate_extraction() {\n        let url = Url::parse(\"https://example.com\").unwrap();\n        let result = simulate_extraction(&url, 5).await.unwrap();\n        \n        assert_eq!(result.url, \"https://example.com/\");\n        assert!(result.content.contains(\"example.com\"));\n        assert!(result.word_count > 0);\n    }\n}\n"
crates/riptide-streaming/src/openapi.rs:1://! OpenAPI specification and tool registry for RipTide streaming endpoints\n//!\n//! This module provides OpenAPI documentation for streaming endpoints and\n//! manages a registry of available tools and integrations.\n\nuse crate::{StreamingError, StreamingResult};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse utoipa::ToSchema;\nuse uuid::Uuid;\n\n/// OpenAPI specification builder for RipTide streaming\n#[derive(Debug, Clone)]\npub struct OpenApiBuilder {\n    title: String,\n    version: String,\n    description: String,\n    servers: Vec<ServerInfo>,\n    tools: ToolRegistry,\n}\n\n/// Server information for OpenAPI spec\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ServerInfo {\n    pub url: String,\n    pub description: String,\n    pub variables: HashMap<String, ServerVariable>,\n}\n\n/// Server variable for OpenAPI spec\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ServerVariable {\n    pub default: String,\n    pub description: Option<String>,\n    pub enum_values: Option<Vec<String>>,\n}\n\n/// Tool registry for managing available integrations\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolRegistry {\n    pub tools: HashMap<String, ToolInfo>,\n    pub categories: HashMap<String, Vec<String>>,\n    pub integrations: HashMap<String, IntegrationInfo>,\n}\n\n/// Information about a tool or integration\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ToolInfo {\n    pub id: String,\n    pub name: String,\n    pub description: String,\n    pub version: String,\n    pub category: String,\n    pub endpoints: Vec<EndpointInfo>,\n    pub authentication: AuthenticationInfo,\n    pub rate_limits: Option<RateLimitInfo>,\n    pub documentation_url: Option<String>,\n    pub supported_formats: Vec<String>,\n    pub status: ToolStatus,\n}\n\n/// Tool status\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum ToolStatus {\n    Active,\n    Deprecated,\n    Beta,\n    Maintenance,\n}\n\n/// Endpoint information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct EndpointInfo {\n    pub path: String,\n    pub method: String,\n    pub summary: String,\n    pub description: String,\n    pub parameters: Vec<ParameterInfo>,\n    pub request_body: Option<RequestBodyInfo>,\n    pub responses: HashMap<String, ResponseInfo>,\n    pub tags: Vec<String>,\n    pub streaming: bool,\n}\n\n/// Parameter information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ParameterInfo {\n    pub name: String,\n    pub in_location: ParameterLocation,\n    pub description: String,\n    pub required: bool,\n    pub schema: ParameterSchema,\n}\n\n/// Parameter location\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum ParameterLocation {\n    Query,\n    Path,\n    Header,\n    Cookie,\n}\n\n/// Parameter schema\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ParameterSchema {\n    pub type_name: String,\n    pub format: Option<String>,\n    pub enum_values: Option<Vec<String>>,\n    pub default: Option<serde_json::Value>,\n    pub example: Option<serde_json::Value>,\n}\n\n/// Request body information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct RequestBodyInfo {\n    pub description: String,\n    pub required: bool,\n    pub content: HashMap<String, MediaTypeInfo>,\n}\n\n/// Media type information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct MediaTypeInfo {\n    pub schema: serde_json::Value,\n    pub example: Option<serde_json::Value>,\n    pub examples: Option<HashMap<String, ExampleInfo>>,\n}\n\n/// Example information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ExampleInfo {\n    pub summary: String,\n    pub description: Option<String>,\n    pub value: serde_json::Value,\n}\n\n/// Response information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct ResponseInfo {\n    pub description: String,\n    pub content: Option<HashMap<String, MediaTypeInfo>>,\n    pub headers: Option<HashMap<String, HeaderInfo>>,\n}\n\n/// Header information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct HeaderInfo {\n    pub description: String,\n    pub required: bool,\n    pub schema: ParameterSchema,\n}\n\n/// Authentication information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct AuthenticationInfo {\n    pub type_name: AuthenticationType,\n    pub description: String,\n    pub configuration: serde_json::Value,\n}\n\n/// Authentication type\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum AuthenticationType {\n    None,\n    ApiKey,\n    Bearer,\n    Basic,\n    OAuth2,\n    Custom,\n}\n\n/// Rate limit information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct RateLimitInfo {\n    pub requests_per_minute: u32,\n    pub burst_size: u32,\n    pub reset_strategy: ResetStrategy,\n}\n\n/// Rate limit reset strategy\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum ResetStrategy {\n    Fixed,\n    Sliding,\n    TokenBucket,\n}\n\n/// Integration information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct IntegrationInfo {\n    pub id: String,\n    pub name: String,\n    pub description: String,\n    pub provider: String,\n    pub configuration: IntegrationConfig,\n    pub health_check: HealthCheckInfo,\n    pub metrics: Option<MetricsInfo>,\n}\n\n/// Integration configuration\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct IntegrationConfig {\n    pub base_url: String,\n    pub timeout_seconds: u64,\n    pub retry_attempts: u32,\n    pub custom_headers: HashMap<String, String>,\n    pub tls_verification: bool,\n}\n\n/// Health check information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct HealthCheckInfo {\n    pub endpoint: String,\n    pub method: String,\n    pub expected_status: u16,\n    pub timeout_seconds: u64,\n    pub interval_seconds: u64,\n}\n\n/// Metrics information\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub struct MetricsInfo {\n    pub endpoint: String,\n    pub format: MetricsFormat,\n    pub labels: HashMap<String, String>,\n}\n\n/// Metrics format\n#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]\npub enum MetricsFormat {\n    Prometheus,\n    Json,\n    Statsd,\n}\n\nimpl OpenApiBuilder {\n    /// Create a new OpenAPI builder\n    pub fn new() -> Self {\n        Self {\n            title: \"RipTide Streaming API\".to_string(),\n            version: \"1.0.0\".to_string(),\n            description: \"Real-time extraction results streaming and report generation API\".to_string(),\n            servers: Vec::new(),\n            tools: ToolRegistry::new(),\n        }\n    }\n\n    /// Set the API title\n    pub fn title<S: Into<String>>(mut self, title: S) -> Self {\n        self.title = title.into();\n        self\n    }\n\n    /// Set the API version\n    pub fn version<S: Into<String>>(mut self, version: S) -> Self {\n        self.version = version.into();\n        self\n    }\n\n    /// Set the API description\n    pub fn description<S: Into<String>>(mut self, description: S) -> Self {\n        self.description = description.into();\n        self\n    }\n\n    /// Add a server\n    pub fn add_server(mut self, server: ServerInfo) -> Self {\n        self.servers.push(server);\n        self\n    }\n\n    /// Add a tool to the registry\n    pub fn add_tool(mut self, tool: ToolInfo) -> Self {\n        self.tools.add_tool(tool);\n        self\n    }\n\n    /// Build the OpenAPI specification\n    pub fn build(self) -> OpenApiSpec {\n        OpenApiSpec {\n            openapi: \"3.0.3\".to_string(),\n            info: ApiInfo {\n                title: self.title,\n                version: self.version,\n                description: self.description,\n            },\n            servers: self.servers,\n            paths: self.build_paths(),\n            components: self.build_components(),\n            tools: self.tools,\n        }\n    }\n\n    /// Build the paths section\n    fn build_paths(&self) -> HashMap<String, PathItem> {\n        let mut paths = HashMap::new();\n\n        // Streaming endpoints\n        paths.insert(\"/streams\".to_string(), PathItem {\n            get: Some(self.build_list_streams_operation()),\n            post: Some(self.build_create_stream_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/streams/{stream_id}\".to_string(), PathItem {\n            get: Some(self.build_get_stream_operation()),\n            delete: Some(self.build_delete_stream_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/streams/{stream_id}/ndjson\".to_string(), PathItem {\n            get: Some(self.build_ndjson_stream_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/streams/{stream_id}/ws\".to_string(), PathItem {\n            get: Some(self.build_websocket_operation()),\n            ..Default::default()\n        });\n\n        // Report endpoints\n        paths.insert(\"/reports\".to_string(), PathItem {\n            get: Some(self.build_list_reports_operation()),\n            post: Some(self.build_generate_report_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/reports/{report_id}\".to_string(), PathItem {\n            get: Some(self.build_get_report_operation()),\n            delete: Some(self.build_delete_report_operation()),\n            ..Default::default()\n        });\n\n        // Tool registry endpoints\n        paths.insert(\"/tools\".to_string(), PathItem {\n            get: Some(self.build_list_tools_operation()),\n            post: Some(self.build_register_tool_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/tools/{tool_id}\".to_string(), PathItem {\n            get: Some(self.build_get_tool_operation()),\n            put: Some(self.build_update_tool_operation()),\n            delete: Some(self.build_unregister_tool_operation()),\n            ..Default::default()\n        });\n\n        paths.insert(\"/tools/{tool_id}/health\".to_string(), PathItem {\n            get: Some(self.build_tool_health_operation()),\n            ..Default::default()\n        });\n\n        paths\n    }\n\n    /// Build the components section\n    fn build_components(&self) -> ComponentsInfo {\n        ComponentsInfo {\n            schemas: self.build_schemas(),\n            security_schemes: self.build_security_schemes(),\n        }\n    }\n\n    /// Build schemas\n    fn build_schemas(&self) -> HashMap<String, serde_json::Value> {\n        let mut schemas = HashMap::new();\n        \n        // Add common schemas\n        schemas.insert(\"StreamInfo\".to_string(), serde_json::json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"id\": { \"type\": \"string\", \"format\": \"uuid\" },\n                \"extraction_id\": { \"type\": \"string\" },\n                \"start_time\": { \"type\": \"string\", \"format\": \"date-time\" },\n                \"total_items\": { \"type\": \"integer\", \"nullable\": true },\n                \"processed_items\": { \"type\": \"integer\" },\n                \"status\": { \"$ref\": \"#/components/schemas/StreamStatus\" }\n            },\n            \"required\": [\"id\", \"extraction_id\", \"start_time\", \"processed_items\", \"status\"]\n        }));\n\n        schemas.insert(\"StreamStatus\".to_string(), serde_json::json!({\n            \"type\": \"string\",\n            \"enum\": [\"Active\", \"Paused\", \"Completed\", \"Failed\"]\n        }));\n\n        schemas.insert(\"ExtractionResult\".to_string(), serde_json::json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"id\": { \"type\": \"string\" },\n                \"url\": { \"type\": \"string\", \"format\": \"uri\" },\n                \"title\": { \"type\": \"string\", \"nullable\": true },\n                \"content\": { \"type\": \"string\" },\n                \"metadata\": { \"type\": \"object\" },\n                \"timestamp\": { \"type\": \"string\", \"format\": \"date-time\" },\n                \"extraction_time_ms\": { \"type\": \"integer\" },\n                \"word_count\": { \"type\": \"integer\" },\n                \"links\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n                \"images\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }\n            },\n            \"required\": [\"id\", \"url\", \"content\", \"metadata\", \"timestamp\", \"extraction_time_ms\", \"word_count\", \"links\", \"images\"]\n        }));\n\n        schemas.insert(\"ReportRequest\".to_string(), serde_json::json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"extraction_id\": { \"type\": \"string\" },\n                \"format\": { \"type\": \"string\", \"enum\": [\"html\", \"json\", \"csv\", \"pdf\"] },\n                \"config\": { \"$ref\": \"#/components/schemas/ReportConfig\" }\n            },\n            \"required\": [\"extraction_id\", \"format\"]\n        }));\n\n        schemas.insert(\"ToolInfo\".to_string(), serde_json::json!({\n            \"type\": \"object\",\n            \"properties\": {\n                \"id\": { \"type\": \"string\" },\n                \"name\": { \"type\": \"string\" },\n                \"description\": { \"type\": \"string\" },\n                \"version\": { \"type\": \"string\" },\n                \"category\": { \"type\": \"string\" },\n                \"status\": { \"type\": \"string\", \"enum\": [\"Active\", \"Deprecated\", \"Beta\", \"Maintenance\"] }\n            },\n            \"required\": [\"id\", \"name\", \"description\", \"version\", \"category\", \"status\"]\n        }));\n\n        schemas\n    }\n\n    /// Build security schemes\n    fn build_security_schemes(&self) -> HashMap<String, serde_json::Value> {\n        let mut schemes = HashMap::new();\n\n        schemes.insert(\"ApiKeyAuth\".to_string(), serde_json::json!({\n            \"type\": \"apiKey\",\n            \"in\": \"header\",\n            \"name\": \"X-API-Key\"\n        }));\n\n        schemes.insert(\"BearerAuth\".to_string(), serde_json::json!({\n            \"type\": \"http\",\n            \"scheme\": \"bearer\",\n            \"bearerFormat\": \"JWT\"\n        }));\n\n        schemes\n    }\n\n    // Operation builders (simplified for brevity)\n    fn build_list_streams_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"List active streams\".to_string(),\n            description: \"Get a list of all active extraction streams\".to_string(),\n            tags: vec![\"Streaming\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_create_stream_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"Create new stream\".to_string(),\n            description: \"Start a new extraction stream\".to_string(),\n            tags: vec![\"Streaming\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_ndjson_stream_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"NDJSON stream\".to_string(),\n            description: \"Stream extraction results in NDJSON format\".to_string(),\n            tags: vec![\"Streaming\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_websocket_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"WebSocket stream\".to_string(),\n            description: \"Stream extraction results via WebSocket\".to_string(),\n            tags: vec![\"Streaming\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_generate_report_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"Generate report\".to_string(),\n            description: \"Generate a report for extraction results\".to_string(),\n            tags: vec![\"Reports\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_list_tools_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"List tools\".to_string(),\n            description: \"Get a list of all registered tools\".to_string(),\n            tags: vec![\"Tools\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    fn build_register_tool_operation(&self) -> OperationInfo {\n        OperationInfo {\n            summary: \"Register tool\".to_string(),\n            description: \"Register a new tool or integration\".to_string(),\n            tags: vec![\"Tools\".to_string()],\n            parameters: vec![],\n            responses: HashMap::new(),\n            ..Default::default()\n        }\n    }\n\n    // Placeholder implementations for other operations\n    fn build_get_stream_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_delete_stream_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_list_reports_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_get_report_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_delete_report_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_get_tool_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_update_tool_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_unregister_tool_operation(&self) -> OperationInfo { OperationInfo::default() }\n    fn build_tool_health_operation(&self) -> OperationInfo { OperationInfo::default() }\n}\n\nimpl Default for OpenApiBuilder {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Complete OpenAPI specification\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OpenApiSpec {\n    pub openapi: String,\n    pub info: ApiInfo,\n    pub servers: Vec<ServerInfo>,\n    pub paths: HashMap<String, PathItem>,\n    pub components: ComponentsInfo,\n    pub tools: ToolRegistry,\n}\n\n/// API information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ApiInfo {\n    pub title: String,\n    pub version: String,\n    pub description: String,\n}\n\n/// Path item information\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct PathItem {\n    pub get: Option<OperationInfo>,\n    pub post: Option<OperationInfo>,\n    pub put: Option<OperationInfo>,\n    pub delete: Option<OperationInfo>,\n    pub patch: Option<OperationInfo>,\n}\n\n/// Operation information\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct OperationInfo {\n    pub summary: String,\n    pub description: String,\n    pub tags: Vec<String>,\n    pub parameters: Vec<ParameterInfo>,\n    pub responses: HashMap<String, ResponseInfo>,\n}\n\n/// Components information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ComponentsInfo {\n    pub schemas: HashMap<String, serde_json::Value>,\n    pub security_schemes: HashMap<String, serde_json::Value>,\n}\n\nimpl ToolRegistry {\n    /// Create a new tool registry\n    pub fn new() -> Self {\n        Self {\n            tools: HashMap::new(),\n            categories: HashMap::new(),\n            integrations: HashMap::new(),\n        }\n    }\n\n    /// Add a tool to the registry\n    pub fn add_tool(&mut self, tool: ToolInfo) {\n        // Add to category\n        self.categories\n            .entry(tool.category.clone())\n            .or_insert_with(Vec::new)\n            .push(tool.id.clone());\n        \n        self.tools.insert(tool.id.clone(), tool);\n    }\n\n    /// Remove a tool from the registry\n    pub fn remove_tool(&mut self, tool_id: &str) -> Option<ToolInfo> {\n        if let Some(tool) = self.tools.remove(tool_id) {\n            // Remove from category\n            if let Some(category_tools) = self.categories.get_mut(&tool.category) {\n                category_tools.retain(|id| id != tool_id);\n                if category_tools.is_empty() {\n                    self.categories.remove(&tool.category);\n                }\n            }\n            Some(tool)\n        } else {\n            None\n        }\n    }\n\n    /// Get a tool by ID\n    pub fn get_tool(&self, tool_id: &str) -> Option<&ToolInfo> {\n        self.tools.get(tool_id)\n    }\n\n    /// Get tools by category\n    pub fn get_tools_by_category(&self, category: &str) -> Vec<&ToolInfo> {\n        self.categories\n            .get(category)\n            .map(|tool_ids| {\n                tool_ids\n                    .iter()\n                    .filter_map(|id| self.tools.get(id))\n                    .collect()\n            })\n            .unwrap_or_default()\n    }\n\n    /// List all tools\n    pub fn list_tools(&self) -> Vec<&ToolInfo> {\n        self.tools.values().collect()\n    }\n\n    /// List all categories\n    pub fn list_categories(&self) -> Vec<&String> {\n        self.categories.keys().collect()\n    }\n\n    /// Add an integration\n    pub fn add_integration(&mut self, integration: IntegrationInfo) {\n        self.integrations.insert(integration.id.clone(), integration);\n    }\n\n    /// Get an integration\n    pub fn get_integration(&self, integration_id: &str) -> Option<&IntegrationInfo> {\n        self.integrations.get(integration_id)\n    }\n\n    /// Export as Postman collection\n    pub fn export_postman_collection(&self) -> PostmanCollection {\n        PostmanCollection {\n            info: PostmanInfo {\n                name: \"RipTide Streaming API\".to_string(),\n                description: \"Collection for RipTide streaming and reporting API\".to_string(),\n                schema: \"https://schema.getpostman.com/json/collection/v2.1.0/collection.json\".to_string(),\n            },\n            items: self.build_postman_items(),\n            variables: vec![],\n        }\n    }\n\n    /// Build Postman collection items\n    fn build_postman_items(&self) -> Vec<PostmanItem> {\n        let mut items = Vec::new();\n\n        // Add streaming endpoints\n        items.push(PostmanItem {\n            name: \"Streaming\".to_string(),\n            description: \"Streaming endpoints\".to_string(),\n            items: vec![\n                PostmanRequest {\n                    name: \"List Streams\".to_string(),\n                    request: PostmanRequestInfo {\n                        method: \"GET\".to_string(),\n                        url: \"{{base_url}}/streams\".to_string(),\n                        headers: vec![],\n                        body: None,\n                    },\n                },\n                PostmanRequest {\n                    name: \"Create Stream\".to_string(),\n                    request: PostmanRequestInfo {\n                        method: \"POST\".to_string(),\n                        url: \"{{base_url}}/streams\".to_string(),\n                        headers: vec![],\n                        body: Some(PostmanBody {\n                            mode: \"raw\".to_string(),\n                            raw: r#\"{\n  \"extraction_id\": \"example-extraction\",\n  \"config\": {\n    \"buffer_size\": 1000,\n    \"include_progress\": true\n  }\n}\"#.to_string(),\n                        }),\n                    },\n                },\n            ],\n        });\n\n        // Add report endpoints\n        items.push(PostmanItem {\n            name: \"Reports\".to_string(),\n            description: \"Report generation endpoints\".to_string(),\n            items: vec![\n                PostmanRequest {\n                    name: \"Generate Report\".to_string(),\n                    request: PostmanRequestInfo {\n                        method: \"POST\".to_string(),\n                        url: \"{{base_url}}/reports\".to_string(),\n                        headers: vec![],\n                        body: Some(PostmanBody {\n                            mode: \"raw\".to_string(),\n                            raw: r#\"{\n  \"extraction_id\": \"example-extraction\",\n  \"format\": \"html\",\n  \"config\": {\n    \"include_charts\": true,\n    \"theme\": \"modern\"\n  }\n}\"#.to_string(),\n                        }),\n                    },\n                },\n            ],\n        });\n\n        items\n    }\n}\n\nimpl Default for ToolRegistry {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Postman collection structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanCollection {\n    pub info: PostmanInfo,\n    pub items: Vec<PostmanItem>,\n    pub variables: Vec<PostmanVariable>,\n}\n\n/// Postman collection info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanInfo {\n    pub name: String,\n    pub description: String,\n    pub schema: String,\n}\n\n/// Postman collection item\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanItem {\n    pub name: String,\n    pub description: String,\n    pub items: Vec<PostmanRequest>,\n}\n\n/// Postman request\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanRequest {\n    pub name: String,\n    pub request: PostmanRequestInfo,\n}\n\n/// Postman request info\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanRequestInfo {\n    pub method: String,\n    pub url: String,\n    pub headers: Vec<PostmanHeader>,\n    pub body: Option<PostmanBody>,\n}\n\n/// Postman header\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanHeader {\n    pub key: String,\n    pub value: String,\n}\n\n/// Postman body\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanBody {\n    pub mode: String,\n    pub raw: String,\n}\n\n/// Postman variable\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostmanVariable {\n    pub key: String,\n    pub value: String,\n    pub description: String,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_openapi_builder() {\n        let spec = OpenApiBuilder::new()\n            .title(\"Test API\")\n            .version(\"2.0.0\")\n            .description(\"Test description\")\n            .build();\n        \n        assert_eq!(spec.info.title, \"Test API\");\n        assert_eq!(spec.info.version, \"2.0.0\");\n        assert_eq!(spec.info.description, \"Test description\");\n        assert!(!spec.paths.is_empty());\n    }\n\n    #[test]\n    fn test_tool_registry() {\n        let mut registry = ToolRegistry::new();\n        \n        let tool = ToolInfo {\n            id: \"test-tool\".to_string(),\n            name: \"Test Tool\".to_string(),\n            description: \"A test tool\".to_string(),\n            version: \"1.0.0\".to_string(),\n            category: \"testing\".to_string(),\n            endpoints: vec![],\n            authentication: AuthenticationInfo {\n                type_name: AuthenticationType::None,\n                description: \"No authentication\".to_string(),\n                configuration: serde_json::json!({}),\n            },\n            rate_limits: None,\n            documentation_url: None,\n            supported_formats: vec![\"json\".to_string()],\n            status: ToolStatus::Active,\n        };\n        \n        registry.add_tool(tool);\n        \n        assert_eq!(registry.tools.len(), 1);\n        assert!(registry.get_tool(\"test-tool\").is_some());\n        assert_eq!(registry.get_tools_by_category(\"testing\").len(), 1);\n    }\n\n    #[test]\n    fn test_postman_export() {\n        let registry = ToolRegistry::new();\n        let collection = registry.export_postman_collection();\n        \n        assert_eq!(collection.info.name, \"RipTide Streaming API\");\n        assert!(!collection.items.is_empty());\n    }\n\n    #[test]\n    fn test_tool_removal() {\n        let mut registry = ToolRegistry::new();\n        \n        let tool = ToolInfo {\n            id: \"test-tool\".to_string(),\n            name: \"Test Tool\".to_string(),\n            description: \"A test tool\".to_string(),\n            version: \"1.0.0\".to_string(),\n            category: \"testing\".to_string(),\n            endpoints: vec![],\n            authentication: AuthenticationInfo {\n                type_name: AuthenticationType::None,\n                description: \"No authentication\".to_string(),\n                configuration: serde_json::json!({}),\n            },\n            rate_limits: None,\n            documentation_url: None,\n            supported_formats: vec![\"json\".to_string()],\n            status: ToolStatus::Active,\n        };\n        \n        registry.add_tool(tool);\n        assert_eq!(registry.tools.len(), 1);\n        \n        let removed = registry.remove_tool(\"test-tool\");\n        assert!(removed.is_some());\n        assert_eq!(registry.tools.len(), 0);\n        assert!(registry.categories.is_empty());\n    }\n}\n"
crates/riptide-facade/tests/browser_facade_integration.rs:286:// async fn create_test_browser() -> Result<BrowserFacade, Box<dyn std::error::Error>> {
crates/riptide-facade/tests/extractor_facade_integration.rs:333:// async fn create_test_extractor() -> Result<ExtractorFacade, Box<dyn std::error::Error>> {
crates/riptide-types/src/config.rs:105:/// Note: This struct cannot include DynamicConfig, StealthConfig, or PdfConfig
crates/riptide-security/src/types.rs:297:// impl From<SecurityError> for anyhow::Error {
crates/riptide-security/src/types.rs:298://     fn from(err: SecurityError) -> Self {
crates/riptide-facade/src/facades/search.rs:12://! # async fn example() -> anyhow::Result<()> {
crates/riptide-facade/src/facades/search.rs:80:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-facade/src/facades/search.rs:114:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-facade/src/facades/search.rs:169:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-facade/src/facades/search.rs:218:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-facade/src/facades/search.rs:265:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-facade/src/facades/search.rs:299:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-facade/src/facades/search.rs:326:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-facade/src/facades/spider.rs:61:    /// # #[tokio::main]
crates/riptide-facade/src/facades/spider.rs:62:    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/spider.rs:107:    /// # #[tokio::main]
crates/riptide-facade/src/facades/spider.rs:108:    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/spider.rs:141:    /// # #[tokio::main]
crates/riptide-facade/src/facades/spider.rs:142:    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-types/src/conditional.rs:95:        // Check If-Match (for unsafe methods)
crates/riptide-facade/src/facades/scraper.rs:57:    /// # #[tokio::main]
crates/riptide-facade/src/facades/scraper.rs:58:    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/browser.rs:32:/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/browser.rs:206:    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/browser.rs:255:    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/browser.rs:301:    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/browser.rs:341:    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/browser.rs:400:    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/browser.rs:446:    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/facades/browser.rs:501:    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-browser-abstraction/tests/spider_impl_tests.rs:27:    // but we can test the struct construction logic
crates/riptide-browser-abstraction/tests/chromiumoxide_impl_tests.rs:487:    // Test that we can construct it (validation happens at usage time)
crates/riptide-browser-abstraction/tests/chromiumoxide_impl_tests.rs:500:    // Test that we can construct it (validation happens at usage time)
crates/riptide-browser-abstraction/tests/trait_behavior_tests.rs:175:    // Test struct update syntax
crates/riptide-stealth/tests/stealth_tests.rs:4://! They are marked with #[ignore] and TODO comments for future implementation.
crates/riptide-browser-abstraction/src/spider_impl.rs:4://! unlike the chromiumoxide_impl which uses the chromiumoxide compatibility layer.
crates/riptide-test-utils/src/lib.rs:11:// #[cfg(feature = "http-mock")]
crates/riptide-browser-abstraction/src/tests.rs:11:    // #[cfg(feature = "spider")]
crates/riptide-browser-abstraction/src/lib.rs:17://! # async fn example() -> anyhow::Result<()> {
crates/riptide-facade/src/builder.rs:161:    /// # #[tokio::main]
crates/riptide-facade/src/builder.rs:162:    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/builder.rs:189:    /// # #[tokio::main]
crates/riptide-facade/src/builder.rs:190:    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/builder.rs:217:    /// # #[tokio::main]
crates/riptide-facade/src/builder.rs:218:    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-facade/src/lib.rs:18://! #[tokio::main]
crates/riptide-facade/src/lib.rs:19://! async fn main() -> Result<(), RiptideError> {
crates/riptide-facade/src/lib.rs:59:    /// # #[tokio::main]
crates/riptide-facade/src/lib.rs:60:    /// # async fn main() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-cache/src/warming_integration.rs:266:    // #[tokio::test]
crates/riptide-cache/src/warming_integration.rs:267:    // async fn test_cache_warming_pool_creation() {
crates/riptide-cache/src/wasm/mod.rs:14://! #[tokio::main]
crates/riptide-cache/src/wasm/mod.rs:15://! async fn main() -> anyhow::Result<()> {
crates/riptide-cache/src/lib.rs:24://! #[tokio::main]
crates/riptide-cache/src/lib.rs:25://! async fn main() -> anyhow::Result<()> {
crates/riptide-pdf/src/lib.rs:21://! #[tokio::main]
crates/riptide-pdf/src/lib.rs:22://! async fn main() -> Result<(), Box<dyn std::error::Error>> {
crates/riptide-pdf/src/processor.rs:966:/// Helper struct to collect extraction results
crates/riptide-reliability/src/engine_selection.rs:328:/// A `ContentAnalysis` struct containing detailed analysis results.
crates/riptide-pdf/src/helpers.rs:23:/// #[tokio::main]
crates/riptide-pdf/src/helpers.rs:24:/// async fn main() -> anyhow::Result<()> {
crates/riptide-pdf/src/helpers.rs:60:/// fn main() -> anyhow::Result<()> {
crates/riptide-pdf/src/helpers.rs:91:/// fn main() -> anyhow::Result<()> {
crates/riptide-pdf/src/helpers.rs:122:/// fn main() -> anyhow::Result<()> {
crates/riptide-pdf/src/helpers.rs:152:/// fn main() -> anyhow::Result<()> {
crates/riptide-reliability/src/gate.rs:5:/// This struct represents various characteristics of a web page that help determine
crates/riptide-pool/tests/pool_tests.rs:189:    // Note: WasmResourceTracker is a simple struct without atomic fields
crates/riptide-pool/src/lib.rs:20://! # async fn example() -> anyhow::Result<()> {
crates/riptide-cli/src/metrics/mod.rs:37://! async fn execute_command() -> anyhow::Result<()> {
crates/riptide-intelligence/src/providers/local.rs:159:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-api/tests/unit/test_errors.rs:332:        // Note: This is a simplified test as reqwest::Error is hard to construct directly
crates/riptide-cli/src/commands/pdf.rs:183:// This struct is kept for future use but not currently used
crates/riptide-api/tests/browser_pool_integration.rs:6://! with `#[ignore]` by default. Run with:
crates/riptide-extraction/src/strategies/manager.rs:112:    // pub async fn register_spider(&self, strategy: Arc<dyn SpiderStrategy>) -> Result<()> {
crates/riptide-extraction/src/strategies/manager.rs:207:    // pub async fn process_crawl_requests(
crates/riptide-extraction/src/strategies/manager.rs:216:    // pub async fn process_crawl_requests_with_strategy(
crates/riptide-extraction/src/strategies/traits.rs:266:    // pub fn with_spider(mut self, strategy: Arc<dyn SpiderStrategy>) -> Self {
crates/riptide-api/src/tests/facade_integration_tests.rs:13://! `#[ignore]` require actual browser/network resources and should be run explicitly.
crates/riptide-extraction/src/table_extraction/mod.rs:20://! # async fn example() -> anyhow::Result<()> {
crates/riptide-api/src/tests/test_helpers.rs:4://! of complex types that are difficult to construct manually in tests.
crates/riptide-browser/src/pool/mod.rs:229:        // Set user_data_dir directly on the config struct to override the default
crates/riptide-extraction/src/unified_extractor.rs:16://! # async fn example() -> anyhow::Result<()> {
crates/riptide-extraction/src/unified_extractor.rs:99:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-extraction/src/unified_extractor.rs:224:    /// # async fn example() -> anyhow::Result<()> {
crates/riptide-api/src/tests/event_bus_integration_tests.rs:18:        // Use test builder to construct AppState with defaults
crates/riptide-browser/src/lib.rs:21://! # async fn example() -> anyhow::Result<()> {
crates/riptide-extraction/src/lib.rs:21://! # async fn example() -> anyhow::Result<()> {
crates/riptide-api/src/handlers/workers.rs:15:// No #[allow(dead_code)] needed as they are properly wired
crates/riptide-api/src/resource_manager/mod.rs:28://! # async fn example() -> anyhow::Result<()> {
crates/riptide-api/src/resource_manager/mod.rs:482:    /// A `ResourceStatus` struct containing current metrics for all resources
crates/riptide-api/src/resource_manager/metrics.rs:120:/// This struct holds a consistent view of all metrics at a specific moment,
crates/riptide-api/src/streaming/processor.rs:588:        // Use test builder to construct AppState
crates/riptide-api/src/streaming/pipeline.rs:580:        // Use test builder to construct AppState
crates/riptide-api/src/streaming/ndjson/streaming.rs:11://! This module contains the main streaming handler struct and its implementation methods.
crates/riptide-api/src/streaming/metrics.rs:9://! struct in `crate::metrics`. The StreamLifecycleManager automatically records
crates/riptide-api/src/streaming/mod.rs:34://! pub async fn handle_ndjson_stream(
crates/riptide-api/src/streaming/mod.rs:37://! ) -> impl IntoResponse {
crates/riptide-api/src/streaming/mod.rs:48://! pub async fn handle_websocket(
crates/riptide-api/src/streaming/mod.rs:51://! ) -> impl IntoResponse {
crates/riptide-api/src/streaming/mod.rs:63://! pub async fn handle_sse_stream(
crates/riptide-api/src/streaming/mod.rs:66://! ) -> impl IntoResponse {
crates/riptide-api/src/state.rs:39:/// This struct contains all the shared resources needed for crawling operations,
