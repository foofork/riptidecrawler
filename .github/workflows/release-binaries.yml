name: Release Binaries

# Build and publish pre-built binaries for multiple platforms
# OPTIMIZATION: Reuses Linux x86_64 binaries from CI workflow to avoid duplicate builds
#
# Runs on:
# - Version tags (v*) - ONLY after CI passes
# - Manual trigger (workflow_dispatch)
#
# Workflow:
# 1. Wait for CI to complete and pass
# 2. Download Linux x86_64 artifacts from CI (native + WASM)
# 3. Build NEW platforms only: macOS, Windows, Linux ARM64
# 4. Package and publish all binaries

on:
  push:
    tags:
      - 'v*'
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v0.5.0)'
        required: true
        type: string
      draft:
        description: 'Create as draft release'
        required: false
        default: true
        type: boolean
      skip_ci_check:
        description: 'Skip CI completion check (emergency use only)'
        required: false
        default: false
        type: boolean

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

# Cancel in-progress runs on new pushes
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Verify CI passed before proceeding
  check-ci:
    name: Verify CI Passed
    runs-on: ubuntu-latest
    # Only check if triggered by workflow_run, skip for manual dispatch with override
    if: |
      github.event_name != 'workflow_dispatch' ||
      (github.event_name == 'workflow_dispatch' && !inputs.skip_ci_check)
    outputs:
      ci_passed: ${{ steps.check.outputs.passed }}
      ci_run_id: ${{ steps.check.outputs.run_id }}
    steps:
      - name: Check CI workflow status
        id: check
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            # Triggered by workflow_run - check the triggering workflow
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              echo "‚ùå CI workflow did not pass. Cannot proceed with release."
              exit 1
            fi
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
            echo "‚úÖ CI passed (run: ${{ github.event.workflow_run.id }})"
          else
            # Manual trigger - find latest CI run
            echo "‚ö†Ô∏è Manual trigger - implement CI check via gh CLI if needed"
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "run_id=" >> $GITHUB_OUTPUT
          fi

  # Create GitHub Release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: check-ci
    if: always() && (needs.check-ci.result == 'success' || needs.check-ci.result == 'skipped')
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ steps.get_version.outputs.version }}
      ci_run_id: ${{ needs.check-ci.outputs.ci_run_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version from tag or input
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/}
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "üì¶ Building release: ${VERSION}"

      - name: Extract release notes
        id: release_notes
        run: |
          # Extract release notes from CHANGELOG if it exists
          if [ -f "CHANGELOG.md" ]; then
            # Get notes for this version
            VERSION="${{ steps.get_version.outputs.version }}"
            NOTES=$(sed -n "/## ${VERSION}/,/## /p" CHANGELOG.md | sed '$d' | tail -n +2)
            if [ -z "$NOTES" ]; then
              NOTES="Release ${VERSION}"
            fi
          else
            NOTES="Release ${{ steps.get_version.outputs.version }}"
          fi

          # Save to file to preserve multiline content
          echo "$NOTES" > /tmp/release_notes.md
          echo "notes_file=/tmp/release_notes.md" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.get_version.outputs.version }}
          release_name: RipTide ${{ steps.get_version.outputs.version }}
          body_path: ${{ steps.release_notes.outputs.notes_file }}
          draft: ${{ github.event_name == 'workflow_dispatch' && inputs.draft || false }}
          prerelease: ${{ contains(steps.get_version.outputs.version, 'rc') || contains(steps.get_version.outputs.version, 'beta') || contains(steps.get_version.outputs.version, 'alpha') }}

  # Download pre-built Linux x86_64 artifacts from CI
  download-ci-artifacts:
    name: Download CI Artifacts (Linux x86_64)
    needs: create-release
    runs-on: ubuntu-latest
    if: needs.create-release.outputs.ci_run_id != ''
    outputs:
      has_native: ${{ steps.check.outputs.has_native }}
      has_wasm: ${{ steps.check.outputs.has_wasm }}
    steps:
      - name: Download native artifacts from CI
        id: download-native
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: build-artifacts-native
          path: artifacts-native/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ needs.create-release.outputs.ci_run_id }}

      - name: Download WASM artifacts from CI
        id: download-wasm
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: build-artifacts-wasm32-wasip2
          path: artifacts-wasm/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ needs.create-release.outputs.ci_run_id }}

      - name: Check downloaded artifacts
        id: check
        run: |
          HAS_NATIVE=false
          HAS_WASM=false

          if [ -f "artifacts-native/riptide-api" ]; then
            echo "‚úÖ Found native artifacts from CI (saves 15-20 minutes!)"
            ls -lh artifacts-native/
            HAS_NATIVE=true
          else
            echo "‚ö†Ô∏è No native artifacts found, will build from scratch"
          fi

          if [ -d "artifacts-wasm" ] && [ "$(ls -A artifacts-wasm)" ]; then
            echo "‚úÖ Found WASM artifacts from CI"
            ls -lh artifacts-wasm/
            HAS_WASM=true
          else
            echo "‚ö†Ô∏è No WASM artifacts found"
          fi

          echo "has_native=$HAS_NATIVE" >> $GITHUB_OUTPUT
          echo "has_wasm=$HAS_WASM" >> $GITHUB_OUTPUT

      - name: Upload artifacts for packaging
        if: steps.check.outputs.has_native == 'true' || steps.check.outputs.has_wasm == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ci-linux-x64-artifacts
          path: |
            artifacts-native/
            artifacts-wasm/
          retention-days: 1

  # Build binaries for NEW platforms only (not Linux x86_64)
  build-binaries:
    name: Build ${{ matrix.target }}
    needs: [create-release, download-ci-artifacts]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    # Skip this job if we need CI artifacts but don't have them
    if: always() && (needs.download-ci-artifacts.result == 'success' || needs.download-ci-artifacts.result == 'skipped')
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux ARM64 (Native) - NEW PLATFORM
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            variant: native
            asset_name: riptide-linux-arm64-native
            cross: true

          # macOS x86_64 (Intel) - NEW PLATFORM
          - os: macos-13
            target: x86_64-apple-darwin
            variant: native
            asset_name: riptide-macos-x64

          # macOS ARM64 (Apple Silicon) - NEW PLATFORM
          - os: macos-14
            target: aarch64-apple-darwin
            variant: native
            asset_name: riptide-macos-arm64

          # Windows x86_64 - NEW PLATFORM
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            variant: native
            asset_name: riptide-windows-x64
            ext: .exe

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install WASM target (if needed)
        if: matrix.variant == 'wasm'
        run: rustup target add wasm32-wasip2

      - name: Install cross-compilation tools
        if: matrix.cross
        run: |
          cargo install cross --git https://github.com/cross-rs/cross

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-registry-

      - name: Cache cargo index
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-git-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-git-

      - name: Cache target directory
        uses: actions/cache@v4
        with:
          path: target
          key: ${{ runner.os }}-${{ matrix.target }}-release-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.target }}-release-

      - name: Install Linux dependencies
        if: runner.os == 'Linux' && !matrix.cross
        run: |
          sudo apt-get update
          sudo apt-get install -y pkg-config libssl-dev

      - name: Build binaries for new platform
        env:
          RUSTFLAGS: "-C target-cpu=native -C opt-level=3"
        run: |
          echo "üî® Building for ${{ matrix.target }} (NEW PLATFORM - not built by CI)..."

          if [ "${{ matrix.cross }}" = "true" ]; then
            BUILD_CMD="cross"
          else
            BUILD_CMD="cargo"
          fi

          # All new platforms use native-parser only (no WASM)
          echo "Building with native-parser only..."
          $BUILD_CMD build --release --target ${{ matrix.target }} -p riptide-api --no-default-features --features native-parser
          $BUILD_CMD build --release --target ${{ matrix.target }} -p riptide-cli
          $BUILD_CMD build --release --target ${{ matrix.target }} -p riptide-headless
          $BUILD_CMD build --release --target ${{ matrix.target }} -p riptide-workers
        shell: bash

      - name: Strip binaries (Unix)
        if: runner.os != 'Windows'
        run: |
          strip target/${{ matrix.target }}/release/riptide-api || true
          strip target/${{ matrix.target }}/release/riptide-cli || true
          strip target/${{ matrix.target }}/release/riptide-headless || true
          strip target/${{ matrix.target }}/release/riptide-workers || true

      - name: Create distribution package
        id: package
        run: |
          mkdir -p dist/${{ matrix.asset_name }}

          # Copy binaries
          cp target/${{ matrix.target }}/release/riptide-api${{ matrix.ext || '' }} dist/${{ matrix.asset_name }}/
          cp target/${{ matrix.target }}/release/riptide-cli${{ matrix.ext || '' }} dist/${{ matrix.asset_name }}/
          cp target/${{ matrix.target }}/release/riptide-headless${{ matrix.ext || '' }} dist/${{ matrix.asset_name }}/
          cp target/${{ matrix.target }}/release/riptide-workers${{ matrix.ext || '' }} dist/${{ matrix.asset_name }}/

          # Copy WASM if built
          if [ "${{ matrix.variant }}" = "wasm" ] && [ -d "target/wasm32-wasip2/release" ]; then
            mkdir -p dist/${{ matrix.asset_name }}/wasm
            cp target/wasm32-wasip2/release/*.wasm dist/${{ matrix.asset_name }}/wasm/ || true
          fi

          # Copy configuration templates
          mkdir -p dist/${{ matrix.asset_name }}/config
          cp -r config/application dist/${{ matrix.asset_name }}/config/ || true
          cp .env.test dist/${{ matrix.asset_name }}/.env.example || true

          # Copy documentation
          cp README.md dist/${{ matrix.asset_name }}/
          cp LICENSE dist/${{ matrix.asset_name }}/ || echo "Apache-2.0" > dist/${{ matrix.asset_name }}/LICENSE

          # Create install instructions
          cat > dist/${{ matrix.asset_name }}/INSTALL.md << 'EOF'
          # RipTide Installation

          ## Quick Start

          1. Extract this archive to your desired location
          2. Copy `.env.example` to `.env` and configure as needed
          3. Run the API server:
             ```bash
             ./riptide-api
             ```

          ## Binaries Included

          - `riptide-api` - Main API server
          - `riptide-cli` - Command-line interface
          - `riptide-headless` - Headless browser service
          - `riptide-workers` - Background workers

          ## Configuration

          Configuration files are in the `config/` directory.
          See the main README.md for detailed configuration options.

          ## For more information

          Visit: https://github.com/${{ github.repository }}
          EOF

          # Create archive
          cd dist
          if [ "${{ runner.os }}" = "Windows" ]; then
            7z a -tzip ${{ matrix.asset_name }}.zip ${{ matrix.asset_name }}
            ASSET_PATH="${{ matrix.asset_name }}.zip"
          else
            tar czf ${{ matrix.asset_name }}.tar.gz ${{ matrix.asset_name }}
            ASSET_PATH="${{ matrix.asset_name }}.tar.gz"
          fi

          echo "asset_path=dist/${ASSET_PATH}" >> $GITHUB_OUTPUT
          echo "asset_name=${ASSET_PATH}" >> $GITHUB_OUTPUT

          # Calculate checksum
          if [ "${{ runner.os }}" = "Windows" ]; then
            certutil -hashfile "${ASSET_PATH}" SHA256 > "${ASSET_PATH}.sha256"
          else
            shasum -a 256 "${ASSET_PATH}" > "${ASSET_PATH}.sha256"
          fi

          echo "‚úÖ Created package: ${ASSET_PATH}"
          ls -lh "${ASSET_PATH}"
        shell: bash

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ${{ steps.package.outputs.asset_path }}
          asset_name: ${{ steps.package.outputs.asset_name }}
          asset_content_type: application/octet-stream

      - name: Upload Checksum
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ${{ steps.package.outputs.asset_path }}.sha256
          asset_name: ${{ steps.package.outputs.asset_name }}.sha256
          asset_content_type: text/plain

  # Package Linux x86_64 artifacts from CI
  package-ci-artifacts:
    name: Package CI Artifacts (${{ matrix.variant }})
    needs: [create-release, download-ci-artifacts]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.download-ci-artifacts.result == 'success' &&
      (needs.download-ci-artifacts.outputs.has_native == 'true' ||
       needs.download-ci-artifacts.outputs.has_wasm == 'true')
    strategy:
      matrix:
        include:
          - variant: native
            asset_name: riptide-linux-x64-native
            check: has_native
          - variant: wasm
            asset_name: riptide-linux-x64-wasm
            check: has_wasm
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download CI artifacts
        uses: actions/download-artifact@v4
        with:
          name: ci-linux-x64-artifacts
          path: ci-artifacts/

      - name: Create distribution package from CI artifacts
        id: package
        run: |
          mkdir -p dist/${{ matrix.asset_name }}

          # Copy binaries from CI artifacts
          if [ "${{ matrix.variant }}" = "native" ]; then
            cp ci-artifacts/artifacts-native/riptide-* dist/${{ matrix.asset_name }}/ || exit 1
          else
            cp ci-artifacts/artifacts-native/riptide-* dist/${{ matrix.asset_name }}/ || exit 1
            if [ -d "ci-artifacts/artifacts-wasm" ]; then
              mkdir -p dist/${{ matrix.asset_name }}/wasm
              cp ci-artifacts/artifacts-wasm/*.wasm dist/${{ matrix.asset_name }}/wasm/ || true
            fi
          fi

          # Copy configuration templates
          mkdir -p dist/${{ matrix.asset_name }}/config
          cp -r config/application dist/${{ matrix.asset_name }}/config/ || true
          cp .env.test dist/${{ matrix.asset_name }}/.env.example || true

          # Copy documentation
          cp README.md dist/${{ matrix.asset_name }}/
          cp LICENSE dist/${{ matrix.asset_name }}/ || echo "Apache-2.0" > dist/${{ matrix.asset_name }}/LICENSE

          # Create install instructions
          cat > dist/${{ matrix.asset_name }}/INSTALL.md << 'EOF'
          # RipTide Installation

          ## Quick Start

          1. Extract this archive to your desired location
          2. Copy `.env.example` to `.env` and configure as needed
          3. Run the API server:
             ```bash
             ./riptide-api
             ```

          ## Binaries Included

          - `riptide-api` - Main API server
          - `riptide-cli` - Command-line interface
          - `riptide-headless` - Headless browser service
          - `riptide-workers` - Background workers

          ## Configuration

          Configuration files are in the `config/` directory.
          See the main README.md for detailed configuration options.

          ## For more information

          Visit: https://github.com/${{ github.repository }}
          EOF

          # Create archive
          cd dist
          tar czf ${{ matrix.asset_name }}.tar.gz ${{ matrix.asset_name }}
          ASSET_PATH="${{ matrix.asset_name }}.tar.gz"

          echo "asset_path=dist/${ASSET_PATH}" >> $GITHUB_OUTPUT
          echo "asset_name=${ASSET_PATH}" >> $GITHUB_OUTPUT

          # Calculate checksum
          shasum -a 256 "${ASSET_PATH}" > "${ASSET_PATH}.sha256"

          echo "‚úÖ Created package from CI artifacts: ${ASSET_PATH}"
          ls -lh "${ASSET_PATH}"

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ${{ steps.package.outputs.asset_path }}
          asset_name: ${{ steps.package.outputs.asset_name }}
          asset_content_type: application/octet-stream

      - name: Upload Checksum
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ${{ steps.package.outputs.asset_path }}.sha256
          asset_name: ${{ steps.package.outputs.asset_name }}.sha256
          asset_content_type: text/plain

  # Publish Docker images to GHCR
  publish-docker:
    name: Publish Docker Images
    needs: create-release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        variant: [native, wasm]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}},suffix=-${{ matrix.variant }}
            type=semver,pattern={{major}}.{{minor}},suffix=-${{ matrix.variant }}
            type=semver,pattern={{major}},suffix=-${{ matrix.variant }}
            type=raw,value=latest-${{ matrix.variant }}
            type=raw,value=latest,enable=${{ matrix.variant == 'native' }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: infra/docker/Dockerfile.api
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            ENABLE_WASM=${{ matrix.variant == 'wasm' && 'true' || 'false' }}

  # Summary and notifications
  release-complete:
    name: Release Complete
    needs: [create-release, build-binaries, package-ci-artifacts, publish-docker]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Check status
        run: |
          echo "=== Release Status Summary ==="
          echo ""

          # Check CI artifacts packaging
          if [[ "${{ needs.package-ci-artifacts.result }}" == "success" ]]; then
            echo "‚úÖ Linux x86_64 binaries packaged from CI (saved 30-40 minutes!)"
          elif [[ "${{ needs.package-ci-artifacts.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è CI artifacts packaging skipped (manual build?)"
          else
            echo "‚ùå CI artifacts packaging failed"
          fi

          # Check new platform builds
          if [[ "${{ needs.build-binaries.result }}" != "success" ]]; then
            echo "‚ùå New platform builds failed (macOS, Windows, ARM64)"
            exit 1
          else
            echo "‚úÖ New platform binaries built successfully"
          fi

          # Check Docker publish
          if [[ "${{ needs.publish-docker.result }}" != "success" ]]; then
            echo "‚ö†Ô∏è Docker publish failed (non-fatal)"
          else
            echo "‚úÖ Docker images published"
          fi

          echo ""
          echo "‚úÖ Release ${{ needs.create-release.outputs.version }} completed successfully!"
          echo "üì¶ Binaries available at: https://github.com/${{ github.repository }}/releases/tag/${{ needs.create-release.outputs.version }}"
          echo "üê≥ Docker images published to ghcr.io/${{ github.repository }}"
          echo ""
          echo "üéØ Optimization: Linux x86_64 binaries reused from CI workflow"
