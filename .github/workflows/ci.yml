name: CI

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "docs/**"
      - "**.md"
      - ".github/workflows/quality-gates.yml"
      - ".github/workflows/metrics.yml"
      # API validation workflow handles these:
      - "tests/api/**"
  pull_request:
    branches: ["main"]
    paths-ignore:
      - "docs/**"
      - "**.md"
      - ".github/workflows/quality-gates.yml"
      - ".github/workflows/metrics.yml"
      # API validation workflow handles these:
      - "tests/api/**"
  workflow_dispatch:

# Cancel previous runs on new push
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  RUST_BACKTRACE: 1
  # Note: RUSTFLAGS moved to per-job config to avoid applying x86 flags to WASM
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  CARGO_NET_RETRY: 10
  RUST_LOG: warn
  # Optimize for CI speed
  CARGO_BUILD_JOBS: 4

jobs:
  # Fast preliminary checks
  check:
    name: Quick Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate cache key
        id: cache-key
        run: |
          echo "key=rust-${{ hashFiles('**/Cargo.lock', '**/Cargo.toml') }}-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Setup Rust environment
        uses: ./.github/actions/setup-rust
        with:
          targets: wasm32-wasip2
          components: rustfmt, clippy
          cache-key: ${{ steps.cache-key.outputs.key }}
          shared-key: ci-cache

      - name: Check formatting
        run: cargo fmt --all --check

  # Parallel build matrix
  build:
    name: Build (${{ matrix.target }})
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: check
    strategy:
      fail-fast: false
      matrix:
        target:
          - native
        # WASM build is opt-in: only on main branch, workflow_dispatch, or [wasm] in commit message
        include:
          - target: wasm32-wasip2
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust environment
        uses: ./.github/actions/setup-rust
        with:
          targets: ${{ matrix.target == 'wasm32-wasip2' && 'wasm32-wasip2' || '' }}
          cache-key: ${{ needs.check.outputs.cache-key }}-${{ matrix.target }}
          shared-key: build-cache-${{ matrix.target }}

      - name: Build native binaries (fast, native-only)
        if: matrix.target == 'native'
        env:
          RUSTFLAGS: "-Dwarnings -C target-cpu=x86-64-v2"  # Baseline CPU for portability
        run: |
          set -e  # Exit on any error
          echo "üî® Building native binaries (WITHOUT WASM - faster builds)..."
          echo "RUSTFLAGS: $RUSTFLAGS"
          echo "Building packages with native-parser only (40% faster)..."

          # Build each binary package explicitly with native-parser feature (no WASM)
          # This skips wasmtime dependencies and uses only the native Rust parser
          echo ""
          echo "Building riptide-api (native-only, no WASM)..."
          cargo build --release -p riptide-api --no-default-features --features native-parser

          echo ""
          echo "Building riptide-headless..."
          cargo build --release -p riptide-headless

          echo ""
          echo "Building riptide-workers..."
          cargo build --release -p riptide-workers

          echo ""
          echo "‚úÖ Build completed. Detecting binary location..."

          # Cargo may build to target/release or target/<triple>/release depending on configuration
          # Find the actual location and copy binaries to standard location
          if [ -f "target/x86_64-unknown-linux-gnu/release/riptide-api" ]; then
            echo "Found binaries in target/x86_64-unknown-linux-gnu/release/"
            mkdir -p target/release
            cp target/x86_64-unknown-linux-gnu/release/riptide-{api,headless,workers} target/release/
            echo "Copied binaries to target/release/"
          fi

          echo "Final binary listing:"
          ls -lah target/release/ | grep -E "^-.*riptide-" || echo "No riptide binaries found!"

      - name: Build WASM component with caching
        if: |
          matrix.target == 'wasm32-wasip2' &&
          (github.ref == 'refs/heads/main' ||
           github.event_name == 'workflow_dispatch' ||
           contains(github.event.head_commit.message, '[wasm]'))
        env:
          RUSTFLAGS: "-Dwarnings"  # Only warnings, NO x86 CPU flags for WASM
        run: |
          # Debug: Show versions and config
          echo "RUSTC: $(rustc -vV)"
          echo "CARGO: $(cargo --version)"
          echo "TARGET_DIR: ${CARGO_TARGET_DIR:-target}"
          echo "Building WASM with explicit package selection..."

          # Build with explicit package flag (uses workspace root target dir)
          cargo build --release --target wasm32-wasip2 -p riptide-extractor-wasm -v 2>&1 | tail -20

          # List what was actually built
          echo ""
          echo "Scanning for WASM artifacts in workspace target:"
          OUTDIR="${CARGO_TARGET_DIR:-target}"
          for T in wasm32-wasip2 wasm32-wasi; do
            if [ -d "$OUTDIR/$T/release" ]; then
              echo "Contents of $OUTDIR/$T/release:"
              ls -lh "$OUTDIR/$T/release/" | grep -E "\.wasm$" || echo "  (no .wasm files)"
              if [ -d "$OUTDIR/$T/release/deps" ]; then
                echo "Contents of $OUTDIR/$T/release/deps:"
                ls -lh "$OUTDIR/$T/release/deps/" | grep -E "\.wasm$" || echo "  (no .wasm files)"
              fi
            fi
          done

          # Bulletproof artifact collection
          echo ""
          echo "Collecting WASM artifacts..."
          mkdir -p wasm-dist
          FOUND=0

          for T in wasm32-wasip2 wasm32-wasi; do
            DIR="$OUTDIR/$T/release"
            if [ -d "$DIR" ]; then
              echo "Checking $DIR for .wasm files"
              # Prefer top-level .wasm over deps/*.wasm
              if compgen -G "$DIR/*.wasm" > /dev/null; then
                echo "Found top-level .wasm files in $DIR"
                cp "$DIR/"*.wasm wasm-dist/
                FOUND=1
                break
              fi
              # Fallback to deps (some setups leave artifacts there)
              if [ -d "$DIR/deps" ] && compgen -G "$DIR/deps/*.wasm" > /dev/null; then
                echo "Found .wasm files in $DIR/deps"
                cp "$DIR/deps/"*.wasm wasm-dist/
                FOUND=1
                break
              fi
            fi
          done

          if [ "$FOUND" -eq 0 ]; then
            echo "ERROR: No .wasm artifacts found!"
            echo "Directory tree:"
            find "$OUTDIR" -maxdepth 4 -type d -name "wasm32-*" -exec echo {} \; -exec ls -la {} \; || true
            exit 1
          fi

          echo ""
          echo "Collected artifacts:"
          ls -lh wasm-dist/

          # Optimize WASM binary if it exists
          if [ -f wasm-dist/riptide_extractor_wasm.wasm ]; then
            if command -v wasm-opt >/dev/null 2>&1; then
              echo "Optimizing with wasm-opt..."
              wasm-opt -Oz wasm-dist/riptide_extractor_wasm.wasm \
                -o wasm-dist/riptide_extractor_wasm.optimized.wasm
              echo "Optimized artifact size:"
              ls -lh wasm-dist/riptide_extractor_wasm.optimized.wasm
            fi
          fi

      - name: Cache WASM artifacts
        if: matrix.target == 'wasm32-wasip2'
        uses: actions/cache@v4
        with:
          path: |
            target/wasm32-wasip2/release/*.wasm
            wasm-dist/*.wasm
            ~/.cargo/registry/cache/
          key: wasm-artifacts-${{ hashFiles('wasm/riptide-extractor-wasm/Cargo.lock') }}-${{ github.sha }}
          restore-keys: |
            wasm-artifacts-${{ hashFiles('wasm/riptide-extractor-wasm/Cargo.lock') }}-
            wasm-artifacts-

      - name: Verify native binaries exist
        if: matrix.target == 'native'
        run: |
          echo "Verifying native binaries were built..."
          for binary in riptide-api riptide-headless riptide-workers; do
            if [[ ! -f "target/release/$binary" ]]; then
              echo "‚ùå ERROR: Binary not found: target/release/$binary"
              exit 1
            fi
            echo "‚úÖ Found: target/release/$binary ($(stat --format=%s target/release/$binary | numfmt --to=iec))"
          done

      - name: Upload native build artifacts
        if: matrix.target == 'native'
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.target }}
          path: |
            target/release/riptide-api
            target/release/riptide-headless
            target/release/riptide-workers
          retention-days: 7
          compression-level: 6
          if-no-files-found: error

      - name: Upload WASM build artifacts
        if: matrix.target == 'wasm32-wasip2'
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ matrix.target }}
          path: wasm-dist/*.wasm
          retention-days: 7
          compression-level: 6
          if-no-files-found: error

  # Parallel testing
  test:
    name: Test (${{ matrix.test-type }})
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: check
    strategy:
      fail-fast: false
      matrix:
        test-type:
          - unit
          - integration
          - browser
          - features-native
          - features-wasm
          - features-all
    # Redis service for integration tests
    services:
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    steps:
      - uses: actions/checkout@v4

      - name: Free disk space
        run: |
          # Remove unnecessary packages to free up space
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc || true
          sudo apt-get clean
          df -h

      - name: Setup Rust environment
        uses: ./.github/actions/setup-rust
        with:
          cache-key: ${{ needs.check.outputs.cache-key }}-test
          shared-key: test-cache

      - name: Run unit tests (non-browser, parallel)
        if: matrix.test-type == 'unit'
        env:
          RUSTFLAGS: "-Dwarnings -C target-cpu=x86-64-v2"
          REDIS_URL: "redis://localhost:6379"
        run: |
          # Run all workspace crates except browser (parallel, fast)
          cargo test --workspace --lib --bins --exclude riptide-browser -- --nocapture --test-threads=4

      - name: Run integration tests (non-browser, parallel)
        if: matrix.test-type == 'integration'
        env:
          RUSTFLAGS: "-Dwarnings -C target-cpu=x86-64-v2"
          REQUIRE_AUTH: "false"
          REDIS_URL: "redis://localhost:6379"
        run: |
          # Wait for Redis to be ready
          timeout 30 bash -c 'until redis-cli -h localhost ping; do sleep 1; done' || echo "Redis may not be available"

          # Run all workspace integration tests except browser (parallel)
          cargo test --workspace --tests --exclude riptide-browser -- --nocapture --test-threads=2

      - name: Run browser tests (serialized, isolated)
        if: matrix.test-type == 'browser'
        env:
          RUSTFLAGS: "-Dwarnings -C target-cpu=x86-64-v2"
          # Create unique temp dir per run to avoid Chrome SingletonLock collisions
          CHROME_USER_DATA_DIR: /tmp/chrome-ci-${{ github.run_id }}
        run: |
          # Clean any stale Chrome singleton locks from previous runs
          rm -rf /tmp/chromiumoxide-runner /tmp/chrome-ci-* || true

          # Create fresh profile directory
          mkdir -p "${CHROME_USER_DATA_DIR}"

          # Run browser tests with single thread to avoid Chrome profile conflicts
          # Chrome will use flags: --no-sandbox --disable-dev-shm-usage --headless=new
          cargo test -p riptide-browser -- --test-threads=1 --nocapture 2>&1 | tee browser-tests.log

      - name: Upload browser test logs on failure
        if: matrix.test-type == 'browser' && failure()
        uses: actions/upload-artifact@v4
        with:
          name: browser-test-logs
          path: browser-tests.log
          retention-days: 7
          if-no-files-found: ignore

      # Phase 5: Feature Flag Tests - Native Only
      - name: Run feature flag tests (native-only)
        if: matrix.test-type == 'features-native'
        env:
          RUSTFLAGS: "-Dwarnings -C target-cpu=x86-64-v2"
          REDIS_URL: "redis://localhost:6379"
        run: |
          echo "üîß Testing native-only build (no wasm-extractor feature)"
          echo "This verifies the codebase works without WASM dependencies"

          # Build without WASM feature (use default features which should NOT include wasm)
          cargo build --workspace --lib --bins

          # Run workspace tests (excluding browser which needs separate treatment)
          cargo test --workspace --exclude riptide-browser \
            -- --nocapture --test-threads=2

          # Run extractor fallback tests specifically
          cargo test -p riptide extractor_fallback_tests \
            -- --nocapture

          echo "‚úÖ Native-only tests passed"

      # Phase 5: Feature Flag Tests - WASM Enabled
      - name: Run feature flag tests (with wasm-extractor)
        if: matrix.test-type == 'features-wasm'
        env:
          RUSTFLAGS: "-Dwarnings -C target-cpu=x86-64-v2"
          REDIS_URL: "redis://localhost:6379"
        run: |
          echo "üîß Testing WASM-enabled build (with wasm-extractor feature)"
          echo "This verifies WASM feature integration and fallback behavior"

          # Build with WASM feature
          cargo build --workspace --features wasm-extractor --lib --bins

          # Run workspace tests with WASM feature
          cargo test --workspace --features wasm-extractor --exclude riptide-browser \
            -- --nocapture --test-threads=2

          # Run extractor fallback tests with WASM feature
          cargo test -p riptide extractor_fallback_tests --features wasm-extractor \
            -- --nocapture

          echo "‚úÖ WASM-enabled tests passed"

      # Phase 5: Feature Flag Tests - All Features
      - name: Run feature flag tests (all features)
        if: matrix.test-type == 'features-all'
        env:
          RUSTFLAGS: "-Dwarnings -C target-cpu=x86-64-v2"
          REDIS_URL: "redis://localhost:6379"
        run: |
          echo "üîß Testing with all features enabled"
          echo "This verifies full feature compatibility"

          # Build with all features
          cargo build --workspace --all-features --lib --bins

          # Run all tests (excluding browser)
          cargo test --workspace --all-features --exclude riptide-browser \
            -- --nocapture --test-threads=2

          # Run extractor fallback tests with all features
          cargo test -p riptide extractor_fallback_tests --all-features \
            -- --nocapture

          echo "‚úÖ All-features tests passed"

  # Binary size monitoring
  size-check:
    name: Binary Size Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: build
    continue-on-error: true  # Advisory - warns but doesn't block PRs
    steps:
      - uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-native
          path: artifacts/

      - name: Download WASM artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-wasm32-wasip2
          path: wasm-dist/

      - name: Verify artifacts before size check
        run: |
          echo "Verifying artifacts..."
          ls -lah artifacts/ wasm-dist/
          if [[ ! -f artifacts/riptide-api ]]; then
            echo "‚ùå ERROR: Native artifacts not found"
            exit 1
          fi
          echo "‚úÖ Artifacts verified"

      - name: Check binary sizes
        run: |
          echo "üìä Binary Size Report"
          echo "====================="

          # Check native binaries
          for binary in artifacts/riptide-*; do
            if [[ -f "$binary" ]]; then
              size=$(stat --format=%s "$binary")
              size_mb=$(echo "scale=2; $size / 1024 / 1024" | bc)
              echo "$(basename "$binary"): ${size_mb}MB"

              # Size limits (adjust as needed)
              if (( $(echo "$size_mb > 100" | bc -l) )); then
                echo "‚ö†Ô∏è  Warning: $(basename "$binary") is larger than 100MB"
              fi
            fi
          done

          # Check WASM binary
          find wasm-dist -name "*.wasm" 2>/dev/null | while read wasm_file; do
            if [[ -f "$wasm_file" ]]; then
              size=$(stat --format=%s "$wasm_file")
              size_kb=$(echo "scale=2; $size / 1024" | bc)
              echo "$(basename "$wasm_file"): ${size_kb}KB"

              # WASM size limit
              if (( $(echo "$size_kb > 1024" | bc -l) )); then
                echo "‚ö†Ô∏è  Warning: $(basename "$wasm_file") is larger than 1MB"
              fi
            fi
          done

          echo "\nüéØ Optimization suggestions:"
          echo "- Use 'cargo bloat' to analyze binary composition"
          echo "- Consider feature flags to reduce binary size"
          echo "- Use 'wee_alloc' for WASM to reduce memory overhead"

  # Performance benchmarking
  benchmark:
    name: Performance Benchmarks
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: build
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust environment
        uses: ./.github/actions/setup-rust
        with:
          shared-key: benchmark-cache

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts-native
          path: artifacts/

      - name: Verify artifacts for benchmarking
        run: |
          echo "Verifying artifacts..."
          ls -lah artifacts/
          if [[ ! -f artifacts/riptide-api ]]; then
            echo "‚ùå ERROR: Native artifacts not found for benchmarking"
            exit 1
          fi
          echo "‚úÖ Artifacts ready for benchmarking"

      - name: Run benchmarks
        run: |
          # Add benchmark commands here if available
          echo "üöÄ Performance benchmarks would run here"
          echo "Placeholder for criterion benchmarks"

  # Final validation
  validate:
    name: Final Validation
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [build, test, size-check]
    # Only validate if jobs weren't cancelled (due to new push)
    if: |
      always() &&
      needs.build.result != 'cancelled' &&
      needs.test.result != 'cancelled'
    steps:
      - name: Check job results
        run: |
          echo "üîç Validating pipeline results..."

          # Check if critical jobs succeeded
          if [[ "${{ needs.build.result }}" != "success" ]]; then
            echo "‚ùå Build failed"
            exit 1
          fi

          if [[ "${{ needs.test.result }}" != "success" ]]; then
            echo "‚ùå Tests failed"
            exit 1
          fi

          echo "‚úÖ All critical checks passed!"
          echo "üìà Pipeline optimizations active:"
          echo "- ‚úÖ Parallel execution for builds and tests"
          echo "- ‚úÖ WASM artifact caching"
          echo "- ‚úÖ Binary size monitoring"
          echo "- ‚úÖ Incremental builds configured"
          echo "- ‚úÖ Docker builds separated (see docker-build.yml)"
          echo "- ‚úÖ Quality checks separated (see quality-gates.yml)"
          echo "- ‚úÖ Concurrency cancellation enabled"
          echo "- ‚úÖ Documentation changes skip CI"

  # Cleanup to reclaim space
  cleanup:
    name: Build Cleanup
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [validate]
    if: always()
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install cargo-sweep
        run: cargo install cargo-sweep --locked

      - name: Clean old build artifacts
        run: |
          echo "üßπ Reclaiming build space..."

          # Clean build artifacts older than 7 days
          cargo sweep --time 7 || echo "No old artifacts to clean"

          # Clean Docker build cache (keep recent)
          docker system prune -f --filter "until=24h" || true

          # Clean cargo registry cache (keep recent)
          cargo cache --autoclean || true

          echo "üíæ Space cleanup completed"
          echo "‚úÖ cargo-sweep: Removed artifacts older than 7 days"