# Safety Audit CI/CD

This document describes the automated safety checks that run on every pull request and push to the main branch.

## Overview

RipTide enforces strict memory safety and code quality standards through automated GitHub Actions workflows. These checks prevent unsafe code regressions and ensure production code maintains high quality standards.

**Workflow File**: `.github/workflows/safety-audit.yml`

## Safety Checks

### 1. Unsafe Code Audit

**Purpose**: Ensure all `unsafe` blocks are properly documented with safety justifications.

**What it checks:**
- Finds all `unsafe` blocks in production code (excluding `*/bindings.rs` and test files)
- Verifies each `unsafe` block has a `// SAFETY:` comment within 3 lines above
- Fails if any undocumented `unsafe` blocks are found

**Example - Correct:**
```rust
// SAFETY: This pointer is guaranteed to be valid because we just allocated it
// and it's aligned to the type's requirements. The memory is initialized.
let value = unsafe { ptr.read() };
```

**Example - Incorrect:**
```rust
// Missing SAFETY comment - CI will fail
let value = unsafe { ptr.read() };
```

**Exclusions:**
- `*/bindings.rs` - WASM bindings have separate safety requirements
- `**/tests/*` - Test code has relaxed safety requirements

**Local testing:**
```bash
.github/workflows/scripts/check-unsafe.sh
```

### 2. Production Code Quality (No Unwrap/Expect)

**Purpose**: Prevent panic-prone `.unwrap()` and `.expect()` calls in production code.

**What it checks:**
- Runs Clippy with `-D clippy::unwrap_used -D clippy::expect_used` on production code
- Allows `unwrap()` and `expect()` in test files only
- Fails if any production code uses these methods

**Rationale:**
- `.unwrap()` and `.expect()` can cause panics in production
- Use proper error handling with `Result` or `Option` types instead

**Local testing:**
```bash
# Check production code (should fail if unwrap/expect found)
cargo clippy --workspace --all-features --lib --bins -- \
  -D clippy::unwrap_used \
  -D clippy::expect_used \
  -D warnings

# Check tests (allows unwrap/expect)
cargo clippy --workspace --all-features --tests -- \
  -A clippy::unwrap_used \
  -A clippy::expect_used \
  -D warnings
```

**Alternatives to unwrap/expect:**
```rust
// BAD: Can panic
let value = map.get(&key).unwrap();

// GOOD: Handle error properly
let value = map.get(&key).ok_or(Error::KeyNotFound)?;

// GOOD: Provide default
let value = map.get(&key).unwrap_or(&default_value);

// GOOD: Use if-let
if let Some(value) = map.get(&key) {
    // handle value
}
```

### 3. Memory Safety (Miri)

**Purpose**: Detect undefined behavior and memory safety issues at runtime.

**What it checks:**
- Runs Miri (Rust's undefined behavior detector) on memory_manager tests
- Limited to 5-minute timeout for CI efficiency
- Continues on error (informational check)

**What Miri catches:**
- Use-after-free
- Out-of-bounds memory accesses
- Uninitialized memory reads
- Data races
- Invalid pointer arithmetic
- Alignment violations

**Local testing:**
```bash
# Install Miri (requires nightly)
rustup toolchain install nightly
cargo +nightly miri setup

# Run Miri on memory_manager tests
cargo +nightly miri test --package riptide-core --lib memory_manager

# Run on all tests (can be slow)
cargo +nightly miri test
```

**Note**: Full Miri testing can be slow. CI runs only critical memory_manager tests. Run comprehensive Miri checks locally before major releases.

### 4. WASM Safety Documentation

**Purpose**: Ensure WASM bindings document FFI safety requirements.

**What it checks:**
- Finds all `bindings.rs` files in the project
- Verifies presence of required WASM FFI safety comment
- Required text: `// SAFETY: Required for WASM component model FFI`

**Example - Correct:**
```rust
// SAFETY: Required for WASM component model FFI. These bindings are
// auto-generated by wit-bindgen and provide the interface between Rust
// and the WASM Component Model. The raw pointers are managed by the
// component model runtime and are guaranteed valid for the call duration.
#[no_mangle]
pub unsafe extern "C" fn cabi_realloc(...) {
    // FFI implementation
}
```

**Local testing:**
```bash
.github/workflows/scripts/check-wasm-safety.sh
```

## Workflow Jobs

### Job 1: `unsafe-audit`
- **Duration**: ~30 seconds
- **Dependencies**: None
- **Failure Impact**: Blocks PR merge
- Counts unsafe blocks and verifies documentation

### Job 2: `clippy-production`
- **Duration**: ~2-3 minutes (with cache)
- **Dependencies**: None
- **Failure Impact**: Blocks PR merge
- Runs Clippy twice: strict for production, relaxed for tests

### Job 3: `miri-memory-safety`
- **Duration**: ~3-5 minutes
- **Dependencies**: None
- **Failure Impact**: Warning only (continues on error)
- Runs Miri on subset of tests for CI speed

### Job 4: `wasm-safety-docs`
- **Duration**: ~10 seconds
- **Dependencies**: None
- **Failure Impact**: Blocks PR merge
- Validates WASM bindings documentation

### Job 5: `safety-summary`
- **Duration**: ~5 seconds
- **Dependencies**: All previous jobs
- **Failure Impact**: Blocks PR if critical checks failed
- Generates summary report with status of all checks

## Workflow Triggers

The safety audit runs on:
- **Pull Requests**: All PRs targeting `main` branch
- **Push to main**: Direct commits to main branch
- **Manual**: Can be triggered via `workflow_dispatch`

## Environment Variables

```yaml
env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
```

## Caching

The workflow uses `Swatinem/rust-cache@v2` for:
- Cargo dependencies
- Build artifacts
- Compilation outputs

This reduces CI time from ~10 minutes to ~5 minutes on subsequent runs.

## Handling Failures

### Unsafe Code Violations

**Error**: "Found undocumented unsafe blocks"

**Fix**:
1. Locate the file and line number in CI logs
2. Add a `// SAFETY:` comment explaining why the unsafe code is safe
3. The comment must be within 3 lines above the `unsafe` block

### Unwrap/Expect Violations

**Error**: "error: used unwrap() on a Result value"

**Fix**:
1. Replace `.unwrap()` with proper error handling
2. Options:
   - Use `?` operator if in function returning `Result`
   - Use `.unwrap_or()` / `.unwrap_or_else()` for defaults
   - Use pattern matching (`if let`, `match`)
   - Convert to `Result` with `.ok_or()`

### Miri Failures

**Error**: Miri detected undefined behavior

**Fix**:
1. Review Miri output for specific issue
2. Common causes:
   - Invalid pointer dereferences
   - Use-after-free
   - Uninitialized memory
   - Data races
3. Fix the underlying memory safety issue
4. Re-run locally with `cargo +nightly miri test`

### WASM Safety Documentation Missing

**Error**: "Missing SAFETY documentation" in bindings.rs

**Fix**:
1. Add required comment to bindings.rs:
   ```rust
   // SAFETY: Required for WASM component model FFI
   ```
2. Include explanation of why the FFI boundary is safe

## Best Practices

### For Unsafe Code

1. **Minimize unsafe**: Use safe abstractions when possible
2. **Document thoroughly**: Explain all invariants and assumptions
3. **Isolate**: Keep unsafe code in small, well-tested functions
4. **Test extensively**: Use Miri and fuzzing on unsafe code

### For Error Handling

1. **Prefer Result**: Use `Result<T, E>` for fallible operations
2. **Chain errors**: Use `?` operator to propagate errors
3. **Provide context**: Use `.context()` from anyhow/thiserror
4. **Test error paths**: Write tests for error conditions

### For WASM Bindings

1. **Auto-generate**: Use wit-bindgen for WASM bindings
2. **Document once**: Add safety comment to the top of bindings.rs
3. **Don't modify**: Treat generated bindings as read-only
4. **Version control**: Commit bindings to ensure reproducibility

## Monitoring

View workflow runs:
- **GitHub Actions**: Repository → Actions → Safety Audit
- **PR Checks**: Pull Request → Checks tab
- **Badges**: README.md shows safety audit status

## Performance

Typical CI run times (with cache):
- Unsafe audit: 30s
- Clippy checks: 2-3 min
- Miri tests: 3-5 min
- WASM docs: 10s
- **Total**: ~6-9 minutes

Without cache: ~12-15 minutes

## Scripts

### check-unsafe.sh

Standalone script for auditing unsafe code blocks.

**Usage:**
```bash
.github/workflows/scripts/check-unsafe.sh
```

**Exit codes:**
- `0`: All unsafe blocks documented
- `1`: Found undocumented unsafe blocks

### check-wasm-safety.sh

Standalone script for validating WASM bindings safety documentation.

**Usage:**
```bash
.github/workflows/scripts/check-wasm-safety.sh
```

**Exit codes:**
- `0`: All bindings documented or no bindings found
- `1`: Found bindings without proper documentation

## Troubleshooting

### False Positives

If the script incorrectly flags safe code:

1. **Check comment format**: Must be `// SAFETY:` (case-sensitive, with colon)
2. **Check proximity**: Comment must be within 3 lines above unsafe block
3. **Check exclusions**: Tests and bindings.rs should be excluded

### CI Timeout

If Miri times out:

1. Check if memory_manager tests are running correctly
2. Consider reducing test scope or increasing timeout
3. Miri failures are non-blocking by design

### Cache Issues

If builds are slow:

1. Check if rust-cache is working: look for "Restoring cache" in logs
2. Try clearing cache: Repository Settings → Actions → Caches
3. Check cache-on-failure setting

## Related Documentation

- [Coding Standards](coding-standards.md)
- [Testing Guide](testing.md)
- [Contributing Guide](contributing.md)
- [WASM Guide](../architecture/WASM_GUIDE.md)

## Support

For issues with the safety audit workflow:
1. Check CI logs for detailed error messages
2. Run scripts locally for faster debugging
3. Open an issue with CI logs attached
4. Tag maintainers for help
