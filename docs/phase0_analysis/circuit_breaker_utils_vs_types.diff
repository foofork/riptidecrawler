--- crates/riptide-utils/src/circuit_breaker.rs	2025-11-05 12:15:32.390294127 +0000
+++ crates/riptide-types/src/reliability/circuit.rs	2025-11-07 17:44:20.520735328 +0000
@@ -1,343 +1,372 @@
-//! Circuit breaker implementation for fault tolerance
-//!
-//! Prevents cascading failures by opening the circuit after repeated failures
-//! and allowing gradual recovery through half-open state.
-
+use std::sync::atomic::{AtomicU32, AtomicU64, AtomicU8, Ordering::Relaxed};
 use std::sync::Arc;
-use std::time::{Duration, Instant};
-use tokio::sync::Mutex;
-use tracing::{debug, warn};
-
-/// Circuit breaker states
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub enum CircuitState {
-    /// Circuit is closed, requests flow normally
-    Closed,
-    /// Circuit is open, requests are rejected
-    Open {
-        /// Time when circuit was opened
-        opened_at: Instant,
-        /// Number of failures that triggered opening
-        failure_count: u32,
-    },
-    /// Circuit is half-open, testing if service recovered
-    HalfOpen {
-        /// Number of successful requests in half-open state
-        success_count: u32,
-    },
+use tokio::sync::{OwnedSemaphorePermit, Semaphore};
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub enum State {
+    Closed = 0,
+    Open = 1,
+    HalfOpen = 2,
 }
 
-/// Circuit breaker configuration
-#[derive(Debug, Clone)]
-pub struct CircuitBreakerConfig {
-    /// Number of failures before opening circuit
-    pub failure_threshold: u32,
-    /// Duration to wait before transitioning from Open to HalfOpen
-    pub timeout: Duration,
-    /// Number of successful requests in HalfOpen before closing
-    pub success_threshold: u32,
+impl From<u8> for State {
+    fn from(v: u8) -> Self {
+        match v {
+            1 => State::Open,
+            2 => State::HalfOpen,
+            _ => State::Closed,
+        }
+    }
 }
 
-impl Default for CircuitBreakerConfig {
+#[derive(Clone, Debug)]
+pub struct Config {
+    pub failure_threshold: u32,       // N failures → Open
+    pub open_cooldown_ms: u64,        // time in Open
+    pub half_open_max_in_flight: u32, // number of trial calls allowed
+}
+
+impl Default for Config {
     fn default() -> Self {
         Self {
             failure_threshold: 5,
-            timeout: Duration::from_secs(60),
-            success_threshold: 2,
+            open_cooldown_ms: 30_000,
+            half_open_max_in_flight: 3,
         }
     }
 }
 
-/// Circuit breaker for protecting services from cascading failures
-pub struct CircuitBreaker {
-    config: CircuitBreakerConfig,
-    state: Arc<Mutex<CircuitBreakerState>>,
+pub trait Clock: Send + Sync + std::fmt::Debug {
+    fn now_ms(&self) -> u64;
 }
 
-#[derive(Debug)]
-struct CircuitBreakerState {
-    circuit_state: CircuitState,
-    failure_count: u32,
-    success_count: u32,
-}
+#[derive(Default, Debug)]
+pub struct RealClock;
 
-impl CircuitBreaker {
-    /// Create a new circuit breaker with default config
-    pub fn new() -> Self {
-        Self::with_config(CircuitBreakerConfig::default())
+impl Clock for RealClock {
+    fn now_ms(&self) -> u64 {
+        use std::time::{SystemTime, UNIX_EPOCH};
+        let duration = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .unwrap_or_else(|e| {
+                tracing::error!("System time is before Unix epoch: {}", e);
+                // Fallback: return 0 for current time if system clock is broken
+                // This allows the circuit breaker to continue functioning
+                std::time::Duration::from_secs(0)
+            });
+
+        // Safe conversion: saturate to u64::MAX if duration exceeds u64 milliseconds
+        // This handles the theoretical case where as_millis() returns u128 > u64::MAX
+        u64::try_from(duration.as_millis()).unwrap_or(u64::MAX)
     }
+}
 
-    /// Create a new circuit breaker with custom config
-    pub fn with_config(config: CircuitBreakerConfig) -> Self {
-        Self {
-            config,
-            state: Arc::new(Mutex::new(CircuitBreakerState {
-                circuit_state: CircuitState::Closed,
-                failure_count: 0,
-                success_count: 0,
-            })),
-        }
-    }
+#[derive(Debug)]
+pub struct CircuitBreaker {
+    state: AtomicU8,
+    failures: AtomicU32,
+    successes: AtomicU32,
+    open_until_ms: AtomicU64,
+    half_open_permits: Arc<Semaphore>,
+    cfg: Config,
+    clock: Arc<dyn Clock>,
+}
 
-    /// Check if circuit allows requests
-    pub async fn is_available(&self) -> bool {
-        let mut state = self.state.lock().await;
-
-        match &state.circuit_state {
-            CircuitState::Closed => true,
-            CircuitState::HalfOpen { .. } => true,
-            CircuitState::Open { opened_at, .. } => {
-                // Check if timeout has elapsed
-                if opened_at.elapsed() >= self.config.timeout {
-                    debug!("Circuit breaker transitioning to HalfOpen");
-                    state.circuit_state = CircuitState::HalfOpen { success_count: 0 };
-                    state.success_count = 0;
-                    true
+impl CircuitBreaker {
+    pub fn new(cfg: Config, clock: Arc<dyn Clock>) -> Arc<Self> {
+        // Safe: u32 always fits in usize on all platforms (usize >= 16 bits)
+        let permit_count = cfg.half_open_max_in_flight as usize;
+
+        Arc::new(Self {
+            state: AtomicU8::new(State::Closed as u8),
+            failures: AtomicU32::new(0),
+            successes: AtomicU32::new(0),
+            open_until_ms: AtomicU64::new(0),
+            half_open_permits: Arc::new(Semaphore::new(permit_count)),
+            cfg,
+            clock,
+        })
+    }
+
+    #[inline]
+    pub fn state(&self) -> State {
+        self.state.load(Relaxed).into()
+    }
+
+    /// Returns Ok(permit_guard) if allowed to proceed; Err if short-circuited
+    pub fn try_acquire(&self) -> Result<Option<OwnedSemaphorePermit>, &'static str> {
+        match self.state() {
+            State::Closed => Ok(None),
+            State::Open => {
+                let now = self.clock.now_ms();
+                let open_until = self.open_until_ms.load(Relaxed);
+                if now >= open_until {
+                    // transition Open -> HalfOpen
+                    self.state.store(State::HalfOpen as u8, Relaxed);
                 } else {
-                    false
+                    return Err("circuit open");
                 }
+                // fallthrough to HalfOpen path
+                self.try_acquire()
             }
+            State::HalfOpen => match Arc::clone(&self.half_open_permits).try_acquire_owned() {
+                Ok(permit) => Ok(Some(permit)),
+                Err(_) => Err("half-open saturated"),
+            },
         }
     }
 
-    /// Record a successful request
-    pub async fn record_success(&self) {
-        let mut state = self.state.lock().await;
-
-        match &state.circuit_state {
-            CircuitState::Closed => {
-                // Reset failure count on success
-                state.failure_count = 0;
+    #[inline]
+    pub fn on_success(&self) {
+        match self.state() {
+            State::Closed => {
+                self.failures.store(0, Relaxed);
             }
-            CircuitState::HalfOpen { .. } => {
-                state.success_count += 1;
-
-                if state.success_count >= self.config.success_threshold {
-                    debug!(
-                        "Circuit breaker closing after {} successes",
-                        state.success_count
-                    );
-                    state.circuit_state = CircuitState::Closed;
-                    state.failure_count = 0;
-                    state.success_count = 0;
+            State::HalfOpen => {
+                let succ = self.successes.fetch_add(1, Relaxed) + 1;
+                if succ >= 1 {
+                    // First success closes the circuit and fully resets
+                    self.state.store(State::Closed as u8, Relaxed);
+                    self.failures.store(0, Relaxed);
+                    self.successes.store(0, Relaxed);
+                    // refill semaphore (in case previous failures consumed)
+                    // Safe: u32 always fits in usize on all platforms
+                    let def = self.cfg.half_open_max_in_flight as usize;
+                    let deficit = def.saturating_sub(self.half_open_permits.available_permits());
+                    if deficit > 0 {
+                        self.half_open_permits.add_permits(deficit);
+                    }
                 }
             }
-            CircuitState::Open { .. } => {
-                // Should not receive success in Open state
-                warn!("Received success in Open state - this should not happen");
-            }
+            State::Open => {} // shouldn't happen; guarded by try_acquire
         }
     }
 
-    /// Record a failed request
-    pub async fn record_failure(&self) {
-        let mut state = self.state.lock().await;
-
-        match &state.circuit_state {
-            CircuitState::Closed => {
-                state.failure_count += 1;
-
-                if state.failure_count >= self.config.failure_threshold {
-                    warn!(
-                        "Circuit breaker opening after {} failures",
-                        state.failure_count
-                    );
-                    state.circuit_state = CircuitState::Open {
-                        opened_at: Instant::now(),
-                        failure_count: state.failure_count,
-                    };
+    #[inline]
+    pub fn on_failure(&self) {
+        match self.state() {
+            State::Closed => {
+                let f = self.failures.fetch_add(1, Relaxed) + 1;
+                if f >= self.cfg.failure_threshold {
+                    self.trip_open();
                 }
             }
-            CircuitState::HalfOpen { .. } => {
-                warn!("Circuit breaker reopening after failure in HalfOpen state");
-                state.circuit_state = CircuitState::Open {
-                    opened_at: Instant::now(),
-                    failure_count: state.failure_count + 1,
-                };
-                state.failure_count += 1;
-                state.success_count = 0;
-            }
-            CircuitState::Open { .. } => {
-                // Already open, just increment counter
-                state.failure_count += 1;
+            State::HalfOpen => {
+                // immediate reopen on any failure in half-open
+                self.trip_open();
             }
+            State::Open => {}
         }
     }
 
-    /// Get current circuit state
-    pub async fn get_state(&self) -> CircuitState {
-        let state = self.state.lock().await;
-        state.circuit_state.clone()
-    }
-
-    /// Get failure count
-    pub async fn get_failure_count(&self) -> u32 {
-        let state = self.state.lock().await;
-        state.failure_count
-    }
-
-    /// Reset circuit breaker to closed state
-    pub async fn reset(&self) {
-        let mut state = self.state.lock().await;
-        debug!("Circuit breaker manually reset to Closed");
-        state.circuit_state = CircuitState::Closed;
-        state.failure_count = 0;
-        state.success_count = 0;
+    #[inline]
+    fn trip_open(&self) {
+        self.state.store(State::Open as u8, Relaxed);
+        self.successes.store(0, Relaxed);
+        self.failures.store(0, Relaxed);
+        let until = self.clock.now_ms() + self.cfg.open_cooldown_ms;
+        self.open_until_ms.store(until, Relaxed);
+        // reset half-open permits for the next time we enter HalfOpen
+        // Safe: u32 always fits in usize on all platforms
+        let def = self.cfg.half_open_max_in_flight as usize;
+        let avail = self.half_open_permits.available_permits();
+        if avail < def {
+            self.half_open_permits.add_permits(def - avail);
+        }
+    }
+
+    pub fn failure_count(&self) -> u32 {
+        self.failures.load(Relaxed)
     }
 }
 
-impl Default for CircuitBreaker {
-    fn default() -> Self {
-        Self::new()
+/// Helper function to wrap async calls with circuit breaker protection
+pub async fn guarded_call<T, E, F, Fut>(cb: &Arc<CircuitBreaker>, f: F) -> Result<T, anyhow::Error>
+where
+    F: FnOnce() -> Fut,
+    Fut: std::future::Future<Output = Result<T, E>>,
+    E: Into<anyhow::Error>,
+{
+    let permit = cb
+        .try_acquire()
+        .map_err(|msg| anyhow::anyhow!("Circuit breaker rejected: {}", msg))?;
+
+    let res = f().await;
+    match &res {
+        Ok(_) => cb.on_success(),
+        Err(_) => cb.on_failure(),
     }
+    drop(permit); // releases half-open permit if any
+    res.map_err(Into::into)
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-    use tokio::time::{sleep, Duration};
+    use std::sync::atomic::AtomicU64;
+
+    #[derive(Default, Debug)]
+    struct TestClock {
+        now: AtomicU64,
+    }
+
+    impl TestClock {
+        fn advance(&self, ms: u64) {
+            self.now.fetch_add(ms, Relaxed);
+        }
+
+        #[allow(dead_code)]
+        fn set(&self, ms: u64) {
+            self.now.store(ms, Relaxed);
+        }
+    }
+
+    impl Clock for TestClock {
+        fn now_ms(&self) -> u64 {
+            self.now.load(Relaxed)
+        }
+    }
+
+    #[test]
+    fn circuit_transitions_closed_open_halfopen_closed() {
+        let clock = Arc::new(TestClock::default());
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 3,
+                open_cooldown_ms: 5_000,
+                half_open_max_in_flight: 2,
+            },
+            clock.clone(),
+        );
+
+        // Initial state is Closed
+        assert_eq!(cb.state(), State::Closed);
+        assert!(cb.try_acquire().unwrap().is_none());
+
+        // 3 failures → Open
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Closed);
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Closed);
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Should reject while cool-down not elapsed
+        assert!(cb.try_acquire().is_err());
+
+        // Advance time to exit Open
+        clock.advance(5_000);
+
+        // First acquire transitions to HalfOpen and grants a permit
+        let permit = cb.try_acquire().expect("should get permit");
+        assert!(permit.is_some());
+        assert_eq!(cb.state(), State::HalfOpen);
+
+        // Success closes
+        cb.on_success();
+        assert_eq!(cb.state(), State::Closed);
+    }
+
+    #[test]
+    fn half_open_failure_reopens_immediately() {
+        let clock = Arc::new(TestClock::default());
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 2,
+                open_cooldown_ms: 1_000,
+                half_open_max_in_flight: 1,
+            },
+            clock.clone(),
+        );
+
+        // Trip to Open
+        cb.on_failure();
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Advance time and transition to HalfOpen
+        clock.advance(1_000);
+        // RAII guard: must remain in scope to transition circuit breaker state
+        let _permit = cb.try_acquire().expect("should get permit");
+        assert_eq!(cb.state(), State::HalfOpen);
+
+        // Failure in HalfOpen immediately reopens
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Should need to wait again
+        assert!(cb.try_acquire().is_err());
+
+        // After another cooldown
+        clock.advance(1_000);
+        assert!(cb.try_acquire().is_ok());
+    }
+
+    #[test]
+    fn half_open_respects_max_permits() {
+        let clock = Arc::new(TestClock::default());
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 1,
+                open_cooldown_ms: 100,
+                half_open_max_in_flight: 2,
+            },
+            clock.clone(),
+        );
+
+        // Trip to Open
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Advance time and transition to HalfOpen
+        clock.advance(100);
+
+        // Should allow exactly 2 permits
+        let p1 = cb.try_acquire().expect("first permit");
+        assert!(p1.is_some());
+        assert_eq!(cb.state(), State::HalfOpen);
+
+        let p2 = cb.try_acquire().expect("second permit");
+        assert!(p2.is_some());
+
+        // Third should be rejected (saturated)
+        assert!(cb.try_acquire().is_err());
+
+        // Release one permit and try again
+        drop(p1);
+
+        // Now should get another permit after dropping
+        let p3 = cb.try_acquire().expect("third permit after release");
+        assert!(p3.is_some());
+    }
+
+    #[tokio::test(start_paused = true)]
+    async fn circuit_breaker_with_tokio_time() {
+        use std::time::Duration;
+
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 3,
+                open_cooldown_ms: 5_000,
+                half_open_max_in_flight: 2,
+            },
+            Arc::new(RealClock),
+        );
+
+        // Note: with start_paused = true, we control time advancement
+        assert_eq!(cb.state(), State::Closed);
+
+        // Trip to Open
+        cb.on_failure();
+        cb.on_failure();
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Can't use try_acquire with RealClock in paused time directly,
+        // but we demonstrate the pattern
+        tokio::time::advance(Duration::from_millis(5_000)).await;
 
-    #[tokio::test]
-    async fn test_circuit_breaker_opens_after_failures() {
-        let config = CircuitBreakerConfig {
-            failure_threshold: 3,
-            timeout: Duration::from_secs(60),
-            success_threshold: 2,
-        };
-        let cb = CircuitBreaker::with_config(config);
-
-        // Initially closed
-        assert!(cb.is_available().await);
-        assert_eq!(cb.get_state().await, CircuitState::Closed);
-
-        // Record failures
-        cb.record_failure().await;
-        cb.record_failure().await;
-        assert!(cb.is_available().await); // Still closed
-
-        cb.record_failure().await; // Threshold reached
-        assert!(!cb.is_available().await); // Now open
-        assert!(matches!(cb.get_state().await, CircuitState::Open { .. }));
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_transitions_to_half_open() {
-        let config = CircuitBreakerConfig {
-            failure_threshold: 2,
-            timeout: Duration::from_millis(100),
-            success_threshold: 2,
-        };
-        let cb = CircuitBreaker::with_config(config);
-
-        // Open the circuit
-        cb.record_failure().await;
-        cb.record_failure().await;
-        assert!(!cb.is_available().await);
-
-        // Wait for timeout
-        sleep(Duration::from_millis(150)).await;
-
-        // Should transition to HalfOpen
-        assert!(cb.is_available().await);
-        assert!(matches!(
-            cb.get_state().await,
-            CircuitState::HalfOpen { .. }
-        ));
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_closes_after_successes() {
-        let config = CircuitBreakerConfig {
-            failure_threshold: 2,
-            timeout: Duration::from_millis(100),
-            success_threshold: 2,
-        };
-        let cb = CircuitBreaker::with_config(config);
-
-        // Open the circuit
-        cb.record_failure().await;
-        cb.record_failure().await;
-
-        // Wait and transition to HalfOpen
-        sleep(Duration::from_millis(150)).await;
-        assert!(cb.is_available().await);
-
-        // Record successes
-        cb.record_success().await;
-        cb.record_success().await;
-
-        // Should close
-        assert_eq!(cb.get_state().await, CircuitState::Closed);
-        assert_eq!(cb.get_failure_count().await, 0);
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_reopens_on_half_open_failure() {
-        let config = CircuitBreakerConfig {
-            failure_threshold: 2,
-            timeout: Duration::from_millis(100),
-            success_threshold: 2,
-        };
-        let cb = CircuitBreaker::with_config(config);
-
-        // Open the circuit
-        cb.record_failure().await;
-        cb.record_failure().await;
-
-        // Wait and transition to HalfOpen
-        sleep(Duration::from_millis(150)).await;
-        assert!(cb.is_available().await);
-
-        // Record failure in HalfOpen
-        cb.record_failure().await;
-
-        // Should reopen
-        assert!(!cb.is_available().await);
-        assert!(matches!(cb.get_state().await, CircuitState::Open { .. }));
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_reset() {
-        let config = CircuitBreakerConfig {
-            failure_threshold: 2,
-            timeout: Duration::from_secs(60),
-            success_threshold: 2,
-        };
-        let cb = CircuitBreaker::with_config(config);
-
-        // Open the circuit
-        cb.record_failure().await;
-        cb.record_failure().await;
-        assert!(!cb.is_available().await);
-
-        // Reset
-        cb.reset().await;
-
-        // Should be closed
-        assert!(cb.is_available().await);
-        assert_eq!(cb.get_state().await, CircuitState::Closed);
-        assert_eq!(cb.get_failure_count().await, 0);
-    }
-
-    #[tokio::test]
-    async fn test_success_resets_failure_count_when_closed() {
-        let config = CircuitBreakerConfig {
-            failure_threshold: 3,
-            timeout: Duration::from_secs(60),
-            success_threshold: 2,
-        };
-        let cb = CircuitBreaker::with_config(config);
-
-        // Record some failures
-        cb.record_failure().await;
-        cb.record_failure().await;
-        assert_eq!(cb.get_failure_count().await, 2);
-
-        // Record success
-        cb.record_success().await;
-
-        // Failure count should reset
-        assert_eq!(cb.get_failure_count().await, 0);
-        assert_eq!(cb.get_state().await, CircuitState::Closed);
+        // In real usage with RealClock, time has "passed"
+        // This test shows the structure without hanging
     }
 }
