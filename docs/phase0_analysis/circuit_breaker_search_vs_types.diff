--- crates/riptide-search/src/circuit_breaker.rs	2025-11-05 12:15:32.277294135 +0000
+++ crates/riptide-types/src/reliability/circuit.rs	2025-11-07 17:44:20.520735328 +0000
@@ -1,461 +1,372 @@
-//! Circuit breaker implementation for search providers.
-//!
-//! This module provides circuit breaker functionality to protect against
-//! cascading failures when search providers become unavailable or unreliable.
-//!
-//! ## Relationship to Canonical Circuit Breaker
-//!
-//! This is a **specialized wrapper** for the `SearchProvider` trait. The canonical,
-//! production-ready circuit breaker lives in `riptide-types::reliability::circuit`.
-//!
-//! **Why this wrapper exists:**
-//! - Provides SearchProvider-specific integration
-//! - Percentage-based failure thresholds (more intuitive for search APIs)
-//! - Transparent wrapper pattern for any SearchProvider implementation
-//! - Health check passthrough (independent of circuit state)
-//!
-//! **Future work:** Could be refactored to use the canonical circuit breaker internally
-//! while maintaining the same public API. See `/docs/architecture/CIRCUIT_BREAKER_CONSOLIDATION_SUMMARY.md`
-
-use super::{SearchBackend, SearchHit, SearchProvider};
-use anyhow::Result;
-use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};
+use std::sync::atomic::{AtomicU32, AtomicU64, AtomicU8, Ordering::Relaxed};
 use std::sync::Arc;
-use std::time::{Duration, SystemTime, UNIX_EPOCH};
+use tokio::sync::{OwnedSemaphorePermit, Semaphore};
 
-/// Circuit breaker states following the standard pattern.
-#[derive(Debug, Clone, Copy, PartialEq, Eq)]
-pub enum CircuitState {
-    /// Circuit is closed, requests flow normally
-    Closed,
-    /// Circuit is open, all requests fail fast
-    Open,
-    /// Circuit is half-open, allowing test requests
-    HalfOpen,
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub enum State {
+    Closed = 0,
+    Open = 1,
+    HalfOpen = 2,
 }
 
-/// Configuration for the circuit breaker behavior.
-#[derive(Debug, Clone)]
-pub struct CircuitBreakerConfig {
-    /// Failure threshold percentage (0-100) to trigger circuit opening
-    pub failure_threshold_percentage: u32,
-    /// Minimum number of requests before circuit can open
-    pub minimum_request_threshold: u32,
-    /// Time to wait before attempting to close an open circuit
-    pub recovery_timeout: Duration,
-    /// Maximum number of test requests in half-open state
-    pub half_open_max_requests: u32,
-}
-
-impl Default for CircuitBreakerConfig {
-    fn default() -> Self {
-        Self {
-            failure_threshold_percentage: 50,
-            minimum_request_threshold: 5,
-            recovery_timeout: Duration::from_secs(60),
-            half_open_max_requests: 3,
+impl From<u8> for State {
+    fn from(v: u8) -> Self {
+        match v {
+            1 => State::Open,
+            2 => State::HalfOpen,
+            _ => State::Closed,
         }
     }
 }
 
-/// Metrics tracked by the circuit breaker for decision making.
-#[derive(Debug)]
-struct CircuitMetrics {
-    total_requests: AtomicU32,
-    failed_requests: AtomicU32,
-    last_failure_time: AtomicU64,
-    half_open_requests: AtomicU32,
-    half_open_failures: AtomicU32,
+#[derive(Clone, Debug)]
+pub struct Config {
+    pub failure_threshold: u32,       // N failures → Open
+    pub open_cooldown_ms: u64,        // time in Open
+    pub half_open_max_in_flight: u32, // number of trial calls allowed
 }
 
-impl CircuitMetrics {
-    fn new() -> Self {
+impl Default for Config {
+    fn default() -> Self {
         Self {
-            total_requests: AtomicU32::new(0),
-            failed_requests: AtomicU32::new(0),
-            last_failure_time: AtomicU64::new(0),
-            half_open_requests: AtomicU32::new(0),
-            half_open_failures: AtomicU32::new(0),
+            failure_threshold: 5,
+            open_cooldown_ms: 30_000,
+            half_open_max_in_flight: 3,
         }
     }
+}
 
-    fn record_success(&self) {
-        self.total_requests.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn record_failure(&self) {
-        self.total_requests.fetch_add(1, Ordering::Relaxed);
-        self.failed_requests.fetch_add(1, Ordering::Relaxed);
-
-        let now = SystemTime::now()
-            .duration_since(UNIX_EPOCH)
-            .unwrap_or_default()
-            .as_secs();
-        self.last_failure_time.store(now, Ordering::Relaxed);
-    }
-
-    fn record_half_open_success(&self) {
-        self.half_open_requests.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn record_half_open_failure(&self) {
-        self.half_open_requests.fetch_add(1, Ordering::Relaxed);
-        self.half_open_failures.fetch_add(1, Ordering::Relaxed);
-    }
-
-    fn failure_rate_percentage(&self) -> u32 {
-        let total = self.total_requests.load(Ordering::Relaxed);
-        let failed = self.failed_requests.load(Ordering::Relaxed);
-
-        if total == 0 {
-            return 0;
-        }
-
-        // Use saturating multiplication and checked division to prevent overflow/div-by-zero
-        // Division is safe because total > 0 (checked above), but we use checked_div for clippy
-        failed.saturating_mul(100).checked_div(total).unwrap_or(0)
-    }
-
-    fn should_trip(&self, config: &CircuitBreakerConfig) -> bool {
-        let total = self.total_requests.load(Ordering::Relaxed);
+pub trait Clock: Send + Sync + std::fmt::Debug {
+    fn now_ms(&self) -> u64;
+}
 
-        total >= config.minimum_request_threshold
-            && self.failure_rate_percentage() >= config.failure_threshold_percentage
-    }
+#[derive(Default, Debug)]
+pub struct RealClock;
 
-    fn can_attempt_reset(&self, config: &CircuitBreakerConfig) -> bool {
-        let last_failure = self.last_failure_time.load(Ordering::Relaxed);
-        let now = SystemTime::now()
+impl Clock for RealClock {
+    fn now_ms(&self) -> u64 {
+        use std::time::{SystemTime, UNIX_EPOCH};
+        let duration = SystemTime::now()
             .duration_since(UNIX_EPOCH)
-            .unwrap_or_default()
-            .as_secs();
-
-        // Use saturating subtraction to prevent underflow
-        now.saturating_sub(last_failure) >= config.recovery_timeout.as_secs()
-    }
-
-    fn reset(&self) {
-        self.total_requests.store(0, Ordering::Relaxed);
-        self.failed_requests.store(0, Ordering::Relaxed);
-        self.half_open_requests.store(0, Ordering::Relaxed);
-        self.half_open_failures.store(0, Ordering::Relaxed);
+            .unwrap_or_else(|e| {
+                tracing::error!("System time is before Unix epoch: {}", e);
+                // Fallback: return 0 for current time if system clock is broken
+                // This allows the circuit breaker to continue functioning
+                std::time::Duration::from_secs(0)
+            });
+
+        // Safe conversion: saturate to u64::MAX if duration exceeds u64 milliseconds
+        // This handles the theoretical case where as_millis() returns u128 > u64::MAX
+        u64::try_from(duration.as_millis()).unwrap_or(u64::MAX)
     }
 }
 
-/// Circuit breaker wrapper that adds reliability to search providers.
-///
-/// This wrapper monitors search provider health and can fail fast when
-/// providers become unreliable, preventing cascade failures and reducing
-/// response times during provider outages.
-///
-/// ## Behavior
-///
-/// - **Closed**: Normal operation, requests pass through
-/// - **Open**: All requests fail immediately with circuit breaker error
-/// - **Half-Open**: Limited test requests to check provider recovery
-///
-/// ## Configuration
-///
-/// The circuit breaker can be tuned for different failure scenarios:
-/// - API rate limiting (higher threshold, longer recovery)
-/// - Network issues (lower threshold, shorter recovery)
-/// - Service outages (balanced settings)
-pub struct CircuitBreakerWrapper {
-    provider: Box<dyn SearchProvider>,
-    config: CircuitBreakerConfig,
-    state: Arc<std::sync::RwLock<CircuitState>>,
-    metrics: Arc<CircuitMetrics>,
+#[derive(Debug)]
+pub struct CircuitBreaker {
+    state: AtomicU8,
+    failures: AtomicU32,
+    successes: AtomicU32,
+    open_until_ms: AtomicU64,
+    half_open_permits: Arc<Semaphore>,
+    cfg: Config,
+    clock: Arc<dyn Clock>,
 }
 
-impl CircuitBreakerWrapper {
-    /// Create a new circuit breaker wrapper with default configuration.
-    pub fn new(provider: Box<dyn SearchProvider>) -> Self {
-        Self::with_config(provider, CircuitBreakerConfig::default())
-    }
-
-    /// Create a new circuit breaker wrapper with custom configuration.
-    pub fn with_config(provider: Box<dyn SearchProvider>, config: CircuitBreakerConfig) -> Self {
-        Self {
-            provider,
-            config,
-            state: Arc::new(std::sync::RwLock::new(CircuitState::Closed)),
-            metrics: Arc::new(CircuitMetrics::new()),
-        }
-    }
-
-    /// Get the current circuit state for monitoring and debugging.
-    pub fn current_state(&self) -> CircuitState {
-        // If the lock is poisoned, we default to Open state for safety
-        *self.state.read().unwrap_or_else(|e| {
-            tracing::warn!("Circuit breaker state lock poisoned, defaulting to Open");
-            e.into_inner()
+impl CircuitBreaker {
+    pub fn new(cfg: Config, clock: Arc<dyn Clock>) -> Arc<Self> {
+        // Safe: u32 always fits in usize on all platforms (usize >= 16 bits)
+        let permit_count = cfg.half_open_max_in_flight as usize;
+
+        Arc::new(Self {
+            state: AtomicU8::new(State::Closed as u8),
+            failures: AtomicU32::new(0),
+            successes: AtomicU32::new(0),
+            open_until_ms: AtomicU64::new(0),
+            half_open_permits: Arc::new(Semaphore::new(permit_count)),
+            cfg,
+            clock,
         })
     }
 
-    /// Get current failure rate percentage for monitoring.
-    pub fn failure_rate(&self) -> u32 {
-        self.metrics.failure_rate_percentage()
+    #[inline]
+    pub fn state(&self) -> State {
+        self.state.load(Relaxed).into()
     }
 
-    /// Manually reset the circuit breaker (for testing or manual recovery).
-    pub fn reset(&self) {
-        self.metrics.reset();
-        // Handle poisoned lock by replacing it
-        if let Ok(mut state) = self.state.write() {
-            *state = CircuitState::Closed;
-        } else {
-            tracing::error!("Circuit breaker state lock poisoned during reset");
-        }
-    }
-
-    /// Check if a request can proceed based on current circuit state.
-    fn can_proceed(&self) -> Result<bool> {
-        let current_state = self.current_state();
-
-        match current_state {
-            CircuitState::Closed => Ok(true),
-            CircuitState::Open => {
-                // Check if we can transition to half-open
-                if self.metrics.can_attempt_reset(&self.config) {
-                    if let Ok(mut state) = self.state.write() {
-                        *state = CircuitState::HalfOpen;
-                        Ok(true)
-                    } else {
-                        tracing::error!(
-                            "Circuit breaker state lock poisoned, cannot transition to HalfOpen"
-                        );
-                        Ok(false)
-                    }
+    /// Returns Ok(permit_guard) if allowed to proceed; Err if short-circuited
+    pub fn try_acquire(&self) -> Result<Option<OwnedSemaphorePermit>, &'static str> {
+        match self.state() {
+            State::Closed => Ok(None),
+            State::Open => {
+                let now = self.clock.now_ms();
+                let open_until = self.open_until_ms.load(Relaxed);
+                if now >= open_until {
+                    // transition Open -> HalfOpen
+                    self.state.store(State::HalfOpen as u8, Relaxed);
                 } else {
-                    Ok(false)
+                    return Err("circuit open");
                 }
+                // fallthrough to HalfOpen path
+                self.try_acquire()
             }
-            CircuitState::HalfOpen => {
-                // Allow limited requests in half-open state
-                let half_open_requests = self.metrics.half_open_requests.load(Ordering::Relaxed);
-                Ok(half_open_requests < self.config.half_open_max_requests)
-            }
+            State::HalfOpen => match Arc::clone(&self.half_open_permits).try_acquire_owned() {
+                Ok(permit) => Ok(Some(permit)),
+                Err(_) => Err("half-open saturated"),
+            },
         }
     }
 
-    /// Handle the result of a request and update circuit state accordingly.
-    fn handle_result<T>(&self, result: &Result<T>) {
-        let current_state = self.current_state();
-
-        match result {
-            Ok(_) => {
-                match current_state {
-                    CircuitState::Closed => {
-                        self.metrics.record_success();
-                    }
-                    CircuitState::HalfOpen => {
-                        self.metrics.record_half_open_success();
-
-                        // If we've had enough successful half-open requests, close the circuit
-                        let half_open_requests =
-                            self.metrics.half_open_requests.load(Ordering::Relaxed);
-                        let half_open_failures =
-                            self.metrics.half_open_failures.load(Ordering::Relaxed);
-
-                        if half_open_requests >= self.config.half_open_max_requests
-                            && half_open_failures == 0
-                        {
-                            if let Ok(mut state) = self.state.write() {
-                                *state = CircuitState::Closed;
-                                self.metrics.reset();
-                            }
-                        }
-                    }
-                    CircuitState::Open => {
-                        // This shouldn't happen, but if it does, we can close the circuit
-                        if let Ok(mut state) = self.state.write() {
-                            *state = CircuitState::Closed;
-                            self.metrics.reset();
-                        }
-                    }
-                }
+    #[inline]
+    pub fn on_success(&self) {
+        match self.state() {
+            State::Closed => {
+                self.failures.store(0, Relaxed);
             }
-            Err(_) => {
-                match current_state {
-                    CircuitState::Closed => {
-                        self.metrics.record_failure();
-
-                        // Check if we should open the circuit
-                        if self.metrics.should_trip(&self.config) {
-                            if let Ok(mut state) = self.state.write() {
-                                *state = CircuitState::Open;
-                            }
-                        }
-                    }
-                    CircuitState::HalfOpen => {
-                        self.metrics.record_half_open_failure();
-
-                        // Any failure in half-open immediately opens the circuit
-                        if let Ok(mut state) = self.state.write() {
-                            *state = CircuitState::Open;
-                        }
-                    }
-                    CircuitState::Open => {
-                        // Already open, just update failure time
-                        self.metrics.record_failure();
+            State::HalfOpen => {
+                let succ = self.successes.fetch_add(1, Relaxed) + 1;
+                if succ >= 1 {
+                    // First success closes the circuit and fully resets
+                    self.state.store(State::Closed as u8, Relaxed);
+                    self.failures.store(0, Relaxed);
+                    self.successes.store(0, Relaxed);
+                    // refill semaphore (in case previous failures consumed)
+                    // Safe: u32 always fits in usize on all platforms
+                    let def = self.cfg.half_open_max_in_flight as usize;
+                    let deficit = def.saturating_sub(self.half_open_permits.available_permits());
+                    if deficit > 0 {
+                        self.half_open_permits.add_permits(deficit);
                     }
                 }
             }
+            State::Open => {} // shouldn't happen; guarded by try_acquire
         }
     }
-}
 
-#[async_trait::async_trait]
-impl SearchProvider for CircuitBreakerWrapper {
-    async fn search(
-        &self,
-        query: &str,
-        limit: u32,
-        country: &str,
-        locale: &str,
-    ) -> Result<Vec<SearchHit>> {
-        // Check if the circuit allows this request
-        if !self.can_proceed()? {
-            return Err(anyhow::anyhow!(
-                "Search provider circuit breaker is OPEN. Provider is currently unavailable. Failure rate: {}%",
-                self.failure_rate()
-            ));
+    #[inline]
+    pub fn on_failure(&self) {
+        match self.state() {
+            State::Closed => {
+                let f = self.failures.fetch_add(1, Relaxed) + 1;
+                if f >= self.cfg.failure_threshold {
+                    self.trip_open();
+                }
+            }
+            State::HalfOpen => {
+                // immediate reopen on any failure in half-open
+                self.trip_open();
+            }
+            State::Open => {}
         }
-
-        // Execute the search request
-        let result = self.provider.search(query, limit, country, locale).await;
-
-        // Update circuit state based on result
-        self.handle_result(&result);
-
-        result
     }
 
-    fn backend_type(&self) -> SearchBackend {
-        self.provider.backend_type()
+    #[inline]
+    fn trip_open(&self) {
+        self.state.store(State::Open as u8, Relaxed);
+        self.successes.store(0, Relaxed);
+        self.failures.store(0, Relaxed);
+        let until = self.clock.now_ms() + self.cfg.open_cooldown_ms;
+        self.open_until_ms.store(until, Relaxed);
+        // reset half-open permits for the next time we enter HalfOpen
+        // Safe: u32 always fits in usize on all platforms
+        let def = self.cfg.half_open_max_in_flight as usize;
+        let avail = self.half_open_permits.available_permits();
+        if avail < def {
+            self.half_open_permits.add_permits(def - avail);
+        }
     }
 
-    async fn health_check(&self) -> Result<()> {
-        // Always allow health checks, but don't count them in circuit breaker metrics
-        // This allows external monitoring to determine provider health independently
-        self.provider.health_check().await
+    pub fn failure_count(&self) -> u32 {
+        self.failures.load(Relaxed)
     }
 }
 
-impl std::fmt::Debug for CircuitBreakerWrapper {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        f.debug_struct("CircuitBreakerWrapper")
-            .field("backend_type", &self.provider.backend_type())
-            .field("state", &self.current_state())
-            .field("failure_rate", &self.failure_rate())
-            .field("config", &self.config)
-            .finish()
+/// Helper function to wrap async calls with circuit breaker protection
+pub async fn guarded_call<T, E, F, Fut>(cb: &Arc<CircuitBreaker>, f: F) -> Result<T, anyhow::Error>
+where
+    F: FnOnce() -> Fut,
+    Fut: std::future::Future<Output = Result<T, E>>,
+    E: Into<anyhow::Error>,
+{
+    let permit = cb
+        .try_acquire()
+        .map_err(|msg| anyhow::anyhow!("Circuit breaker rejected: {}", msg))?;
+
+    let res = f().await;
+    match &res {
+        Ok(_) => cb.on_success(),
+        Err(_) => cb.on_failure(),
     }
+    drop(permit); // releases half-open permit if any
+    res.map_err(Into::into)
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::none_provider::NoneProvider;
+    use std::sync::atomic::AtomicU64;
+
+    #[derive(Default, Debug)]
+    struct TestClock {
+        now: AtomicU64,
+    }
+
+    impl TestClock {
+        fn advance(&self, ms: u64) {
+            self.now.fetch_add(ms, Relaxed);
+        }
 
-    #[tokio::test]
-    async fn test_circuit_breaker_closed_state() {
-        let provider = Box::new(NoneProvider::new(true));
-        let circuit = CircuitBreakerWrapper::new(provider);
-
-        assert_eq!(circuit.current_state(), CircuitState::Closed);
-        assert!(circuit.can_proceed().unwrap());
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_success_flow() {
-        let provider = Box::new(NoneProvider::new(true));
-        let circuit = CircuitBreakerWrapper::new(provider);
-
-        // Successful request should not affect circuit state
-        let result = circuit.search("https://example.com", 1, "us", "en").await;
-        assert!(result.is_ok());
-        assert_eq!(circuit.current_state(), CircuitState::Closed);
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_failure_threshold() {
-        let provider = Box::new(NoneProvider::new(true));
-        let config = CircuitBreakerConfig {
-            failure_threshold_percentage: 50,
-            minimum_request_threshold: 2,
-            recovery_timeout: Duration::from_secs(300), // Long timeout to prevent auto-recovery during test
-            half_open_max_requests: 1,
-        };
-        let circuit = CircuitBreakerWrapper::with_config(provider, config);
-
-        // Generate intentional failures to trip the circuit breaker
-        // These searches contain invalid input to trigger the failure threshold
-        let _fail1_result = circuit.search("no urls here", 1, "us", "en").await;
-        let _fail2_result = circuit.search("still no urls", 1, "us", "en").await;
-
-        // Circuit should now be open due to 100% failure rate
-        assert_eq!(circuit.current_state(), CircuitState::Open);
-
-        // Next request should fail fast (recovery timeout hasn't elapsed)
-        let result = circuit.search("https://example.com", 1, "us", "en").await;
-        assert!(result.is_err());
-        assert!(result
-            .unwrap_err()
-            .to_string()
-            .contains("circuit breaker is OPEN"));
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_recovery() {
-        let provider = Box::new(NoneProvider::new(true));
-        let config = CircuitBreakerConfig {
-            failure_threshold_percentage: 50,
-            minimum_request_threshold: 2,
-            recovery_timeout: Duration::from_millis(50),
-            half_open_max_requests: 1,
-        };
-        let circuit = CircuitBreakerWrapper::with_config(provider, config);
-
-        // Trip the circuit breaker with intentional failures
-        // These invalid queries are expected to fail and open the circuit
-        let _fail1_result = circuit.search("no urls", 1, "us", "en").await;
-        let _fail2_result = circuit.search("no urls", 1, "us", "en").await;
-        assert_eq!(circuit.current_state(), CircuitState::Open);
-
-        // Wait for recovery timeout
-        tokio::time::sleep(Duration::from_millis(60)).await;
-
-        // Next request should transition to half-open and succeed
-        let result = circuit.search("https://example.com", 1, "us", "en").await;
-        assert!(result.is_ok());
+        #[allow(dead_code)]
+        fn set(&self, ms: u64) {
+            self.now.store(ms, Relaxed);
+        }
+    }
 
-        // Circuit should close after successful half-open request
-        assert_eq!(circuit.current_state(), CircuitState::Closed);
+    impl Clock for TestClock {
+        fn now_ms(&self) -> u64 {
+            self.now.load(Relaxed)
+        }
     }
 
     #[test]
-    fn test_circuit_metrics() {
-        let metrics = CircuitMetrics::new();
+    fn circuit_transitions_closed_open_halfopen_closed() {
+        let clock = Arc::new(TestClock::default());
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 3,
+                open_cooldown_ms: 5_000,
+                half_open_max_in_flight: 2,
+            },
+            clock.clone(),
+        );
+
+        // Initial state is Closed
+        assert_eq!(cb.state(), State::Closed);
+        assert!(cb.try_acquire().unwrap().is_none());
+
+        // 3 failures → Open
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Closed);
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Closed);
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Should reject while cool-down not elapsed
+        assert!(cb.try_acquire().is_err());
+
+        // Advance time to exit Open
+        clock.advance(5_000);
+
+        // First acquire transitions to HalfOpen and grants a permit
+        let permit = cb.try_acquire().expect("should get permit");
+        assert!(permit.is_some());
+        assert_eq!(cb.state(), State::HalfOpen);
+
+        // Success closes
+        cb.on_success();
+        assert_eq!(cb.state(), State::Closed);
+    }
 
-        // Initial state
-        assert_eq!(metrics.failure_rate_percentage(), 0);
+    #[test]
+    fn half_open_failure_reopens_immediately() {
+        let clock = Arc::new(TestClock::default());
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 2,
+                open_cooldown_ms: 1_000,
+                half_open_max_in_flight: 1,
+            },
+            clock.clone(),
+        );
+
+        // Trip to Open
+        cb.on_failure();
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Advance time and transition to HalfOpen
+        clock.advance(1_000);
+        // RAII guard: must remain in scope to transition circuit breaker state
+        let _permit = cb.try_acquire().expect("should get permit");
+        assert_eq!(cb.state(), State::HalfOpen);
+
+        // Failure in HalfOpen immediately reopens
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Should need to wait again
+        assert!(cb.try_acquire().is_err());
+
+        // After another cooldown
+        clock.advance(1_000);
+        assert!(cb.try_acquire().is_ok());
+    }
 
-        // Record some requests
-        metrics.record_success();
-        metrics.record_success();
-        metrics.record_failure();
-
-        // Should be 33% failure rate (1 failure out of 3 total)
-        assert_eq!(metrics.failure_rate_percentage(), 33);
-
-        // Test should_trip logic
-        let config = CircuitBreakerConfig {
-            minimum_request_threshold: 3,
-            failure_threshold_percentage: 30,
-            ..Default::default()
-        };
+    #[test]
+    fn half_open_respects_max_permits() {
+        let clock = Arc::new(TestClock::default());
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 1,
+                open_cooldown_ms: 100,
+                half_open_max_in_flight: 2,
+            },
+            clock.clone(),
+        );
+
+        // Trip to Open
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Advance time and transition to HalfOpen
+        clock.advance(100);
+
+        // Should allow exactly 2 permits
+        let p1 = cb.try_acquire().expect("first permit");
+        assert!(p1.is_some());
+        assert_eq!(cb.state(), State::HalfOpen);
+
+        let p2 = cb.try_acquire().expect("second permit");
+        assert!(p2.is_some());
+
+        // Third should be rejected (saturated)
+        assert!(cb.try_acquire().is_err());
+
+        // Release one permit and try again
+        drop(p1);
+
+        // Now should get another permit after dropping
+        let p3 = cb.try_acquire().expect("third permit after release");
+        assert!(p3.is_some());
+    }
+
+    #[tokio::test(start_paused = true)]
+    async fn circuit_breaker_with_tokio_time() {
+        use std::time::Duration;
+
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 3,
+                open_cooldown_ms: 5_000,
+                half_open_max_in_flight: 2,
+            },
+            Arc::new(RealClock),
+        );
+
+        // Note: with start_paused = true, we control time advancement
+        assert_eq!(cb.state(), State::Closed);
+
+        // Trip to Open
+        cb.on_failure();
+        cb.on_failure();
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Can't use try_acquire with RealClock in paused time directly,
+        // but we demonstrate the pattern
+        tokio::time::advance(Duration::from_millis(5_000)).await;
 
-        assert!(metrics.should_trip(&config));
+        // In real usage with RealClock, time has "passed"
+        // This test shows the structure without hanging
     }
 }
