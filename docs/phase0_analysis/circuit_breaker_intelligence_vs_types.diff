--- crates/riptide-intelligence/src/circuit_breaker.rs	2025-11-05 12:15:32.176294142 +0000
+++ crates/riptide-types/src/reliability/circuit.rs	2025-11-07 17:44:20.520735328 +0000
@@ -1,579 +1,372 @@
-//! Circuit breaker implementation with multi-signal support and 1 repair retry maximum
-//!
-//! ## Relationship to Canonical Circuit Breaker
-//!
-//! This is a **specialized domain-specific wrapper** for LLM providers. The canonical,
-//! lock-free circuit breaker lives in `riptide-types::reliability::circuit`.
-//!
-//! **Why this specialized version exists:**
-//! - Wraps `Arc<dyn LlmProvider>` with transparent circuit breaker behavior
-//! - Implements repair attempt limiting (hard requirement: max 1 retry)
-//! - Uses time-windowed failure tracking (not just counters)
-//! - Provides detailed `CircuitBreakerStats` for LLM monitoring
-//! - Implements the `LlmProvider` trait itself (transparent wrapper pattern)
-//! - Multi-tier configurations: `new()`, `strict()`, `lenient()`
-//!
-//! **Design decision:** Kept as specialized implementation due to domain-specific requirements.
-//! See `/docs/architecture/CIRCUIT_BREAKER_CONSOLIDATION_SUMMARY.md` for full analysis.
-
-use async_trait::async_trait;
-use parking_lot::RwLock;
-use serde::{Deserialize, Serialize};
+use std::sync::atomic::{AtomicU32, AtomicU64, AtomicU8, Ordering::Relaxed};
 use std::sync::Arc;
-use std::time::{Duration, Instant};
-use tracing::{error, info, warn};
+use tokio::sync::{OwnedSemaphorePermit, Semaphore};
 
-use crate::{
-    CompletionRequest, CompletionResponse, Cost, IntelligenceError, LlmCapabilities, LlmProvider,
-    Result,
-};
-
-/// Circuit breaker state
-#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
-pub enum CircuitState {
-    /// Circuit is closed - requests pass through normally
-    Closed,
-    /// Circuit is open - requests are rejected immediately
-    Open,
-    /// Circuit is half-open - limited requests are allowed to test recovery
-    HalfOpen,
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub enum State {
+    Closed = 0,
+    Open = 1,
+    HalfOpen = 2,
 }
 
-/// Configuration for circuit breaker behavior
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct CircuitBreakerConfig {
-    /// Number of failures before opening the circuit
-    pub failure_threshold: u32,
-    /// Time window for counting failures (seconds)
-    pub failure_window_secs: u64,
-    /// Minimum number of requests before circuit can open
-    pub min_request_threshold: u32,
-    /// Time to wait before transitioning from Open to HalfOpen
-    pub recovery_timeout_secs: u64,
-    /// Maximum number of repair attempts (hard limit of 1 per requirement)
-    pub max_repair_attempts: u32,
-    /// Success rate threshold for closing circuit in HalfOpen state
-    pub success_rate_threshold: f32,
-    /// Number of requests to allow in HalfOpen state
-    pub half_open_max_requests: u32,
-}
-
-impl CircuitBreakerConfig {
-    /// Create a new configuration with safe defaults
-    pub fn new() -> Self {
-        Self {
-            failure_threshold: 5,
-            failure_window_secs: 60,
-            min_request_threshold: 10,
-            recovery_timeout_secs: 30,
-            max_repair_attempts: 1, // Hard requirement limit
-            success_rate_threshold: 0.7,
-            half_open_max_requests: 3,
+impl From<u8> for State {
+    fn from(v: u8) -> Self {
+        match v {
+            1 => State::Open,
+            2 => State::HalfOpen,
+            _ => State::Closed,
         }
     }
+}
 
-    /// Create a strict configuration for testing
-    pub fn strict() -> Self {
-        Self {
-            failure_threshold: 3,
-            failure_window_secs: 30,
-            min_request_threshold: 5,
-            recovery_timeout_secs: 15,
-            max_repair_attempts: 1,
-            success_rate_threshold: 0.8,
-            half_open_max_requests: 2,
-        }
-    }
+#[derive(Clone, Debug)]
+pub struct Config {
+    pub failure_threshold: u32,       // N failures → Open
+    pub open_cooldown_ms: u64,        // time in Open
+    pub half_open_max_in_flight: u32, // number of trial calls allowed
+}
 
-    /// Create a lenient configuration for stable environments
-    pub fn lenient() -> Self {
+impl Default for Config {
+    fn default() -> Self {
         Self {
-            failure_threshold: 10,
-            failure_window_secs: 120,
-            min_request_threshold: 20,
-            recovery_timeout_secs: 60,
-            max_repair_attempts: 1,
-            success_rate_threshold: 0.6,
-            half_open_max_requests: 5,
+            failure_threshold: 5,
+            open_cooldown_ms: 30_000,
+            half_open_max_in_flight: 3,
         }
     }
 }
 
-impl Default for CircuitBreakerConfig {
-    fn default() -> Self {
-        Self::new()
-    }
+pub trait Clock: Send + Sync + std::fmt::Debug {
+    fn now_ms(&self) -> u64;
 }
 
-/// Statistics for monitoring circuit breaker behavior
-#[derive(Debug, Clone, Serialize, Deserialize)]
-pub struct CircuitBreakerStats {
-    pub state: CircuitState,
-    pub total_requests: u64,
-    pub successful_requests: u64,
-    pub failed_requests: u64,
-    pub circuit_opens: u64,
-    pub repair_attempts: u32,
-    #[serde(skip)]
-    pub last_failure_time: Option<Instant>,
-    #[serde(skip)]
-    pub last_success_time: Option<Instant>,
-    pub current_failure_count: u32,
-}
+#[derive(Default, Debug)]
+pub struct RealClock;
 
-impl CircuitBreakerStats {
-    fn new() -> Self {
-        Self {
-            state: CircuitState::Closed,
-            total_requests: 0,
-            successful_requests: 0,
-            failed_requests: 0,
-            circuit_opens: 0,
-            repair_attempts: 0,
-            last_failure_time: None,
-            last_success_time: None,
-            current_failure_count: 0,
-        }
-    }
+impl Clock for RealClock {
+    fn now_ms(&self) -> u64 {
+        use std::time::{SystemTime, UNIX_EPOCH};
+        let duration = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .unwrap_or_else(|e| {
+                tracing::error!("System time is before Unix epoch: {}", e);
+                // Fallback: return 0 for current time if system clock is broken
+                // This allows the circuit breaker to continue functioning
+                std::time::Duration::from_secs(0)
+            });
 
-    fn success_rate(&self) -> f32 {
-        if self.total_requests == 0 {
-            1.0
-        } else {
-            self.successful_requests as f32 / self.total_requests as f32
-        }
+        // Safe conversion: saturate to u64::MAX if duration exceeds u64 milliseconds
+        // This handles the theoretical case where as_millis() returns u128 > u64::MAX
+        u64::try_from(duration.as_millis()).unwrap_or(u64::MAX)
     }
 }
 
-/// Internal state of the circuit breaker
 #[derive(Debug)]
-struct CircuitBreakerState {
-    config: CircuitBreakerConfig,
-    stats: CircuitBreakerStats,
-    state_change_time: Instant,
-    half_open_requests: u32,
-    recent_failures: Vec<Instant>,
+pub struct CircuitBreaker {
+    state: AtomicU8,
+    failures: AtomicU32,
+    successes: AtomicU32,
+    open_until_ms: AtomicU64,
+    half_open_permits: Arc<Semaphore>,
+    cfg: Config,
+    clock: Arc<dyn Clock>,
 }
 
-impl CircuitBreakerState {
-    fn new(config: CircuitBreakerConfig) -> Self {
-        Self {
-            config,
-            stats: CircuitBreakerStats::new(),
-            state_change_time: Instant::now(),
-            half_open_requests: 0,
-            recent_failures: Vec::new(),
-        }
-    }
-
-    /// Check if circuit should transition to open state
-    fn should_open(&mut self) -> bool {
-        // Clean old failures outside the window
-        let cutoff = Instant::now() - Duration::from_secs(self.config.failure_window_secs);
-        self.recent_failures.retain(|&time| time > cutoff);
-
-        // Check thresholds
-        self.stats.total_requests >= self.config.min_request_threshold as u64
-            && self.recent_failures.len() >= self.config.failure_threshold as usize
-    }
-
-    /// Check if circuit should transition to half-open state
-    fn should_half_open(&self) -> bool {
-        matches!(self.stats.state, CircuitState::Open)
-            && self.state_change_time.elapsed().as_secs() >= self.config.recovery_timeout_secs
-    }
-
-    /// Check if circuit should close from half-open state
-    fn should_close_from_half_open(&self) -> bool {
-        matches!(self.stats.state, CircuitState::HalfOpen)
-            && self.half_open_requests >= self.config.half_open_max_requests
-            && self.stats.success_rate() >= self.config.success_rate_threshold
-    }
-
-    /// Record a successful request
-    fn record_success(&mut self) {
-        self.stats.total_requests += 1;
-        self.stats.successful_requests += 1;
-        self.stats.last_success_time = Some(Instant::now());
-
-        if self.stats.state == CircuitState::HalfOpen {
-            self.half_open_requests += 1;
-            if self.should_close_from_half_open() {
-                self.transition_to_closed();
-            }
-        }
+impl CircuitBreaker {
+    pub fn new(cfg: Config, clock: Arc<dyn Clock>) -> Arc<Self> {
+        // Safe: u32 always fits in usize on all platforms (usize >= 16 bits)
+        let permit_count = cfg.half_open_max_in_flight as usize;
+
+        Arc::new(Self {
+            state: AtomicU8::new(State::Closed as u8),
+            failures: AtomicU32::new(0),
+            successes: AtomicU32::new(0),
+            open_until_ms: AtomicU64::new(0),
+            half_open_permits: Arc::new(Semaphore::new(permit_count)),
+            cfg,
+            clock,
+        })
+    }
+
+    #[inline]
+    pub fn state(&self) -> State {
+        self.state.load(Relaxed).into()
     }
 
-    /// Record a failed request
-    fn record_failure(&mut self) {
-        self.stats.total_requests += 1;
-        self.stats.failed_requests += 1;
-        self.stats.current_failure_count += 1;
-        let now = Instant::now();
-        self.stats.last_failure_time = Some(now);
-        self.recent_failures.push(now);
-
-        match self.stats.state {
-            CircuitState::Closed => {
-                if self.should_open() {
-                    self.transition_to_open();
+    /// Returns Ok(permit_guard) if allowed to proceed; Err if short-circuited
+    pub fn try_acquire(&self) -> Result<Option<OwnedSemaphorePermit>, &'static str> {
+        match self.state() {
+            State::Closed => Ok(None),
+            State::Open => {
+                let now = self.clock.now_ms();
+                let open_until = self.open_until_ms.load(Relaxed);
+                if now >= open_until {
+                    // transition Open -> HalfOpen
+                    self.state.store(State::HalfOpen as u8, Relaxed);
+                } else {
+                    return Err("circuit open");
                 }
+                // fallthrough to HalfOpen path
+                self.try_acquire()
             }
-            CircuitState::HalfOpen => {
-                // Any failure in half-open state opens the circuit again
-                self.transition_to_open();
-            }
-            CircuitState::Open => {
-                // Already open, nothing to do
-            }
+            State::HalfOpen => match Arc::clone(&self.half_open_permits).try_acquire_owned() {
+                Ok(permit) => Ok(Some(permit)),
+                Err(_) => Err("half-open saturated"),
+            },
         }
     }
 
-    /// Transition to open state
-    fn transition_to_open(&mut self) {
-        info!("Circuit breaker opening due to failures");
-        self.stats.state = CircuitState::Open;
-        self.stats.circuit_opens += 1;
-        self.state_change_time = Instant::now();
-        self.half_open_requests = 0;
-    }
-
-    /// Transition to half-open state
-    fn transition_to_half_open(&mut self) {
-        if self.stats.repair_attempts >= self.config.max_repair_attempts {
-            warn!(
-                "Maximum repair attempts ({}) reached, keeping circuit open",
-                self.config.max_repair_attempts
-            );
-            return;
-        }
-
-        info!("Circuit breaker transitioning to half-open for repair attempt");
-        self.stats.state = CircuitState::HalfOpen;
-        self.stats.repair_attempts += 1;
-        self.state_change_time = Instant::now();
-        self.half_open_requests = 0;
-    }
-
-    /// Transition to closed state
-    fn transition_to_closed(&mut self) {
-        info!("Circuit breaker closing - service recovered");
-        self.stats.state = CircuitState::Closed;
-        self.state_change_time = Instant::now();
-        self.half_open_requests = 0;
-        self.stats.current_failure_count = 0;
-        self.recent_failures.clear();
-    }
-
-    /// Check current state and perform transitions if needed
-    fn update_state(&mut self) {
-        match self.stats.state {
-            CircuitState::Open => {
-                if self.should_half_open() {
-                    self.transition_to_half_open();
-                }
-            }
-            CircuitState::HalfOpen => {
-                // Transitions are handled in record_success/record_failure
+    #[inline]
+    pub fn on_success(&self) {
+        match self.state() {
+            State::Closed => {
+                self.failures.store(0, Relaxed);
             }
-            CircuitState::Closed => {
-                // Transitions are handled in record_failure
+            State::HalfOpen => {
+                let succ = self.successes.fetch_add(1, Relaxed) + 1;
+                if succ >= 1 {
+                    // First success closes the circuit and fully resets
+                    self.state.store(State::Closed as u8, Relaxed);
+                    self.failures.store(0, Relaxed);
+                    self.successes.store(0, Relaxed);
+                    // refill semaphore (in case previous failures consumed)
+                    // Safe: u32 always fits in usize on all platforms
+                    let def = self.cfg.half_open_max_in_flight as usize;
+                    let deficit = def.saturating_sub(self.half_open_permits.available_permits());
+                    if deficit > 0 {
+                        self.half_open_permits.add_permits(deficit);
+                    }
+                }
             }
+            State::Open => {} // shouldn't happen; guarded by try_acquire
         }
     }
 
-    /// Check if a request should be allowed
-    fn should_allow_request(&mut self) -> bool {
-        self.update_state();
-
-        match self.stats.state {
-            CircuitState::Closed => true,
-            CircuitState::Open => false,
-            CircuitState::HalfOpen => self.half_open_requests < self.config.half_open_max_requests,
-        }
-    }
-}
-
-/// Circuit breaker wrapper for LLM providers
-pub struct CircuitBreaker {
-    inner: Arc<dyn LlmProvider>,
-    state: Arc<RwLock<CircuitBreakerState>>,
-}
-
-impl CircuitBreaker {
-    /// Create a new circuit breaker with default configuration
-    pub fn new(provider: Arc<dyn LlmProvider>) -> Self {
-        Self::with_config(provider, CircuitBreakerConfig::default())
-    }
-
-    /// Create a new circuit breaker with custom configuration
-    pub fn with_config(provider: Arc<dyn LlmProvider>, config: CircuitBreakerConfig) -> Self {
-        Self {
-            inner: provider,
-            state: Arc::new(RwLock::new(CircuitBreakerState::new(config))),
-        }
-    }
-
-    /// Get current circuit state
-    pub fn state(&self) -> CircuitState {
-        self.state.read().stats.state.clone()
-    }
-
-    /// Get circuit breaker statistics
-    pub fn stats(&self) -> CircuitBreakerStats {
-        self.state.read().stats.clone()
-    }
-
-    /// Manually reset the circuit breaker
-    pub fn reset(&self) {
-        let mut state = self.state.write();
-        state.transition_to_closed();
-        info!("Circuit breaker manually reset");
-    }
-
-    /// Check if provider is healthy and update circuit state accordingly
-    pub async fn health_check(&self) -> Result<()> {
-        match self.inner.health_check().await {
-            Ok(_) => {
-                let state = self.state.read();
-                // Don't record as success to avoid skewing stats, but note the health
-                if matches!(state.stats.state, CircuitState::Open) {
-                    // Optionally transition to half-open if health check passes
-                    // This is a policy decision - some implementations might not do this
+    #[inline]
+    pub fn on_failure(&self) {
+        match self.state() {
+            State::Closed => {
+                let f = self.failures.fetch_add(1, Relaxed) + 1;
+                if f >= self.cfg.failure_threshold {
+                    self.trip_open();
                 }
-                Ok(())
             }
-            Err(e) => {
-                // Don't record as failure for health checks to avoid skewing stats
-                Err(e)
+            State::HalfOpen => {
+                // immediate reopen on any failure in half-open
+                self.trip_open();
             }
+            State::Open => {}
         }
     }
 
-    /// Force open the circuit (for testing or emergency situations)
-    pub fn force_open(&self) {
-        let mut state = self.state.write();
-        state.transition_to_open();
-        warn!("Circuit breaker forced open");
-    }
-
-    /// Get the wrapped provider
-    pub fn inner(&self) -> &Arc<dyn LlmProvider> {
-        &self.inner
-    }
-
-    /// Execute a request with circuit breaker protection
-    async fn execute_with_circuit<F, T>(&self, operation: F) -> Result<T>
-    where
-        F: std::future::Future<Output = Result<T>>,
-    {
-        // Check if request should be allowed
-        {
-            let mut state = self.state.write();
-            if !state.should_allow_request() {
-                return Err(IntelligenceError::CircuitOpen {
-                    reason: format!(
-                        "Circuit breaker is {} (failures: {}, repair attempts: {}/{})",
-                        match state.stats.state {
-                            CircuitState::Open => "OPEN",
-                            CircuitState::HalfOpen => "HALF_OPEN (max requests reached)",
-                            CircuitState::Closed => "CLOSED", // Shouldn't happen
-                        },
-                        state.stats.failed_requests,
-                        state.stats.repair_attempts,
-                        state.config.max_repair_attempts
-                    ),
-                });
-            }
-        }
-
-        // Execute the operation
-        match operation.await {
-            Ok(result) => {
-                let mut state = self.state.write();
-                state.record_success();
-                Ok(result)
-            }
-            Err(error) => {
-                let mut state = self.state.write();
-                state.record_failure();
-                error!(
-                    "Request failed, circuit breaker stats: state={:?}, failures={}, repair_attempts={}/{}",
-                    state.stats.state,
-                    state.stats.failed_requests,
-                    state.stats.repair_attempts,
-                    state.config.max_repair_attempts
-                );
-                Err(error)
-            }
+    #[inline]
+    fn trip_open(&self) {
+        self.state.store(State::Open as u8, Relaxed);
+        self.successes.store(0, Relaxed);
+        self.failures.store(0, Relaxed);
+        let until = self.clock.now_ms() + self.cfg.open_cooldown_ms;
+        self.open_until_ms.store(until, Relaxed);
+        // reset half-open permits for the next time we enter HalfOpen
+        // Safe: u32 always fits in usize on all platforms
+        let def = self.cfg.half_open_max_in_flight as usize;
+        let avail = self.half_open_permits.available_permits();
+        if avail < def {
+            self.half_open_permits.add_permits(def - avail);
         }
     }
-}
-
-#[async_trait]
-impl LlmProvider for CircuitBreaker {
-    async fn complete(&self, request: CompletionRequest) -> Result<CompletionResponse> {
-        self.execute_with_circuit(self.inner.complete(request))
-            .await
-    }
-
-    async fn embed(&self, text: &str) -> Result<Vec<f32>> {
-        self.execute_with_circuit(self.inner.embed(text)).await
-    }
 
-    fn capabilities(&self) -> LlmCapabilities {
-        self.inner.capabilities()
-    }
-
-    fn estimate_cost(&self, tokens: usize) -> Cost {
-        self.inner.estimate_cost(tokens)
-    }
-
-    async fn health_check(&self) -> Result<()> {
-        self.health_check().await
-    }
-
-    fn name(&self) -> &str {
-        self.inner.name()
-    }
-
-    async fn is_available(&self) -> bool {
-        match self.state() {
-            CircuitState::Closed => self.inner.is_available().await,
-            CircuitState::Open => false,
-            CircuitState::HalfOpen => {
-                // In half-open state, check if we can still accept requests
-                let state = self.state.read();
-                state.half_open_requests < state.config.half_open_max_requests
-            }
-        }
+    pub fn failure_count(&self) -> u32 {
+        self.failures.load(Relaxed)
     }
 }
 
-/// Helper function to wrap a provider with default circuit breaker
-pub fn with_circuit_breaker(provider: Arc<dyn LlmProvider>) -> CircuitBreaker {
-    CircuitBreaker::new(provider)
-}
+/// Helper function to wrap async calls with circuit breaker protection
+pub async fn guarded_call<T, E, F, Fut>(cb: &Arc<CircuitBreaker>, f: F) -> Result<T, anyhow::Error>
+where
+    F: FnOnce() -> Fut,
+    Fut: std::future::Future<Output = Result<T, E>>,
+    E: Into<anyhow::Error>,
+{
+    let permit = cb
+        .try_acquire()
+        .map_err(|msg| anyhow::anyhow!("Circuit breaker rejected: {}", msg))?;
 
-/// Helper function to wrap a provider with custom circuit breaker config
-pub fn with_custom_circuit_breaker(
-    provider: Arc<dyn LlmProvider>,
-    config: CircuitBreakerConfig,
-) -> CircuitBreaker {
-    CircuitBreaker::with_config(provider, config)
+    let res = f().await;
+    match &res {
+        Ok(_) => cb.on_success(),
+        Err(_) => cb.on_failure(),
+    }
+    drop(permit); // releases half-open permit if any
+    res.map_err(Into::into)
 }
 
-#[cfg(all(test, feature = "mock"))]
+#[cfg(test)]
 mod tests {
     use super::*;
-    use crate::mock_provider::MockLlmProvider;
-    use crate::provider::Message;
-
-    #[tokio::test]
-    async fn test_circuit_breaker_closed_state() {
-        let mock_provider = Arc::new(MockLlmProvider::new());
-        let circuit_breaker = CircuitBreaker::new(mock_provider);
-
-        assert_eq!(circuit_breaker.state(), CircuitState::Closed);
-
-        let request = CompletionRequest::new("mock-gpt-3.5", vec![Message::user("Hello")]);
-
-        let result = circuit_breaker.complete(request).await;
-        assert!(result.is_ok());
-        assert_eq!(circuit_breaker.state(), CircuitState::Closed);
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_opens_on_failures() {
-        let mock_provider = Arc::new(MockLlmProvider::new().fail_after(0)); // Always fail
-        let config = CircuitBreakerConfig::strict();
-        let circuit_breaker = CircuitBreaker::with_config(mock_provider, config);
-
-        let request = CompletionRequest::new("mock-gpt-3.5", vec![Message::user("Hello")]);
-
-        // Make enough requests to trigger circuit opening
-        for _ in 0..10 {
-            let _ = circuit_breaker.complete(request.clone()).await;
-        }
-
-        assert_eq!(circuit_breaker.state(), CircuitState::Open);
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_rejects_when_open() {
-        let mock_provider = Arc::new(MockLlmProvider::new().fail_after(0));
-        let config = CircuitBreakerConfig::strict();
-        let circuit_breaker = CircuitBreaker::with_config(mock_provider, config);
-
-        // Force circuit open
-        circuit_breaker.force_open();
-
-        let request = CompletionRequest::new("mock-gpt-3.5", vec![Message::user("Hello")]);
-
-        let result = circuit_breaker.complete(request).await;
-        assert!(matches!(result, Err(IntelligenceError::CircuitOpen { .. })));
-    }
-
-    #[tokio::test]
-    async fn test_max_repair_attempts() {
-        let mock_provider = Arc::new(MockLlmProvider::new().fail_after(0));
-        let config = CircuitBreakerConfig::strict();
-        let circuit_breaker = CircuitBreaker::with_config(mock_provider, config);
-
-        // Trigger circuit opening
-        let request = CompletionRequest::new("mock-gpt-3.5", vec![Message::user("Hello")]);
-
-        for _ in 0..10 {
-            let _ = circuit_breaker.complete(request.clone()).await;
-        }
-
-        assert_eq!(circuit_breaker.state(), CircuitState::Open);
-
-        // Wait for recovery timeout and trigger half-open
-        tokio::time::sleep(Duration::from_secs(16)).await;
-
-        // Should allow one repair attempt
-        let result = circuit_breaker.complete(request.clone()).await;
-        // This will fail and circuit should open again
-        assert!(result.is_err());
-
-        // Verify repair attempts were recorded
-        let stats = circuit_breaker.stats();
-        assert_eq!(stats.repair_attempts, 1);
-
-        // Wait again and try - should not transition to half-open due to max repair attempts
-        tokio::time::sleep(Duration::from_secs(16)).await;
-
-        // Should still be open and reject requests
-        let result = circuit_breaker.complete(request).await;
-        assert!(matches!(result, Err(IntelligenceError::CircuitOpen { .. })));
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_reset() {
-        let mock_provider = Arc::new(MockLlmProvider::new());
-        let circuit_breaker = CircuitBreaker::new(mock_provider);
-
-        circuit_breaker.force_open();
-        assert_eq!(circuit_breaker.state(), CircuitState::Open);
-
-        circuit_breaker.reset();
-        assert_eq!(circuit_breaker.state(), CircuitState::Closed);
-    }
-
-    #[tokio::test]
-    async fn test_circuit_breaker_stats() {
-        let mock_provider = Arc::new(MockLlmProvider::new());
-        let circuit_breaker = CircuitBreaker::new(mock_provider);
-
-        let request = CompletionRequest::new("mock-gpt-3.5", vec![Message::user("Hello")]);
+    use std::sync::atomic::AtomicU64;
 
-        // Make a successful request
-        circuit_breaker.complete(request).await.unwrap();
+    #[derive(Default, Debug)]
+    struct TestClock {
+        now: AtomicU64,
+    }
+
+    impl TestClock {
+        fn advance(&self, ms: u64) {
+            self.now.fetch_add(ms, Relaxed);
+        }
+
+        #[allow(dead_code)]
+        fn set(&self, ms: u64) {
+            self.now.store(ms, Relaxed);
+        }
+    }
+
+    impl Clock for TestClock {
+        fn now_ms(&self) -> u64 {
+            self.now.load(Relaxed)
+        }
+    }
+
+    #[test]
+    fn circuit_transitions_closed_open_halfopen_closed() {
+        let clock = Arc::new(TestClock::default());
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 3,
+                open_cooldown_ms: 5_000,
+                half_open_max_in_flight: 2,
+            },
+            clock.clone(),
+        );
+
+        // Initial state is Closed
+        assert_eq!(cb.state(), State::Closed);
+        assert!(cb.try_acquire().unwrap().is_none());
+
+        // 3 failures → Open
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Closed);
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Closed);
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Should reject while cool-down not elapsed
+        assert!(cb.try_acquire().is_err());
+
+        // Advance time to exit Open
+        clock.advance(5_000);
+
+        // First acquire transitions to HalfOpen and grants a permit
+        let permit = cb.try_acquire().expect("should get permit");
+        assert!(permit.is_some());
+        assert_eq!(cb.state(), State::HalfOpen);
+
+        // Success closes
+        cb.on_success();
+        assert_eq!(cb.state(), State::Closed);
+    }
+
+    #[test]
+    fn half_open_failure_reopens_immediately() {
+        let clock = Arc::new(TestClock::default());
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 2,
+                open_cooldown_ms: 1_000,
+                half_open_max_in_flight: 1,
+            },
+            clock.clone(),
+        );
+
+        // Trip to Open
+        cb.on_failure();
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Advance time and transition to HalfOpen
+        clock.advance(1_000);
+        // RAII guard: must remain in scope to transition circuit breaker state
+        let _permit = cb.try_acquire().expect("should get permit");
+        assert_eq!(cb.state(), State::HalfOpen);
+
+        // Failure in HalfOpen immediately reopens
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Should need to wait again
+        assert!(cb.try_acquire().is_err());
+
+        // After another cooldown
+        clock.advance(1_000);
+        assert!(cb.try_acquire().is_ok());
+    }
+
+    #[test]
+    fn half_open_respects_max_permits() {
+        let clock = Arc::new(TestClock::default());
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 1,
+                open_cooldown_ms: 100,
+                half_open_max_in_flight: 2,
+            },
+            clock.clone(),
+        );
+
+        // Trip to Open
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Advance time and transition to HalfOpen
+        clock.advance(100);
+
+        // Should allow exactly 2 permits
+        let p1 = cb.try_acquire().expect("first permit");
+        assert!(p1.is_some());
+        assert_eq!(cb.state(), State::HalfOpen);
+
+        let p2 = cb.try_acquire().expect("second permit");
+        assert!(p2.is_some());
+
+        // Third should be rejected (saturated)
+        assert!(cb.try_acquire().is_err());
+
+        // Release one permit and try again
+        drop(p1);
+
+        // Now should get another permit after dropping
+        let p3 = cb.try_acquire().expect("third permit after release");
+        assert!(p3.is_some());
+    }
+
+    #[tokio::test(start_paused = true)]
+    async fn circuit_breaker_with_tokio_time() {
+        use std::time::Duration;
+
+        let cb = CircuitBreaker::new(
+            Config {
+                failure_threshold: 3,
+                open_cooldown_ms: 5_000,
+                half_open_max_in_flight: 2,
+            },
+            Arc::new(RealClock),
+        );
+
+        // Note: with start_paused = true, we control time advancement
+        assert_eq!(cb.state(), State::Closed);
+
+        // Trip to Open
+        cb.on_failure();
+        cb.on_failure();
+        cb.on_failure();
+        assert_eq!(cb.state(), State::Open);
+
+        // Can't use try_acquire with RealClock in paused time directly,
+        // but we demonstrate the pattern
+        tokio::time::advance(Duration::from_millis(5_000)).await;
 
-        let stats = circuit_breaker.stats();
-        assert_eq!(stats.total_requests, 1);
-        assert_eq!(stats.successful_requests, 1);
-        assert_eq!(stats.failed_requests, 0);
+        // In real usage with RealClock, time has "passed"
+        // This test shows the structure without hanging
     }
 }
